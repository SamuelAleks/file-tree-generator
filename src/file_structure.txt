File Structure - C:\Users\SamuelA\source\repos\PaapeConversionKitRefactor\test
Scan Date: 2025-03-13 14:19:40
Extensions: .log, .sln, .xaml, .csproj, .cs, .axaml
================================================================================

DIRECTORY STRUCTURE SUMMARY
--------------------------------------------------------------------------------
📁 test (root)
│   📁 Application
│       📁 Services
│       │   📁 Parsers
│       │   └── 📄 ObjectSetParserImpl.cs
│       │   📁 Writers
│       │   └── 📄 ObjectSetWriterImpl.cs
│       ├── 📄 ComparisonService.cs
│       ├── 📄 ControllerModelService.cs
│       ├── 📄 ControllerService.cs
│       ├── 📄 ExportService.cs
│       ├── 📄 ParsingService.cs
│       ├── 📄 ProjectService.cs
│       └── 📄 XmlModificationService.cs
│   📁 Core
│   │   📁 Domain
│   │   │   📁 ObjectSet
│   │   │   └── 📄 ObjectSetModels.cs
│   │   ├── 📄 Controller.cs
│   │   ├── 📄 ControllerGroup.cs
│   │   ├── 📄 ControllerModelInfo.cs
│   │   ├── 📄 ControllerObject.cs
│   │   ├── 📄 CustomTypeFile.cs
│   │   ├── 📄 ImportedFile.cs
│   │   ├── 📄 Project.cs
│   │   ├── 📄 Session.cs
│   │   └── 📄 SharedType.cs
│   │   📁 Dto
│   │   ├── 📄 ControllerGroupDto.cs
│   │   └── 📄 SimilarityResultDto.cs
│   │   📁 Exceptions
│   │   ├── 📄 BusinessRuleException.cs
│   │   ├── 📄 DataAccessException.cs
│   │   ├── 📄 DomainExceptionBase.cs
│   │   ├── 📄 NotFoundException.cs
│   │   └── 📄 ParsingException.cs
│       📁 Interfaces
│       ├── 📄 IComparisonService.cs
│       ├── 📄 IControllerModelService.cs
│       ├── 📄 IControllerRepository.cs
│       ├── 📄 IDialogService.cs
│       ├── 📄 IErrorHandler.cs
│       ├── 📄 IExportService.cs
│       ├── 📄 IFileSystem.cs
│       ├── 📄 ILoggingService.cs
│       ├── 📄 INavigationService.cs
│       ├── 📄 IObjectSetParser.cs
│       ├── 📄 IObjectSetWriter.cs
│       ├── 📄 IProjectRepository.cs
│       ├── 📄 IRepository.cs
│       └── 📄 IXmlModificationService.cs
│   📁 Data
│   │   📁 Mapping
│   │   ├── 📄 ControllerGroupMapper.cs
│   │   ├── 📄 ControllerMapper.cs
│   │   ├── 📄 ObjectMapper.cs
│   │   ├── 📄 ParsedController.cs
│   │   ├── 📄 ParsedObject.cs
│   │   ├── 📄 ProjectMapper.cs
│   │   ├── 📄 SessionMapper.cs
│   │   └── 📄 SimilarityResultMapper.cs
│   ├── 📄 ParserDbContext.cs
│   └── 📄 SessionInfo.cs
│   📁 Infrastructure
│   │   📁 Data
│   │   ├── 📄 EfControllerRepository.cs
│   │   └── 📄 FileProjectRepository.cs
│   │   📁 FileSystem
│   │   └── 📄 PhysicalFileSystem.cs
│   │   📁 Logging
│   │   ├── 📄 ApplicationErrorHandler.cs
│   │   ├── 📄 ErrorHandlingExtensions.cs
│   │   └── 📄 LoggingService.cs
│   │   📁 Processing
│   │   └── 📄 ByteCodeProcessor.cs
│   │   📁 UI
│   │   │   📁 Converters
│   │   │   └── 📄 BoolToMarginConverter.cs
│   │   ├── 📄 AvaloniaDialogService.cs
│   │   └── 📄 AvaloniaNavigationService.cs
│   ├── 📄 AppBootstrapper.cs
│   ├── 📄 AppSettings.cs
│   ├── 📄 ServiceCollectionExtensions.cs
│   ├── 📄 SettingsManager.cs
│   └── 📄 SukiThemeExtensions.cs
│   📁 ViewModels
│   ├── 📄 ComparisonDemoViewModel.cs
│   ├── 📄 ExportDemoViewModel.cs
│   ├── 📄 IMenuItem.cs
│   ├── 📄 MainViewModel.cs
│   ├── 📄 ObjectSetViewModel.cs
│   ├── 📄 ProjectViewModel.cs
│   ├── 📄 ProjectsViewModel.cs
│   ├── 📄 SettingsViewModel.cs
│   └── 📄 ViewModelBase.cs
│   📁 Views
│   ├── 📄 BaseViewControl.cs
│   ├── 📄 ConvertersView.xaml
│   ├── 📄 ConvertersView.xaml.cs
│   ├── 📄 SettingsView.xaml
│   ├── 📄 SettingsView.xaml.cs
│   └── 📄 TextInputDialog.cs
├── 📄 App.axaml
├── 📄 App.axaml.cs
├── 📄 MainWindow.axaml
├── 📄 MainWindow.axaml.cs
├── 📄 Program.cs
├── 📄 ViewLocator.cs
└── 📄 test.csproj

Prioritized Folders (in order):
  1. Views
  2. ViewModels
  3. Models
  4. Services
  5. Helpers
  6. Converters

Prioritized Files (in order):
  1. App.xaml
  2. App.xaml.cs
  3. MainWindow.xaml
  4. MainWindow.xaml.cs

================================================================================

DETAILED FILE TREE WITH CONTENTS
--------------------------------------------------------------------------------
📁 test (root)
│   📁 Views
│   ├── 📄 BaseViewControl.cs (833.00 B, 2025-03-12 11:27:51)
│   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │ FILE CONTENT: BaseViewControl.cs
│   │   ├──────────────────────────────────────────────────────────────────────
│   │   │    1 │ ﻿using Avalonia;
│   │   │    2 │ using Avalonia.Controls;
│   │   │    3 │ 
│   │   │    4 │ namespace test.Views
│   │   │    5 │ {
│   │   │    6 │     public class BaseViewControl : UserControl
│   │   │    7 │     {
│   │   │    8 │         public BaseViewControl()
│   │   │    9 │         {
│   │   │   10 │             this.Padding = new Thickness(20);
│   │   │   11 │ 
│   │   │   12 │             // You could also make the padding configurable
│   │   │   13 │             var defaultPadding = Avalonia.Application.Current?.Resources["DefaultViewPadding"] as double? ?? 20;
│   │   │   14 │             this.Padding = new Thickness(defaultPadding);
│   │   │   15 │         }
│   │   │   16 │ 
│   │   │   17 │         public static readonly StyledProperty<bool> IsSideMenuExpandedProperty =
│   │   │   18 │         AvaloniaProperty.Register<BaseViewControl, bool>(nameof(IsSideMenuExpanded));
│   │   │   19 │ 
│   │   │   20 │         public bool IsSideMenuExpanded
│   │   │   21 │         {
│   │   │   22 │             get => GetValue(IsSideMenuExpandedProperty);
│   │   │   23 │             set => SetValue(IsSideMenuExpandedProperty, value);
│   │   │   24 │         }
│   │   │   25 │     }
│   │   │   26 │ }
│   │   └──────────────────────────────────────────────────────────────────────
│   ├── 📄 ConvertersView.xaml (757.00 B, 2025-03-11 09:48:27)
│   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │ FILE CONTENT: ConvertersView.xaml
│   │   ├──────────────────────────────────────────────────────────────────────
│   │   │    1 │ <UserControl
│   │   │    2 │     x:Class="test.Views.ConvertersView"
│   │   │    3 │     xmlns="https://github.com/avaloniaui"
│   │   │    4 │     xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
│   │   │    5 │     xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
│   │   │    6 │     xmlns:design="clr-namespace:Avalonia.Controls;assembly=Avalonia.Controls"
│   │   │    7 │     xmlns:icons="using:Material.Icons"
│   │   │    8 │     xmlns:local="using:test"
│   │   │    9 │     xmlns:material="using:Material.Icons.Avalonia"
│   │   │   10 │     xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
│   │   │   11 │     xmlns:suki="using:SukiUI.Controls"
│   │   │   12 │     xmlns:system="using:System"
│   │   │   13 │     xmlns:theme="clr-namespace:SukiUI.Theme;assembly=SukiUI"
│   │   │   14 │     d:DesignHeight="1500"
│   │   │   15 │     d:DesignWidth="800"
│   │   │   16 │     x:CompileBindings="True"
│   │   │   17 │     mc:Ignorable="d">
│   │   │   18 │ 
│   │   │   19 │ </UserControl>
│   │   └──────────────────────────────────────────────────────────────────────
│   ├── 📄 ConvertersView.xaml.cs (183.00 B, 2025-03-11 09:48:27)
│   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │ FILE CONTENT: ConvertersView.xaml.cs
│   │   ├──────────────────────────────────────────────────────────────────────
│   │   │    1 │ ﻿using Avalonia.Controls;
│   │   │    2 │ using Avalonia.Markup.Xaml;
│   │   │    3 │ using test.ViewModels;
│   │   │    4 │ 
│   │   │    5 │ namespace test.Views
│   │   │    6 │ {
│   │   │    7 │     public partial class ConvertersView : BaseViewControl
│   │   │    8 │     {
│   │   │    9 │     }
│   │   │   10 │ }
│   │   └──────────────────────────────────────────────────────────────────────
│   ├── 📄 SettingsView.xaml (10.10 KB, 2025-03-12 15:08:39)
│   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │ FILE CONTENT: SettingsView.xaml
│   │   ├──────────────────────────────────────────────────────────────────────
│   │   │    1 │ ﻿<UserControl
│   │   │    2 │     x:Class="test.Views.SettingsView"
│   │   │    3 │     xmlns="https://github.com/avaloniaui"
│   │   │    4 │     xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
│   │   │    5 │     xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
│   │   │    6 │     xmlns:material="using:Material.Icons.Avalonia"
│   │   │    7 │     xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
│   │   │    8 │     xmlns:suki="using:SukiUI.Controls"
│   │   │    9 │     xmlns:vm="using:test.ViewModels"
│   │   │   10 │     d:DesignHeight="650"
│   │   │   11 │     d:DesignWidth="800"
│   │   │   12 │     x:DataType="vm:SettingsViewModel"
│   │   │   13 │     Background="Red"
│   │   │   14 │     mc:Ignorable="d">
│   │   │   15 │ 
│   │   │   16 │     <ScrollViewer>
│   │   │   17 │         <Grid RowDefinitions="Auto,*">
│   │   │   18 │             <suki:GlassCard Grid.Row="0" Margin="4">
│   │   │   19 │                 <StackPanel>
│   │   │   20 │                     <Grid ColumnDefinitions="*,Auto">
│   │   │   21 │                         <TextBlock Classes="h1" Text="Settings" />
│   │   │   22 │                         <StackPanel
│   │   │   23 │                             Grid.Column="1"
│   │   │   24 │                             VerticalAlignment="Center"
│   │   │   25 │                             Orientation="Horizontal"
│   │   │   26 │                             Spacing="8">
│   │   │   27 │                             <material:MaterialIcon
│   │   │   28 │                                 Width="24"
│   │   │   29 │                                 Height="24"
│   │   │   30 │                                 Foreground="{DynamicResource SukiPrimaryColor}"
│   │   │   31 │                                 Kind="Cog" />
│   │   │   32 │                         </StackPanel>
│   │   │   33 │                     </Grid>
│   │   │   34 │ 
│   │   │   35 │                     <!--  Theme Settings  -->
│   │   │   36 │                     <suki:GroupBox Margin="0,16,0,0" Header="Appearance">
│   │   │   37 │                         <StackPanel Spacing="12">
│   │   │   38 │                             <Grid ColumnDefinitions="Auto,*,Auto">
│   │   │   39 │                                 <material:MaterialIcon
│   │   │   40 │                                     Grid.Column="0"
│   │   │   41 │                                     Width="24"
│   │   │   42 │                                     Height="24"
│   │   │   43 │                                     Margin="0,0,8,0"
│   │   │   44 │                                     VerticalAlignment="Center"
│   │   │   45 │                                     Foreground="{DynamicResource SukiPrimaryColor}"
│   │   │   46 │                                     Kind="ThemeLightDark" />
│   │   │   47 │                                 <TextBlock
│   │   │   48 │                                     Grid.Column="1"
│   │   │   49 │                                     VerticalAlignment="Center"
│   │   │   50 │                                     Text="Application Theme" />
│   │   │   51 │                                 <CheckBox
│   │   │   52 │                                     Grid.Column="2"
│   │   │   53 │                                     Content="Light Theme"
│   │   │   54 │                                     IsChecked="{Binding IsLightTheme}" />
│   │   │   55 │                             </Grid>
│   │   │   56 │ 
│   │   │   57 │                             <TextBlock
│   │   │   58 │                                 Foreground="{DynamicResource SukiLowEmphasisForeground}"
│   │   │   59 │                                 Opacity="{DynamicResource SukiLowEmphasisOpacity}"
│   │   │   60 │                                 Text="The theme will be applied immediately when changed. This setting will be remembered across application restarts."
│   │   │   61 │                                 TextWrapping="Wrap" />
│   │   │   62 │                         </StackPanel>
│   │   │   63 │                     </suki:GroupBox>
│   │   │   64 │ 
│   │   │   65 │                     <!--  Logging Settings  -->
│   │   │   66 │                     <suki:GroupBox Margin="0,16,0,0" Header="Logging">
│   │   │   67 │                         <StackPanel Spacing="12">
│   │   │   68 │                             <Grid ColumnDefinitions="Auto,*,Auto">
│   │   │   69 │                                 <material:MaterialIcon
│   │   │   70 │                                     Grid.Column="0"
│   │   │   71 │                                     Width="24"
│   │   │   72 │                                     Height="24"
│   │   │   73 │                                     Margin="0,0,8,0"
│   │   │   74 │                                     VerticalAlignment="Center"
│   │   │   75 │                                     Foreground="{DynamicResource SukiPrimaryColor}"
│   │   │   76 │                                     Kind="FileCog" />
│   │   │   77 │                                 <TextBlock
│   │   │   78 │                                     Grid.Column="1"
│   │   │   79 │                                     VerticalAlignment="Center"
│   │   │   80 │                                     Text="Application Logging" />
│   │   │   81 │                                 <CheckBox
│   │   │   82 │                                     Grid.Column="2"
│   │   │   83 │                                     Content="Enable Logging"
│   │   │   84 │                                     IsChecked="{Binding EnableLogging}" />
│   │   │   85 │                             </Grid>
│   │   │   86 │ 
│   │   │   87 │                             <StackPanel IsEnabled="{Binding EnableLogging}" Spacing="8">
│   │   │   88 │                                 <StackPanel Orientation="Horizontal" Spacing="8">
│   │   │   89 │                                     <TextBlock
│   │   │   90 │                                         Width="100"
│   │   │   91 │                                         VerticalAlignment="Center"
│   │   │   92 │                                         Text="Log Level:" />
│   │   │   93 │                                     <ComboBox
│   │   │   94 │                                         Width="200"
│   │   │   95 │                                         HorizontalAlignment="Left"
│   │   │   96 │                                         ItemsSource="{Binding LogLevels}"
│   │   │   97 │                                         SelectedItem="{Binding SelectedLogLevel}" />
│   │   │   98 │                                 </StackPanel>
│   │   │   99 │ 
│   │   │  100 │                                 <CheckBox Content="Delete logs on application exit" IsChecked="{Binding DeleteLogsOnExit}" />
│   │   │  101 │ 
│   │   │  102 │                                 <TextBlock
│   │   │  103 │                                     Foreground="{DynamicResource SukiLowEmphasisForeground}"
│   │   │  104 │                                     Opacity="{DynamicResource SukiLowEmphasisOpacity}"
│   │   │  105 │                                     Text="Higher log levels include more detailed information but may affect performance and use more disk space. Logs are stored in the application data folder."
│   │   │  106 │                                     TextWrapping="Wrap" />
│   │   │  107 │ 
│   │   │  108 │                                 <!--  Log file path display  -->
│   │   │  109 │                                 <StackPanel Margin="0,8,0,0" Spacing="4">
│   │   │  110 │                                     <TextBlock Text="Current log file:" />
│   │   │  111 │                                     <suki:GlassCard Padding="8">
│   │   │  112 │                                         <Grid ColumnDefinitions="*,Auto">
│   │   │  113 │                                             <TextBlock
│   │   │  114 │                                                 Grid.Column="0"
│   │   │  115 │                                                 Classes="caption"
│   │   │  116 │                                                 Text="{Binding LogFilePath}"
│   │   │  117 │                                                 TextWrapping="Wrap" />
│   │   │  118 │                                             <Button
│   │   │  119 │                                                 Grid.Column="1"
│   │   │  120 │                                                 Padding="4"
│   │   │  121 │                                                 VerticalAlignment="Center"
│   │   │  122 │                                                 Classes="Flat"
│   │   │  123 │                                                 ToolTip.Tip="Open logs folder">
│   │   │  124 │                                                 <material:MaterialIcon
│   │   │  125 │                                                     Width="16"
│   │   │  126 │                                                     Height="16"
│   │   │  127 │                                                     Kind="FolderOpen" />
│   │   │  128 │                                             </Button>
│   │   │  129 │                                         </Grid>
│   │   │  130 │                                     </suki:GlassCard>
│   │   │  131 │                                 </StackPanel>
│   │   │  132 │                             </StackPanel>
│   │   │  133 │                         </StackPanel>
│   │   │  134 │                     </suki:GroupBox>
│   │   │  135 │ 
│   │   │  136 │                     <!--  Settings Info  -->
│   │   │  137 │                     <suki:GroupBox Margin="0,16,0,16" Header="Settings Information">
│   │   │  138 │                         <StackPanel Spacing="8">
│   │   │  139 │                             <Grid ColumnDefinitions="Auto,*">
│   │   │  140 │                                 <material:MaterialIcon
│   │   │  141 │                                     Grid.Column="0"
│   │   │  142 │                                     Width="24"
│   │   │  143 │                                     Height="24"
│   │   │  144 │                                     Margin="0,0,8,0"
│   │   │  145 │                                     VerticalAlignment="Top"
│   │   │  146 │                                     Foreground="{DynamicResource SukiPrimaryColor}"
│   │   │  147 │                                     Kind="Information" />
│   │   │  148 │                                 <StackPanel Grid.Column="1" Spacing="8">
│   │   │  149 │                                     <TextBlock Text="Settings are automatically saved when changed and will persist between application restarts." TextWrapping="Wrap" />
│   │   │  150 │ 
│   │   │  151 │                                     <TextBlock Text="Settings file location:" />
│   │   │  152 │ 
│   │   │  153 │                                     <suki:GlassCard Padding="8">
│   │   │  154 │                                         <Grid ColumnDefinitions="*,Auto">
│   │   │  155 │                                             <TextBlock
│   │   │  156 │                                                 Grid.Column="0"
│   │   │  157 │                                                 Classes="caption"
│   │   │  158 │                                                 Text="{Binding SettingsPath}"
│   │   │  159 │                                                 TextWrapping="Wrap" />
│   │   │  160 │                                             <Button
│   │   │  161 │                                                 Grid.Column="1"
│   │   │  162 │                                                 Padding="4"
│   │   │  163 │                                                 VerticalAlignment="Center"
│   │   │  164 │                                                 Classes="Flat"
│   │   │  165 │                                                 ToolTip.Tip="Open settings folder">
│   │   │  166 │                                                 <material:MaterialIcon
│   │   │  167 │                                                     Width="16"
│   │   │  168 │                                                     Height="16"
│   │   │  169 │                                                     Kind="FolderOpen" />
│   │   │  170 │                                             </Button>
│   │   │  171 │                                         </Grid>
│   │   │  172 │                                     </suki:GlassCard>
│   │   │  173 │                                 </StackPanel>
│   │   │  174 │                             </Grid>
│   │   │  175 │                         </StackPanel>
│   │   │  176 │                     </suki:GroupBox>
│   │   │  177 │ 
│   │   │  178 │                     <!--  Save Button  -->
│   │   │  179 │                     <Button
│   │   │  180 │                         Margin="0,0,0,10"
│   │   │  181 │                         HorizontalAlignment="Right"
│   │   │  182 │                         Command="{Binding SaveSettingsCommand}"
│   │   │  183 │                         Content="Save Settings" />
│   │   │  184 │                 </StackPanel>
│   │   │  185 │             </suki:GlassCard>
│   │   │  186 │         </Grid>
│   │   │  187 │     </ScrollViewer>
│   │   │  188 │ </UserControl>
│   │   └──────────────────────────────────────────────────────────────────────
│   ├── 📄 SettingsView.xaml.cs (2.41 KB, 2025-03-12 15:03:18)
│   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │ FILE CONTENT: SettingsView.xaml.cs
│   │   ├──────────────────────────────────────────────────────────────────────
│   │   │    1 │ ﻿using Avalonia.Controls;
│   │   │    2 │ using Avalonia.Markup.Xaml;
│   │   │    3 │ using test.ViewModels;
│   │   │    4 │ using System;
│   │   │    5 │ using Microsoft.Extensions.Logging;
│   │   │    6 │ 
│   │   │    7 │ namespace test.Views
│   │   │    8 │ {
│   │   │    9 │     public partial class SettingsView : UserControl
│   │   │   10 │     {
│   │   │   11 │         private readonly ILogger<SettingsView> _logger;
│   │   │   12 │ 
│   │   │   13 │         // Default constructor for XAML designer and when created without DI
│   │   │   14 │         public SettingsView()
│   │   │   15 │         {
│   │   │   16 │             try
│   │   │   17 │             {
│   │   │   18 │                 InitializeComponent();
│   │   │   19 │             }
│   │   │   20 │             catch (Exception ex)
│   │   │   21 │             {
│   │   │   22 │                 // Can't log here since logger is null
│   │   │   23 │                 Console.WriteLine($"Error in SettingsView constructor: {ex.Message}");
│   │   │   24 │             }
│   │   │   25 │         }
│   │   │   26 │ 
│   │   │   27 │         // Constructor that accepts a logger and view model
│   │   │   28 │         public SettingsView(SettingsViewModel viewModel, ILogger<SettingsView> logger = null)
│   │   │   29 │         {
│   │   │   30 │             _logger = logger;
│   │   │   31 │ 
│   │   │   32 │             try
│   │   │   33 │             {
│   │   │   34 │                 // Set the DataContext first
│   │   │   35 │                 DataContext = viewModel;
│   │   │   36 │                 _logger?.LogInformation("SettingsView created with ViewModel: {ViewModel}", viewModel != null ? "provided" : "null");
│   │   │   37 │ 
│   │   │   38 │                 InitializeComponent();
│   │   │   39 │             }
│   │   │   40 │             catch (Exception ex)
│   │   │   41 │             {
│   │   │   42 │                 _logger?.LogError(ex, "Error in SettingsView constructor");
│   │   │   43 │             }
│   │   │   44 │         }
│   │   │   45 │ 
│   │   │   46 │         private void InitializeComponent()
│   │   │   47 │         {
│   │   │   48 │             try
│   │   │   49 │             {
│   │   │   50 │                 AvaloniaXamlLoader.Load(this);
│   │   │   51 │                 _logger?.LogDebug("SettingsView component initialized successfully");
│   │   │   52 │             }
│   │   │   53 │             catch (Exception ex)
│   │   │   54 │             {
│   │   │   55 │                 _logger?.LogError(ex, "Error in InitializeComponent");
│   │   │   56 │                 // Also write to console as a fallback
│   │   │   57 │                 Console.WriteLine($"Error in SettingsView.InitializeComponent: {ex.Message}");
│   │   │   58 │             }
│   │   │   59 │         }
│   │   │   60 │ 
│   │   │   61 │         // Override OnDataContextChanged to log when the DataContext changes
│   │   │   62 │         protected override void OnDataContextChanged(EventArgs e)
│   │   │   63 │         {
│   │   │   64 │             base.OnDataContextChanged(e);
│   │   │   65 │             
│   │   │   66 │             try
│   │   │   67 │             {
│   │   │   68 │                 _logger?.LogDebug("SettingsView DataContext changed to: {Type}", 
│   │   │   69 │                     DataContext?.GetType().Name ?? "null");
│   │   │   70 │             }
│   │   │   71 │             catch (Exception ex)
│   │   │   72 │             {
│   │   │   73 │                 _logger?.LogError(ex, "Error in OnDataContextChanged");
│   │   │   74 │             }
│   │   │   75 │         }
│   │   │   76 │     }
│   │   │   77 │ }
│   │   └──────────────────────────────────────────────────────────────────────
│   └── 📄 TextInputDialog.cs (4.89 KB, 2025-03-12 11:45:11)
│       ┌──────────────────────────────────────────────────────────────────────
│       │ FILE CONTENT: TextInputDialog.cs
│       ├──────────────────────────────────────────────────────────────────────
│       │    1 │ ﻿using Avalonia;
│       │    2 │ using Avalonia.Controls;
│       │    3 │ using Avalonia.Layout;
│       │    4 │ using Avalonia.Media;
│       │    5 │ using SukiUI.Controls;
│       │    6 │ using System.Threading.Tasks;
│       │    7 │ 
│       │    8 │ namespace test.Views
│       │    9 │ {
│       │   10 │     /// <summary>
│       │   11 │     /// A dialog for text input with SukiUI styling
│       │   12 │     /// </summary>
│       │   13 │     public class TextInputDialog
│       │   14 │     {
│       │   15 │         /// <summary>
│       │   16 │         /// The dialog title
│       │   17 │         /// </summary>
│       │   18 │         public string Title { get; set; } = "Input";
│       │   19 │ 
│       │   20 │         /// <summary>
│       │   21 │         /// The message to display
│       │   22 │         /// </summary>
│       │   23 │         public string Message { get; set; } = "Please enter a value:";
│       │   24 │ 
│       │   25 │         /// <summary>
│       │   26 │         /// The default value for the input
│       │   27 │         /// </summary>
│       │   28 │         public string DefaultValue { get; set; } = "";
│       │   29 │ 
│       │   30 │         /// <summary>
│       │   31 │         /// The placeholder text for the input field
│       │   32 │         /// </summary>
│       │   33 │         public string Placeholder { get; set; } = "";
│       │   34 │ 
│       │   35 │         /// <summary>
│       │   36 │         /// Whether to enable OK button even when the input is empty
│       │   37 │         /// </summary>
│       │   38 │         public bool AllowEmpty { get; set; } = false;
│       │   39 │ 
│       │   40 │         /// <summary>
│       │   41 │         /// Shows the dialog and waits for user input
│       │   42 │         /// </summary>
│       │   43 │         /// <param name="parent">The parent window</param>
│       │   44 │         /// <returns>The entered value or null if cancelled</returns>
│       │   45 │         public async Task<string> ShowAsync(Window parent)
│       │   46 │         {
│       │   47 │             // Create the dialog window with SukiUI styling
│       │   48 │             var dialog = new SukiWindow
│       │   49 │             {
│       │   50 │                 Title = Title,
│       │   51 │                 Width = 400,
│       │   52 │                 Height = 200,
│       │   53 │                 WindowStartupLocation = WindowStartupLocation.CenterOwner
│       │   54 │             };
│       │   55 │ 
│       │   56 │             var mainPanel = new StackPanel
│       │   57 │             {
│       │   58 │                 Margin = new Thickness(20)
│       │   59 │             };
│       │   60 │ 
│       │   61 │             // Add message
│       │   62 │             if (!string.IsNullOrEmpty(Message))
│       │   63 │             {
│       │   64 │                 mainPanel.Children.Add(new TextBlock
│       │   65 │                 {
│       │   66 │                     Text = Message,
│       │   67 │                     TextWrapping = TextWrapping.Wrap,
│       │   68 │                     Margin = new Thickness(0, 0, 0, 10)
│       │   69 │                 });
│       │   70 │             }
│       │   71 │ 
│       │   72 │             // Add input field
│       │   73 │             var textBox = new TextBox
│       │   74 │             {
│       │   75 │                 Text = DefaultValue,
│       │   76 │                 Watermark = Placeholder,
│       │   77 │                 Margin = new Thickness(0, 0, 0, 20)
│       │   78 │             };
│       │   79 │             mainPanel.Children.Add(textBox);
│       │   80 │ 
│       │   81 │             // Create button panel
│       │   82 │             var buttonPanel = new StackPanel
│       │   83 │             {
│       │   84 │                 Orientation = Orientation.Horizontal,
│       │   85 │                 HorizontalAlignment = HorizontalAlignment.Right,
│       │   86 │                 Spacing = 10
│       │   87 │             };
│       │   88 │ 
│       │   89 │             // Add cancel button
│       │   90 │             var cancelButton = new Button
│       │   91 │             {
│       │   92 │                 Content = "Cancel",
│       │   93 │                 Classes = { "Basic" },
│       │   94 │                 MinWidth = 80
│       │   95 │             };
│       │   96 │ 
│       │   97 │             // Add OK button
│       │   98 │             var okButton = new Button
│       │   99 │             {
│       │  100 │                 Content = "OK",
│       │  101 │                 Classes = { "Accent" },
│       │  102 │                 MinWidth = 80,
│       │  103 │                 IsEnabled = !string.IsNullOrEmpty(DefaultValue) || AllowEmpty
│       │  104 │             };
│       │  105 │ 
│       │  106 │             // Handle text changes to enable/disable OK button
│       │  107 │             if (!AllowEmpty)
│       │  108 │             {
│       │  109 │                 textBox.PropertyChanged += (s, e) =>
│       │  110 │                 {
│       │  111 │                     if (e.Property.Name == nameof(TextBox.Text))
│       │  112 │                     {
│       │  113 │                         okButton.IsEnabled = !string.IsNullOrEmpty(textBox.Text);
│       │  114 │                     }
│       │  115 │                 };
│       │  116 │             }
│       │  117 │ 
│       │  118 │             // Set up result capturing
│       │  119 │             string result = null;
│       │  120 │ 
│       │  121 │             // Set up button handlers
│       │  122 │             okButton.Click += (s, e) =>
│       │  123 │             {
│       │  124 │                 result = textBox.Text;
│       │  125 │                 dialog.Close();
│       │  126 │             };
│       │  127 │ 
│       │  128 │             cancelButton.Click += (s, e) =>
│       │  129 │             {
│       │  130 │                 dialog.Close();
│       │  131 │             };
│       │  132 │ 
│       │  133 │             // Add buttons to panel
│       │  134 │             buttonPanel.Children.Add(cancelButton);
│       │  135 │             buttonPanel.Children.Add(okButton);
│       │  136 │             mainPanel.Children.Add(buttonPanel);
│       │  137 │ 
│       │  138 │             // Add keyboard navigation
│       │  139 │             textBox.KeyDown += (s, e) =>
│       │  140 │             {
│       │  141 │                 if (e.Key == Avalonia.Input.Key.Enter && okButton.IsEnabled)
│       │  142 │                 {
│       │  143 │                     result = textBox.Text;
│       │  144 │                     dialog.Close();
│       │  145 │                 }
│       │  146 │                 else if (e.Key == Avalonia.Input.Key.Escape)
│       │  147 │                 {
│       │  148 │                     dialog.Close();
│       │  149 │                 }
│       │  150 │             };
│       │  151 │ 
│       │  152 │             // Set dialog content
│       │  153 │             dialog.Content = new GlassCard
│       │  154 │             {
│       │  155 │                 Content = mainPanel,
│       │  156 │                 Margin = new Thickness(10)
│       │  157 │             };
│       │  158 │ 
│       │  159 │             // Show dialog
│       │  160 │             await dialog.ShowDialog(parent);
│       │  161 │ 
│       │  162 │             // Return result (null if cancelled)
│       │  163 │             return result;
│       │  164 │         }
│       │  165 │     }
│       │  166 │ }
│       └──────────────────────────────────────────────────────────────────────
│   📁 ViewModels
│   ├── 📄 ComparisonDemoViewModel.cs (14.22 KB, 2025-03-12 07:48:31)
│   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │ FILE CONTENT: ComparisonDemoViewModel.cs
│   │   ├──────────────────────────────────────────────────────────────────────
│   │   │    1 │ ﻿using System;
│   │   │    2 │ using System.Collections.Generic;
│   │   │    3 │ using System.Collections.ObjectModel;
│   │   │    4 │ using System.IO;
│   │   │    5 │ using System.Linq;
│   │   │    6 │ using System.Threading.Tasks;
│   │   │    7 │ using CommunityToolkit.Mvvm.Input;
│   │   │    8 │ using test.Application.Services;
│   │   │    9 │ using test.Core.Domain;
│   │   │   10 │ using test.Core.Dto;
│   │   │   11 │ using test.Core.Interfaces;
│   │   │   12 │ using Avalonia.Controls;
│   │   │   13 │ 
│   │   │   14 │ namespace test.ViewModels
│   │   │   15 │ {
│   │   │   16 │     /// <summary>
│   │   │   17 │     /// A simple view model for demonstrating the use of ComparisonService
│   │   │   18 │     /// This is just a proof of concept, not intended for production use
│   │   │   19 │     /// </summary>
│   │   │   20 │     public class ComparisonDemoViewModel : ViewModelBase
│   │   │   21 │     {
│   │   │   22 │         private readonly IComparisonService _comparisonService;
│   │   │   23 │         private readonly IDialogService _dialogService;
│   │   │   24 │         private readonly ControllerService _controllerService;
│   │   │   25 │ 
│   │   │   26 │         private string _selectedSessionId;
│   │   │   27 │         private string _xmlFilePath;
│   │   │   28 │         private string _comparisonResultSummary;
│   │   │   29 │         private ObservableCollection<string> _availableSessions = new();
│   │   │   30 │         private ObservableCollection<Controller> _controllers = new();
│   │   │   31 │         private ObservableCollection<ComparisonResult> _comparisonResults = new();
│   │   │   32 │         private ObservableCollection<SimilarityResultDto> _similarityResults = new(); // Changed from SimilarityResult to SimilarityResultDto
│   │   │   33 │         private double _minimumSimilarity = 0.7;
│   │   │   34 │         private bool _returnBestMatchesRegardless;
│   │   │   35 │         private int _numberOfGroupsToMatch = 3;
│   │   │   36 │ 
│   │   │   37 │         /// <summary>
│   │   │   38 │         /// Available sessions
│   │   │   39 │         /// </summary>
│   │   │   40 │         public ObservableCollection<string> AvailableSessions
│   │   │   41 │         {
│   │   │   42 │             get => _availableSessions;
│   │   │   43 │             set => SetProperty(ref _availableSessions, value);
│   │   │   44 │         }
│   │   │   45 │ 
│   │   │   46 │         /// <summary>
│   │   │   47 │         /// Selected session ID
│   │   │   48 │         /// </summary>
│   │   │   49 │         public string SelectedSessionId
│   │   │   50 │         {
│   │   │   51 │             get => _selectedSessionId;
│   │   │   52 │             set
│   │   │   53 │             {
│   │   │   54 │                 if (SetProperty(ref _selectedSessionId, value))
│   │   │   55 │                 {
│   │   │   56 │                     LoadSessionDataCommand.ExecuteAsync(null);
│   │   │   57 │                 }
│   │   │   58 │             }
│   │   │   59 │         }
│   │   │   60 │ 
│   │   │   61 │         /// <summary>
│   │   │   62 │         /// Controllers in selected session
│   │   │   63 │         /// </summary>
│   │   │   64 │         public ObservableCollection<Controller> Controllers
│   │   │   65 │         {
│   │   │   66 │             get => _controllers;
│   │   │   67 │             set => SetProperty(ref _controllers, value);
│   │   │   68 │         }
│   │   │   69 │ 
│   │   │   70 │         /// <summary>
│   │   │   71 │         /// XML file path
│   │   │   72 │         /// </summary>
│   │   │   73 │         public string XmlFilePath
│   │   │   74 │         {
│   │   │   75 │             get => _xmlFilePath;
│   │   │   76 │             set => SetProperty(ref _xmlFilePath, value);
│   │   │   77 │         }
│   │   │   78 │ 
│   │   │   79 │         /// <summary>
│   │   │   80 │         /// Comparison results
│   │   │   81 │         /// </summary>
│   │   │   82 │         public ObservableCollection<ComparisonResult> ComparisonResults
│   │   │   83 │         {
│   │   │   84 │             get => _comparisonResults;
│   │   │   85 │             set => SetProperty(ref _comparisonResults, value);
│   │   │   86 │         }
│   │   │   87 │ 
│   │   │   88 │         /// <summary>
│   │   │   89 │         /// Similarity results
│   │   │   90 │         /// </summary>
│   │   │   91 │         public ObservableCollection<SimilarityResultDto> SimilarityResults // Changed from SimilarityResult to SimilarityResultDto
│   │   │   92 │         {
│   │   │   93 │             get => _similarityResults;
│   │   │   94 │             set => SetProperty(ref _similarityResults, value);
│   │   │   95 │         }
│   │   │   96 │ 
│   │   │   97 │         /// <summary>
│   │   │   98 │         /// Summary of comparison results
│   │   │   99 │         /// </summary>
│   │   │  100 │         public string ComparisonResultSummary
│   │   │  101 │         {
│   │   │  102 │             get => _comparisonResultSummary;
│   │   │  103 │             set => SetProperty(ref _comparisonResultSummary, value);
│   │   │  104 │         }
│   │   │  105 │ 
│   │   │  106 │         /// <summary>
│   │   │  107 │         /// Minimum similarity threshold
│   │   │  108 │         /// </summary>
│   │   │  109 │         public double MinimumSimilarity
│   │   │  110 │         {
│   │   │  111 │             get => _minimumSimilarity;
│   │   │  112 │             set => SetProperty(ref _minimumSimilarity, value);
│   │   │  113 │         }
│   │   │  114 │ 
│   │   │  115 │         /// <summary>
│   │   │  116 │         /// Whether to return best matches regardless of threshold
│   │   │  117 │         /// </summary>
│   │   │  118 │         public bool ReturnBestMatchesRegardless
│   │   │  119 │         {
│   │   │  120 │             get => _returnBestMatchesRegardless;
│   │   │  121 │             set => SetProperty(ref _returnBestMatchesRegardless, value);
│   │   │  122 │         }
│   │   │  123 │ 
│   │   │  124 │         /// <summary>
│   │   │  125 │         /// Number of groups to match
│   │   │  126 │         /// </summary>
│   │   │  127 │         public int NumberOfGroupsToMatch
│   │   │  128 │         {
│   │   │  129 │             get => _numberOfGroupsToMatch;
│   │   │  130 │             set => SetProperty(ref _numberOfGroupsToMatch, value);
│   │   │  131 │         }
│   │   │  132 │ 
│   │   │  133 │         /// <summary>
│   │   │  134 │         /// Command to load available sessions
│   │   │  135 │         /// </summary>
│   │   │  136 │         public IAsyncRelayCommand LoadSessionsCommand { get; }
│   │   │  137 │ 
│   │   │  138 │         /// <summary>
│   │   │  139 │         /// Command to load data from selected session
│   │   │  140 │         /// </summary>
│   │   │  141 │         public IAsyncRelayCommand LoadSessionDataCommand { get; }
│   │   │  142 │ 
│   │   │  143 │         /// <summary>
│   │   │  144 │         /// Command to select XML file
│   │   │  145 │         /// </summary>
│   │   │  146 │         public IAsyncRelayCommand SelectXmlFileCommand { get; }
│   │   │  147 │ 
│   │   │  148 │         /// <summary>
│   │   │  149 │         /// Command to compare controllers with XML
│   │   │  150 │         /// </summary>
│   │   │  151 │         public IAsyncRelayCommand CompareWithXmlCommand { get; }
│   │   │  152 │ 
│   │   │  153 │         /// <summary>
│   │   │  154 │         /// Command to find similar controllers
│   │   │  155 │         /// </summary>
│   │   │  156 │         public IAsyncRelayCommand FindSimilarControllersCommand { get; }
│   │   │  157 │ 
│   │   │  158 │         /// <summary>
│   │   │  159 │         /// Command to generate modified XML
│   │   │  160 │         /// </summary>
│   │   │  161 │         public IAsyncRelayCommand<Controller> GenerateModifiedXmlCommand { get; }
│   │   │  162 │ 
│   │   │  163 │         /// <summary>
│   │   │  164 │         /// Creates a new comparison demo view model
│   │   │  165 │         /// </summary>
│   │   │  166 │         /// <param name="comparisonService">The comparison service</param>
│   │   │  167 │         /// <param name="dialogService">The dialog service</param>
│   │   │  168 │         /// <param name="controllerService">The controller service</param>
│   │   │  169 │         public ComparisonDemoViewModel(
│   │   │  170 │             IComparisonService comparisonService,
│   │   │  171 │             IDialogService dialogService,
│   │   │  172 │             ControllerService controllerService)
│   │   │  173 │         {
│   │   │  174 │             _comparisonService = comparisonService ?? throw new ArgumentNullException(nameof(comparisonService));
│   │   │  175 │             _dialogService = dialogService ?? throw new ArgumentNullException(nameof(dialogService));
│   │   │  176 │             _controllerService = controllerService ?? throw new ArgumentNullException(nameof(controllerService));
│   │   │  177 │ 
│   │   │  178 │             // Initialize commands
│   │   │  179 │             LoadSessionsCommand = new AsyncRelayCommand(LoadSessionsAsync);
│   │   │  180 │             LoadSessionDataCommand = new AsyncRelayCommand(LoadSessionDataAsync);
│   │   │  181 │             SelectXmlFileCommand = new AsyncRelayCommand(SelectXmlFileAsync);
│   │   │  182 │             CompareWithXmlCommand = new AsyncRelayCommand(CompareWithXmlAsync, CanCompareWithXml);
│   │   │  183 │             FindSimilarControllersCommand = new AsyncRelayCommand(FindSimilarControllersAsync, CanFindSimilarControllers);
│   │   │  184 │             GenerateModifiedXmlCommand = new AsyncRelayCommand<Controller>(GenerateModifiedXmlAsync, CanGenerateModifiedXml);
│   │   │  185 │ 
│   │   │  186 │             // Load sessions on startup
│   │   │  187 │             LoadSessionsCommand.ExecuteAsync(null);
│   │   │  188 │         }
│   │   │  189 │ 
│   │   │  190 │         /// <summary>
│   │   │  191 │         /// Loads available sessions
│   │   │  192 │         /// </summary>
│   │   │  193 │         private async Task LoadSessionsAsync()
│   │   │  194 │         {
│   │   │  195 │             await ExecuteWithBusyIndicationAsync(async () =>
│   │   │  196 │             {
│   │   │  197 │                 var sessions = await _controllerService.GetAllSessionsAsync();
│   │   │  198 │                 AvailableSessions.Clear();
│   │   │  199 │ 
│   │   │  200 │                 foreach (var session in sessions)
│   │   │  201 │                 {
│   │   │  202 │                     AvailableSessions.Add(session.SessionId);
│   │   │  203 │                 }
│   │   │  204 │ 
│   │   │  205 │                 if (AvailableSessions.Any())
│   │   │  206 │                 {
│   │   │  207 │                     SelectedSessionId = AvailableSessions.First();
│   │   │  208 │                 }
│   │   │  209 │             }, "Sessions loaded successfully", "Failed to load sessions");
│   │   │  210 │         }
│   │   │  211 │ 
│   │   │  212 │         /// <summary>
│   │   │  213 │         /// Loads data from selected session
│   │   │  214 │         /// </summary>
│   │   │  215 │         private async Task LoadSessionDataAsync()
│   │   │  216 │         {
│   │   │  217 │             if (string.IsNullOrEmpty(SelectedSessionId))
│   │   │  218 │                 return;
│   │   │  219 │ 
│   │   │  220 │             await ExecuteWithBusyIndicationAsync(async () =>
│   │   │  221 │             {
│   │   │  222 │                 var controllers = await _controllerService.GetControllersBySessionAsync(SelectedSessionId);
│   │   │  223 │                 Controllers = new ObservableCollection<Controller>(controllers);
│   │   │  224 │             }, "Session data loaded successfully", "Failed to load session data");
│   │   │  225 │         }
│   │   │  226 │ 
│   │   │  227 │         /// <summary>
│   │   │  228 │         /// Selects XML file
│   │   │  229 │         /// </summary>
│   │   │  230 │         private async Task SelectXmlFileAsync()
│   │   │  231 │         {
│   │   │  232 │             var filters = new List<FileDialogFilter>
│   │   │  233 │             {
│   │   │  234 │                 new FileDialogFilter
│   │   │  235 │                 {
│   │   │  236 │                     Name = "XML Files",
│   │   │  237 │                     Extensions = new List<string> { "xml" }
│   │   │  238 │                 }
│   │   │  239 │             };
│   │   │  240 │ 
│   │   │  241 │             var filePath = await _dialogService.ShowOpenFileDialogAsync(
│   │   │  242 │                 "Select XML File",
│   │   │  243 │                 filters);
│   │   │  244 │ 
│   │   │  245 │             if (filePath?.Length > 0)
│   │   │  246 │             {
│   │   │  247 │                 XmlFilePath = filePath[0];
│   │   │  248 │                 CompareWithXmlCommand.NotifyCanExecuteChanged();
│   │   │  249 │                 FindSimilarControllersCommand.NotifyCanExecuteChanged();
│   │   │  250 │             }
│   │   │  251 │         }
│   │   │  252 │ 
│   │   │  253 │         /// <summary>
│   │   │  254 │         /// Compares controllers with XML
│   │   │  255 │         /// </summary>
│   │   │  256 │         private async Task CompareWithXmlAsync()
│   │   │  257 │         {
│   │   │  258 │             if (string.IsNullOrEmpty(XmlFilePath) || !Controllers.Any())
│   │   │  259 │                 return;
│   │   │  260 │ 
│   │   │  261 │             await ExecuteWithBusyIndicationAsync(async () =>
│   │   │  262 │             {
│   │   │  263 │                 // Read XML content
│   │   │  264 │                 var xmlContent = await File.ReadAllTextAsync(XmlFilePath);
│   │   │  265 │ 
│   │   │  266 │                 // Perform comparison
│   │   │  267 │                 var comparisons = await _comparisonService.CompareWithXmlAsync(xmlContent, Controllers);
│   │   │  268 │ 
│   │   │  269 │                 // Update UI
│   │   │  270 │                 ComparisonResults = new ObservableCollection<ComparisonResult>(comparisons);
│   │   │  271 │ 
│   │   │  272 │                 // Generate summary
│   │   │  273 │                 var matchCount = comparisons.Count(c => c.IsMatch);
│   │   │  274 │                 var totalCount = comparisons.Count();
│   │   │  275 │                 var matchPercentage = totalCount > 0 ? (double)matchCount / totalCount * 100 : 0;
│   │   │  276 │ 
│   │   │  277 │                 ComparisonResultSummary = $"Matched {matchCount} of {totalCount} values ({matchPercentage:F1}%)";
│   │   │  278 │             }, "Comparison completed successfully", "Failed to compare with XML");
│   │   │  279 │         }
│   │   │  280 │ 
│   │   │  281 │         /// <summary>
│   │   │  282 │         /// Finds similar controllers
│   │   │  283 │         /// </summary>
│   │   │  284 │         private async Task FindSimilarControllersAsync()
│   │   │  285 │         {
│   │   │  286 │             if (string.IsNullOrEmpty(XmlFilePath) || !Controllers.Any())
│   │   │  287 │                 return;
│   │   │  288 │ 
│   │   │  289 │             await ExecuteWithBusyIndicationAsync(async () =>
│   │   │  290 │             {
│   │   │  291 │                 // Read XML content
│   │   │  292 │                 var xmlContent = await File.ReadAllTextAsync(XmlFilePath);
│   │   │  293 │ 
│   │   │  294 │                 // Configure options
│   │   │  295 │                 var options = new GroupingOptions
│   │   │  296 │                 {
│   │   │  297 │                     MinimumSimilarityThreshold = MinimumSimilarity,
│   │   │  298 │                     ReturnBestMatchesRegardless = ReturnBestMatchesRegardless,
│   │   │  299 │                     NumberOfGroupsToMatch = NumberOfGroupsToMatch
│   │   │  300 │                 };
│   │   │  301 │ 
│   │   │  302 │                 // Find similar controllers
│   │   │  303 │                 var similarities = await _comparisonService.FindSimilarControllersAsync(xmlContent, Controllers, options);
│   │   │  304 │ 
│   │   │  305 │                 // Update UI 
│   │   │  306 │                 SimilarityResults = new ObservableCollection<SimilarityResultDto>(similarities); // Changed from SimilarityResult to SimilarityResultDto
│   │   │  307 │ 
│   │   │  308 │                 // Generate summary
│   │   │  309 │                 if (similarities.Any())
│   │   │  310 │                 {
│   │   │  311 │                     ComparisonResultSummary = $"Found {similarities.Count()} similar controller groups";
│   │   │  312 │                 }
│   │   │  313 │                 else
│   │   │  314 │                 {
│   │   │  315 │                     ComparisonResultSummary = "No similar controllers found";
│   │   │  316 │                 }
│   │   │  317 │             }, "Similarity search completed successfully", "Failed to find similar controllers");
│   │   │  318 │         }
│   │   │  319 │ 
│   │   │  320 │         /// <summary>
│   │   │  321 │         /// Generates modified XML
│   │   │  322 │         /// </summary>
│   │   │  323 │         private async Task GenerateModifiedXmlAsync(Controller controller)
│   │   │  324 │         {
│   │   │  325 │             if (controller == null || string.IsNullOrEmpty(XmlFilePath))
│   │   │  326 │                 return;
│   │   │  327 │ 
│   │   │  328 │             await ExecuteWithBusyIndicationAsync(async () =>
│   │   │  329 │             {
│   │   │  330 │                 // Read XML content
│   │   │  331 │                 var xmlContent = await File.ReadAllTextAsync(XmlFilePath);
│   │   │  332 │ 
│   │   │  333 │                 // Get target name
│   │   │  334 │                 var targetName = await _dialogService.ShowInputDialogAsync(
│   │   │  335 │                     "Target Name",
│   │   │  336 │                     "Enter target name for the modified XML:",
│   │   │  337 │                     controller.Name);
│   │   │  338 │ 
│   │   │  339 │                 if (string.IsNullOrEmpty(targetName))
│   │   │  340 │                     return;
│   │   │  341 │ 
│   │   │  342 │                 // Generate modified XML
│   │   │  343 │                 var modifiedXml = await _comparisonService.GenerateModifiedXmlAsync(xmlContent, controller, targetName);
│   │   │  344 │ 
│   │   │  345 │                 // Save modified XML
│   │   │  346 │                 var filters = new List<FileDialogFilter>
│   │   │  347 │                 {
│   │   │  348 │                     new FileDialogFilter
│   │   │  349 │                     {
│   │   │  350 │                         Name = "XML Files",
│   │   │  351 │                         Extensions = new List<string> { "xml" }
│   │   │  352 │                     }
│   │   │  353 │                 };
│   │   │  354 │ 
│   │   │  355 │                 var savePath = await _dialogService.ShowSaveFileDialogAsync(
│   │   │  356 │                     "Save Modified XML",
│   │   │  357 │                     "xml",
│   │   │  358 │                     filters);
│   │   │  359 │ 
│   │   │  360 │                 if (!string.IsNullOrEmpty(savePath))
│   │   │  361 │                 {
│   │   │  362 │                     await File.WriteAllTextAsync(savePath, modifiedXml);
│   │   │  363 │                     ComparisonResultSummary = $"Modified XML saved to {Path.GetFileName(savePath)}";
│   │   │  364 │                 }
│   │   │  365 │             }, "Modified XML generated successfully", "Failed to generate modified XML");
│   │   │  366 │         }
│   │   │  367 │ 
│   │   │  368 │         /// <summary>
│   │   │  369 │         /// Determines whether comparison is possible
│   │   │  370 │         /// </summary>
│   │   │  371 │         private bool CanCompareWithXml()
│   │   │  372 │         {
│   │   │  373 │             return !string.IsNullOrEmpty(XmlFilePath) && Controllers.Any();
│   │   │  374 │         }
│   │   │  375 │ 
│   │   │  376 │         /// <summary>
│   │   │  377 │         /// Determines whether similarity search is possible
│   │   │  378 │         /// </summary>
│   │   │  379 │         private bool CanFindSimilarControllers()
│   │   │  380 │         {
│   │   │  381 │             return !string.IsNullOrEmpty(XmlFilePath) && Controllers.Any();
│   │   │  382 │         }
│   │   │  383 │ 
│   │   │  384 │         /// <summary>
│   │   │  385 │         /// Determines whether XML modification is possible
│   │   │  386 │         /// </summary>
│   │   │  387 │         private bool CanGenerateModifiedXml(Controller controller)
│   │   │  388 │         {
│   │   │  389 │             return controller != null && !string.IsNullOrEmpty(XmlFilePath);
│   │   │  390 │         }
│   │   │  391 │     }
│   │   │  392 │ }
│   │   └──────────────────────────────────────────────────────────────────────
│   ├── 📄 ExportDemoViewModel.cs (10.15 KB, 2025-03-11 09:48:27)
│   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │ FILE CONTENT: ExportDemoViewModel.cs
│   │   ├──────────────────────────────────────────────────────────────────────
│   │   │    1 │ ﻿using System;
│   │   │    2 │ using System.Collections.Generic;
│   │   │    3 │ using System.Collections.ObjectModel;
│   │   │    4 │ using System.IO;
│   │   │    5 │ using System.Linq;
│   │   │    6 │ using System.Threading.Tasks;
│   │   │    7 │ using Avalonia.Controls;
│   │   │    8 │ using CommunityToolkit.Mvvm.Input;
│   │   │    9 │ using test.Application.Services;
│   │   │   10 │ using test.Core.Domain;
│   │   │   11 │ using test.Core.Interfaces;
│   │   │   12 │ 
│   │   │   13 │ namespace test.ViewModels
│   │   │   14 │ {
│   │   │   15 │     /// <summary>
│   │   │   16 │     /// A simple view model for demonstrating the use of ExportService
│   │   │   17 │     /// This is just a proof of concept, not intended for production use
│   │   │   18 │     /// </summary>
│   │   │   19 │     public class ExportDemoViewModel : ViewModelBase
│   │   │   20 │     {
│   │   │   21 │         private readonly IExportService _exportService;
│   │   │   22 │         private readonly IDialogService _dialogService;
│   │   │   23 │         private readonly ControllerService _controllerService;
│   │   │   24 │ 
│   │   │   25 │         private string _selectedSessionId;
│   │   │   26 │         private string _exportPath;
│   │   │   27 │         private ObservableCollection<string> _availableSessions = new();
│   │   │   28 │         private ObservableCollection<Controller> _controllers = new();
│   │   │   29 │         private ObservableCollection<ExportFormat> _exportFormats = new();
│   │   │   30 │         private ExportFormat _selectedFormat;
│   │   │   31 │         private int _controllerCount;
│   │   │   32 │         private int _objectCount;
│   │   │   33 │ 
│   │   │   34 │         /// <summary>
│   │   │   35 │         /// Available sessions
│   │   │   36 │         /// </summary>
│   │   │   37 │         public ObservableCollection<string> AvailableSessions
│   │   │   38 │         {
│   │   │   39 │             get => _availableSessions;
│   │   │   40 │             set => SetProperty(ref _availableSessions, value);
│   │   │   41 │         }
│   │   │   42 │ 
│   │   │   43 │         /// <summary>
│   │   │   44 │         /// Selected session ID
│   │   │   45 │         /// </summary>
│   │   │   46 │         public string SelectedSessionId
│   │   │   47 │         {
│   │   │   48 │             get => _selectedSessionId;
│   │   │   49 │             set
│   │   │   50 │             {
│   │   │   51 │                 if (SetProperty(ref _selectedSessionId, value))
│   │   │   52 │                 {
│   │   │   53 │                     LoadSessionDataCommand.ExecuteAsync(null);
│   │   │   54 │                 }
│   │   │   55 │             }
│   │   │   56 │         }
│   │   │   57 │ 
│   │   │   58 │         /// <summary>
│   │   │   59 │         /// Controllers in selected session
│   │   │   60 │         /// </summary>
│   │   │   61 │         public ObservableCollection<Controller> Controllers
│   │   │   62 │         {
│   │   │   63 │             get => _controllers;
│   │   │   64 │             set => SetProperty(ref _controllers, value);
│   │   │   65 │         }
│   │   │   66 │ 
│   │   │   67 │         /// <summary>
│   │   │   68 │         /// Count of controllers
│   │   │   69 │         /// </summary>
│   │   │   70 │         public int ControllerCount
│   │   │   71 │         {
│   │   │   72 │             get => _controllerCount;
│   │   │   73 │             set => SetProperty(ref _controllerCount, value);
│   │   │   74 │         }
│   │   │   75 │ 
│   │   │   76 │         /// <summary>
│   │   │   77 │         /// Count of objects
│   │   │   78 │         /// </summary>
│   │   │   79 │         public int ObjectCount
│   │   │   80 │         {
│   │   │   81 │             get => _objectCount;
│   │   │   82 │             set => SetProperty(ref _objectCount, value);
│   │   │   83 │         }
│   │   │   84 │ 
│   │   │   85 │         /// <summary>
│   │   │   86 │         /// Available export formats
│   │   │   87 │         /// </summary>
│   │   │   88 │         public ObservableCollection<ExportFormat> ExportFormats
│   │   │   89 │         {
│   │   │   90 │             get => _exportFormats;
│   │   │   91 │             set => SetProperty(ref _exportFormats, value);
│   │   │   92 │         }
│   │   │   93 │ 
│   │   │   94 │         /// <summary>
│   │   │   95 │         /// Selected export format
│   │   │   96 │         /// </summary>
│   │   │   97 │         public ExportFormat SelectedFormat
│   │   │   98 │         {
│   │   │   99 │             get => _selectedFormat;
│   │   │  100 │             set => SetProperty(ref _selectedFormat, value);
│   │   │  101 │         }
│   │   │  102 │ 
│   │   │  103 │         /// <summary>
│   │   │  104 │         /// Export file path
│   │   │  105 │         /// </summary>
│   │   │  106 │         public string ExportPath
│   │   │  107 │         {
│   │   │  108 │             get => _exportPath;
│   │   │  109 │             set => SetProperty(ref _exportPath, value);
│   │   │  110 │         }
│   │   │  111 │ 
│   │   │  112 │         /// <summary>
│   │   │  113 │         /// Command to load available sessions
│   │   │  114 │         /// </summary>
│   │   │  115 │         public IAsyncRelayCommand LoadSessionsCommand { get; }
│   │   │  116 │ 
│   │   │  117 │         /// <summary>
│   │   │  118 │         /// Command to load data from selected session
│   │   │  119 │         /// </summary>
│   │   │  120 │         public IAsyncRelayCommand LoadSessionDataCommand { get; }
│   │   │  121 │ 
│   │   │  122 │         /// <summary>
│   │   │  123 │         /// Command to select export file path
│   │   │  124 │         /// </summary>
│   │   │  125 │         public IAsyncRelayCommand SelectExportPathCommand { get; }
│   │   │  126 │ 
│   │   │  127 │         /// <summary>
│   │   │  128 │         /// Command to export data
│   │   │  129 │         /// </summary>
│   │   │  130 │         public IAsyncRelayCommand ExportCommand { get; }
│   │   │  131 │ 
│   │   │  132 │         /// <summary>
│   │   │  133 │         /// Creates a new export demo view model
│   │   │  134 │         /// </summary>
│   │   │  135 │         /// <param name="exportService">The export service</param>
│   │   │  136 │         /// <param name="dialogService">The dialog service</param>
│   │   │  137 │         /// <param name="controllerService">The controller service</param>
│   │   │  138 │         public ExportDemoViewModel(
│   │   │  139 │             IExportService exportService,
│   │   │  140 │             IDialogService dialogService,
│   │   │  141 │             ControllerService controllerService)
│   │   │  142 │         {
│   │   │  143 │             _exportService = exportService ?? throw new ArgumentNullException(nameof(exportService));
│   │   │  144 │             _dialogService = dialogService ?? throw new ArgumentNullException(nameof(dialogService));
│   │   │  145 │             _controllerService = controllerService ?? throw new ArgumentNullException(nameof(controllerService));
│   │   │  146 │ 
│   │   │  147 │             // Initialize commands
│   │   │  148 │             LoadSessionsCommand = new AsyncRelayCommand(LoadSessionsAsync);
│   │   │  149 │             LoadSessionDataCommand = new AsyncRelayCommand(LoadSessionDataAsync);
│   │   │  150 │             SelectExportPathCommand = new AsyncRelayCommand(SelectExportPathAsync);
│   │   │  151 │             ExportCommand = new AsyncRelayCommand(ExportDataAsync, CanExport);
│   │   │  152 │ 
│   │   │  153 │             // Load available formats
│   │   │  154 │             ExportFormats = new ObservableCollection<ExportFormat>(_exportService.GetAvailableFormats());
│   │   │  155 │             if (ExportFormats.Any())
│   │   │  156 │             {
│   │   │  157 │                 SelectedFormat = ExportFormats.First();
│   │   │  158 │             }
│   │   │  159 │ 
│   │   │  160 │             // Load sessions on startup
│   │   │  161 │             LoadSessionsCommand.ExecuteAsync(null);
│   │   │  162 │         }
│   │   │  163 │ 
│   │   │  164 │         /// <summary>
│   │   │  165 │         /// Loads available sessions
│   │   │  166 │         /// </summary>
│   │   │  167 │         private async Task LoadSessionsAsync()
│   │   │  168 │         {
│   │   │  169 │             await ExecuteWithBusyIndicationAsync(async () =>
│   │   │  170 │             {
│   │   │  171 │                 var sessions = await _controllerService.GetAllSessionsAsync();
│   │   │  172 │                 AvailableSessions.Clear();
│   │   │  173 │ 
│   │   │  174 │                 foreach (var session in sessions)
│   │   │  175 │                 {
│   │   │  176 │                     AvailableSessions.Add(session.SessionId);
│   │   │  177 │                 }
│   │   │  178 │ 
│   │   │  179 │                 if (AvailableSessions.Any())
│   │   │  180 │                 {
│   │   │  181 │                     SelectedSessionId = AvailableSessions.First();
│   │   │  182 │                 }
│   │   │  183 │             }, "Sessions loaded successfully", "Failed to load sessions");
│   │   │  184 │         }
│   │   │  185 │ 
│   │   │  186 │         /// <summary>
│   │   │  187 │         /// Loads data from selected session
│   │   │  188 │         /// </summary>
│   │   │  189 │         private async Task LoadSessionDataAsync()
│   │   │  190 │         {
│   │   │  191 │             if (string.IsNullOrEmpty(SelectedSessionId))
│   │   │  192 │                 return;
│   │   │  193 │ 
│   │   │  194 │             await ExecuteWithBusyIndicationAsync(async () =>
│   │   │  195 │             {
│   │   │  196 │                 var controllers = await _controllerService.GetControllersBySessionAsync(SelectedSessionId);
│   │   │  197 │                 Controllers = new ObservableCollection<Controller>(controllers);
│   │   │  198 │                 ControllerCount = Controllers.Count;
│   │   │  199 │                 ObjectCount = Controllers.Sum(c => CountObjects(c.Objects));
│   │   │  200 │             }, "Session data loaded successfully", "Failed to load session data");
│   │   │  201 │         }
│   │   │  202 │ 
│   │   │  203 │         /// <summary>
│   │   │  204 │         /// Selects export file path
│   │   │  205 │         /// </summary>
│   │   │  206 │         private async Task SelectExportPathAsync()
│   │   │  207 │         {
│   │   │  208 │             if (SelectedFormat == null)
│   │   │  209 │                 return;
│   │   │  210 │ 
│   │   │  211 │             var filters = new List<FileDialogFilter>
│   │   │  212 │             {
│   │   │  213 │                 new FileDialogFilter
│   │   │  214 │                 {
│   │   │  215 │                     Name = $"{SelectedFormat.DisplayName} Files",
│   │   │  216 │                     Extensions = new List<string> { SelectedFormat.Extension.TrimStart('.') }
│   │   │  217 │                 }
│   │   │  218 │             };
│   │   │  219 │ 
│   │   │  220 │             var path = await _dialogService.ShowSaveFileDialogAsync(
│   │   │  221 │                 "Select Export Location",
│   │   │  222 │                 SelectedFormat.Extension,
│   │   │  223 │                 filters);
│   │   │  224 │ 
│   │   │  225 │             if (!string.IsNullOrEmpty(path))
│   │   │  226 │             {
│   │   │  227 │                 ExportPath = path;
│   │   │  228 │             }
│   │   │  229 │         }
│   │   │  230 │ 
│   │   │  231 │         /// <summary>
│   │   │  232 │         /// Exports data to selected format
│   │   │  233 │         /// </summary>
│   │   │  234 │         private async Task ExportDataAsync()
│   │   │  235 │         {
│   │   │  236 │             if (SelectedFormat == null || string.IsNullOrEmpty(ExportPath) || !Controllers.Any())
│   │   │  237 │                 return;
│   │   │  238 │ 
│   │   │  239 │             await ExecuteWithBusyIndicationAsync(async () =>
│   │   │  240 │             {
│   │   │  241 │                 var options = new ExportOptions
│   │   │  242 │                 {
│   │   │  243 │                     IncludeByteCode = false,
│   │   │  244 │                     IncludeEmptyValues = true,
│   │   │  245 │                     PrettyPrint = true
│   │   │  246 │                 };
│   │   │  247 │ 
│   │   │  248 │                 switch (SelectedFormat.Id)
│   │   │  249 │                 {
│   │   │  250 │                     case "xml":
│   │   │  251 │                         await _exportService.ExportToXmlAsync(Controllers, ExportPath, options);
│   │   │  252 │                         break;
│   │   │  253 │ 
│   │   │  254 │                     case "excel":
│   │   │  255 │                         await _exportService.ExportToExcelAsync(Controllers, ExportPath, options);
│   │   │  256 │                         break;
│   │   │  257 │ 
│   │   │  258 │                     case "csv-grouped":
│   │   │  259 │                         var comparisons = await _exportService.ExportToGroupedCsvAsync(Controllers, ExportPath, options);
│   │   │  260 │                         // Save comparisons to a separate file
│   │   │  261 │                         if (comparisons.Any())
│   │   │  262 │                         {
│   │   │  263 │                             var comparisonPath = Path.ChangeExtension(ExportPath, ".comparisons.txt");
│   │   │  264 │                             await File.WriteAllLinesAsync(comparisonPath, comparisons.Select(c => c.ToString()));
│   │   │  265 │                             SetSuccessMessage($"Exported {Controllers.Count} controllers with {comparisons.Count()} comparisons");
│   │   │  266 │                         }
│   │   │  267 │                         break;
│   │   │  268 │                 }
│   │   │  269 │             }, $"Exported to {Path.GetFileName(ExportPath)} successfully", "Export failed");
│   │   │  270 │         }
│   │   │  271 │ 
│   │   │  272 │         /// <summary>
│   │   │  273 │         /// Determines whether export is possible
│   │   │  274 │         /// </summary>
│   │   │  275 │         private bool CanExport()
│   │   │  276 │         {
│   │   │  277 │             return SelectedFormat != null && !string.IsNullOrEmpty(ExportPath) && Controllers.Any();
│   │   │  278 │         }
│   │   │  279 │ 
│   │   │  280 │         /// <summary>
│   │   │  281 │         /// Counts objects recursively
│   │   │  282 │         /// </summary>
│   │   │  283 │         private int CountObjects(IEnumerable<ControllerObject> objects)
│   │   │  284 │         {
│   │   │  285 │             if (objects == null)
│   │   │  286 │                 return 0;
│   │   │  287 │ 
│   │   │  288 │             int count = objects.Count();
│   │   │  289 │             foreach (var obj in objects)
│   │   │  290 │             {
│   │   │  291 │                 count += CountObjects(obj.Children);
│   │   │  292 │             }
│   │   │  293 │ 
│   │   │  294 │             return count;
│   │   │  295 │         }
│   │   │  296 │     }
│   │   │  297 │ }
│   │   └──────────────────────────────────────────────────────────────────────
│   ├── 📄 IMenuItem.cs (177.00 B, 2025-03-12 11:26:27)
│   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │ FILE CONTENT: IMenuItem.cs
│   │   ├──────────────────────────────────────────────────────────────────────
│   │   │    1 │ ﻿using Material.Icons;
│   │   │    2 │ 
│   │   │    3 │ namespace test.ViewModels
│   │   │    4 │ {
│   │   │    5 │     public interface IMenuItem
│   │   │    6 │     {
│   │   │    7 │         string Header { get; }
│   │   │    8 │         MaterialIconKind Icon { get; }
│   │   │    9 │     }
│   │   │   10 │ }
│   │   └──────────────────────────────────────────────────────────────────────
│   ├── 📄 MainViewModel.cs (5.86 KB, 2025-03-12 15:13:49)
│   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │ FILE CONTENT: MainViewModel.cs
│   │   ├──────────────────────────────────────────────────────────────────────
│   │   │    1 │ ﻿using Avalonia.Controls;
│   │   │    2 │ using CommunityToolkit.Mvvm.ComponentModel;
│   │   │    3 │ using CommunityToolkit.Mvvm.Input;
│   │   │    4 │ using Material.Icons;
│   │   │    5 │ using System;
│   │   │    6 │ using System.Collections.ObjectModel;
│   │   │    7 │ using System.Linq;
│   │   │    8 │ using Microsoft.Extensions.Logging;
│   │   │    9 │ using test.Core.Interfaces;
│   │   │   10 │ 
│   │   │   11 │ namespace test.ViewModels
│   │   │   12 │ {
│   │   │   13 │     public partial class MainViewModel : ObservableObject
│   │   │   14 │     {
│   │   │   15 │         private readonly INavigationService _navigationService;
│   │   │   16 │         private readonly ILogger<MainViewModel> _logger;
│   │   │   17 │ 
│   │   │   18 │         [ObservableProperty]
│   │   │   19 │         private IMenuItem? _selectedMenuItem;
│   │   │   20 │ 
│   │   │   21 │         [ObservableProperty]
│   │   │   22 │         private string _searchText = string.Empty;
│   │   │   23 │ 
│   │   │   24 │         [ObservableProperty]
│   │   │   25 │         private Control? _currentView;
│   │   │   26 │ 
│   │   │   27 │         public ObservableCollection<IMenuItem> MenuItems { get; } = new();
│   │   │   28 │ 
│   │   │   29 │         // Constructor for design-time
│   │   │   30 │         public MainViewModel()
│   │   │   31 │         {
│   │   │   32 │             // Design-time constructor
│   │   │   33 │             InitializeMenuItems();
│   │   │   34 │             _logger?.LogDebug("MainViewModel created with design-time constructor");
│   │   │   35 │         }
│   │   │   36 │ 
│   │   │   37 │         // Main constructor used by DI
│   │   │   38 │         public MainViewModel(INavigationService navigationService, ILogger<MainViewModel> logger = null)
│   │   │   39 │         {
│   │   │   40 │             _navigationService = navigationService ?? throw new ArgumentNullException(nameof(navigationService));
│   │   │   41 │             _logger = logger;
│   │   │   42 │             _logger?.LogInformation("MainViewModel created with navigationService");
│   │   │   43 │ 
│   │   │   44 │             InitializeMenuItems();
│   │   │   45 │             _logger?.LogInformation("Menu items initialized: {Count} items", MenuItems.Count);
│   │   │   46 │ 
│   │   │   47 │             // Set initial view
│   │   │   48 │             var defaultView = MenuItems.FirstOrDefault();
│   │   │   49 │             if (defaultView != null)
│   │   │   50 │             {
│   │   │   51 │                 SelectedMenuItem = defaultView;
│   │   │   52 │                 _logger?.LogDebug("Set initial SelectedMenuItem to {MenuItem}", defaultView.Header);
│   │   │   53 │ 
│   │   │   54 │                 if (_navigationService != null)
│   │   │   55 │                 {
│   │   │   56 │                     try
│   │   │   57 │                     {
│   │   │   58 │                         // Navigate to the default view
│   │   │   59 │                         _navigationService.NavigateTo(defaultView.Header);
│   │   │   60 │                         _logger?.LogDebug("Navigated to initial view: {ViewName}", defaultView.Header);
│   │   │   61 │ 
│   │   │   62 │                         // Subscribe to navigation events to update CurrentView
│   │   │   63 │                         _navigationService.Navigated += (s, e) =>
│   │   │   64 │                         {
│   │   │   65 │                             _logger?.LogDebug("Navigation event received for {ViewName}", e.ViewName);
│   │   │   66 │                             if (e.Parameter is Control control)
│   │   │   67 │                             {
│   │   │   68 │                                 CurrentView = control;
│   │   │   69 │                                 _logger?.LogDebug("CurrentView updated to {ViewType}", control.GetType().Name);
│   │   │   70 │                             }
│   │   │   71 │                         };
│   │   │   72 │                     }
│   │   │   73 │                     catch (Exception ex)
│   │   │   74 │                     {
│   │   │   75 │                         _logger?.LogError(ex, "Error during initial navigation");
│   │   │   76 │                     }
│   │   │   77 │                 }
│   │   │   78 │             }
│   │   │   79 │             else
│   │   │   80 │             {
│   │   │   81 │                 _logger?.LogWarning("No default menu item found to select");
│   │   │   82 │             }
│   │   │   83 │         }
│   │   │   84 │ 
│   │   │   85 │         partial void OnSelectedMenuItemChanged(IMenuItem? value)
│   │   │   86 │         {
│   │   │   87 │             try
│   │   │   88 │             {
│   │   │   89 │                 if (value != null && _navigationService != null)
│   │   │   90 │                 {
│   │   │   91 │                     _logger?.LogDebug("SelectedMenuItem changed to {MenuItem}", value.Header);
│   │   │   92 │                     _navigationService.NavigateTo(value.Header);
│   │   │   93 │                 }
│   │   │   94 │             }
│   │   │   95 │             catch (Exception ex)
│   │   │   96 │             {
│   │   │   97 │                 _logger?.LogError(ex, "Error in OnSelectedMenuItemChanged");
│   │   │   98 │             }
│   │   │   99 │         }
│   │   │  100 │ 
│   │   │  101 │         private void InitializeMenuItems()
│   │   │  102 │         {
│   │   │  103 │             try
│   │   │  104 │             {
│   │   │  105 │                 MenuItems.Clear();
│   │   │  106 │                 MenuItems.Add(new MenuItem { Header = "Dashboard", Icon = MaterialIconKind.ViewDashboard });
│   │   │  107 │                 MenuItems.Add(new MenuItem { Header = "Projects", Icon = MaterialIconKind.Folder });
│   │   │  108 │                 MenuItems.Add(new MenuItem { Header = "Analysis", Icon = MaterialIconKind.ChartBar });
│   │   │  109 │                 MenuItems.Add(new MenuItem { Header = "Diff", Icon = MaterialIconKind.FileCompare });
│   │   │  110 │                 MenuItems.Add(new MenuItem { Header = "Converters", Icon = MaterialIconKind.FileReplace });
│   │   │  111 │                 MenuItems.Add(new MenuItem { Header = "Databases", Icon = MaterialIconKind.Database });
│   │   │  112 │                 MenuItems.Add(new MenuItem { Header = "Reports", Icon = MaterialIconKind.FileChart });
│   │   │  113 │                 MenuItems.Add(new MenuItem { Header = "Settings", Icon = MaterialIconKind.Cog });
│   │   │  114 │                 MenuItems.Add(new MenuItem { Header = "Help", Icon = MaterialIconKind.HelpCircle });
│   │   │  115 │ 
│   │   │  116 │                 _logger?.LogDebug("Menu items initialized with {Count} items", MenuItems.Count);
│   │   │  117 │             }
│   │   │  118 │             catch (Exception ex)
│   │   │  119 │             {
│   │   │  120 │                 _logger?.LogError(ex, "Error initializing menu items");
│   │   │  121 │             }
│   │   │  122 │         }
│   │   │  123 │ 
│   │   │  124 │         [RelayCommand]
│   │   │  125 │         private void MenuItemSelected(IMenuItem menuItem)
│   │   │  126 │         {
│   │   │  127 │             try
│   │   │  128 │             {
│   │   │  129 │                 if (menuItem != null && _navigationService != null)
│   │   │  130 │                 {
│   │   │  131 │                     _logger?.LogDebug("MenuItemSelected command executed for {MenuItem}", menuItem.Header);
│   │   │  132 │                     _navigationService.NavigateTo(menuItem.Header);
│   │   │  133 │                     SelectedMenuItem = menuItem;
│   │   │  134 │                 }
│   │   │  135 │             }
│   │   │  136 │             catch (Exception ex)
│   │   │  137 │             {
│   │   │  138 │                 _logger?.LogError(ex, "Error in MenuItemSelected command");
│   │   │  139 │             }
│   │   │  140 │         }
│   │   │  141 │     }
│   │   │  142 │ 
│   │   │  143 │     public class MenuItem : IMenuItem
│   │   │  144 │     {
│   │   │  145 │         public string Header { get; set; } = string.Empty;
│   │   │  146 │         public MaterialIconKind Icon { get; set; }
│   │   │  147 │ 
│   │   │  148 │         public override string ToString()
│   │   │  149 │         {
│   │   │  150 │             return $"MenuItem: {Header}";
│   │   │  151 │         }
│   │   │  152 │     }
│   │   │  153 │ }
│   │   └──────────────────────────────────────────────────────────────────────
│   ├── 📄 ObjectSetViewModel.cs (5.35 KB, 2025-03-11 15:11:59)
│   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │ FILE CONTENT: ObjectSetViewModel.cs
│   │   ├──────────────────────────────────────────────────────────────────────
│   │   │    1 │ ﻿using System;
│   │   │    2 │ using System.Collections.Generic;
│   │   │    3 │ using System.Collections.ObjectModel;
│   │   │    4 │ using System.IO;
│   │   │    5 │ using System.Threading.Tasks;
│   │   │    6 │ using System.Xml.Linq;
│   │   │    7 │ using CommunityToolkit.Mvvm.Input;
│   │   │    8 │ using test.Core.Domain.ObjectSet;
│   │   │    9 │ using test.Core.Interfaces;
│   │   │   10 │ 
│   │   │   11 │ namespace test.ViewModels
│   │   │   12 │ {
│   │   │   13 │     /// <summary>
│   │   │   14 │     /// View model for ObjectSet XML content
│   │   │   15 │     /// </summary>
│   │   │   16 │     public class ObjectSetViewModel : ViewModelBase
│   │   │   17 │     {
│   │   │   18 │         private readonly IObjectSetParser _objectSetParser;
│   │   │   19 │         private readonly IDialogService _dialogService;
│   │   │   20 │ 
│   │   │   21 │         private string _filePath;
│   │   │   22 │         private MetaInformation _metaInfo;
│   │   │   23 │         private ObservableCollection<ObjectTypeDefinition> _typeDefinitions = new();
│   │   │   24 │         private ObservableCollection<ExportedObject> _exportedObjects = new();
│   │   │   25 │         private ObjectTypeDefinition _selectedType;
│   │   │   26 │         private ExportedObject _selectedObject;
│   │   │   27 │ 
│   │   │   28 │         /// <summary>
│   │   │   29 │         /// The file path
│   │   │   30 │         /// </summary>
│   │   │   31 │         public string FilePath
│   │   │   32 │         {
│   │   │   33 │             get => _filePath;
│   │   │   34 │             set => SetProperty(ref _filePath, value);
│   │   │   35 │         }
│   │   │   36 │ 
│   │   │   37 │         /// <summary>
│   │   │   38 │         /// The meta information
│   │   │   39 │         /// </summary>
│   │   │   40 │         public MetaInformation MetaInfo
│   │   │   41 │         {
│   │   │   42 │             get => _metaInfo;
│   │   │   43 │             set => SetProperty(ref _metaInfo, value);
│   │   │   44 │         }
│   │   │   45 │ 
│   │   │   46 │         /// <summary>
│   │   │   47 │         /// The type definitions
│   │   │   48 │         /// </summary>
│   │   │   49 │         public ObservableCollection<ObjectTypeDefinition> TypeDefinitions
│   │   │   50 │         {
│   │   │   51 │             get => _typeDefinitions;
│   │   │   52 │             set => SetProperty(ref _typeDefinitions, value);
│   │   │   53 │         }
│   │   │   54 │ 
│   │   │   55 │         /// <summary>
│   │   │   56 │         /// The exported objects
│   │   │   57 │         /// </summary>
│   │   │   58 │         public ObservableCollection<ExportedObject> ExportedObjects
│   │   │   59 │         {
│   │   │   60 │             get => _exportedObjects;
│   │   │   61 │             set => SetProperty(ref _exportedObjects, value);
│   │   │   62 │         }
│   │   │   63 │ 
│   │   │   64 │         /// <summary>
│   │   │   65 │         /// The selected type definition
│   │   │   66 │         /// </summary>
│   │   │   67 │         public ObjectTypeDefinition SelectedType
│   │   │   68 │         {
│   │   │   69 │             get => _selectedType;
│   │   │   70 │             set => SetProperty(ref _selectedType, value);
│   │   │   71 │         }
│   │   │   72 │ 
│   │   │   73 │         /// <summary>
│   │   │   74 │         /// The selected exported object
│   │   │   75 │         /// </summary>
│   │   │   76 │         public ExportedObject SelectedObject
│   │   │   77 │         {
│   │   │   78 │             get => _selectedObject;
│   │   │   79 │             set => SetProperty(ref _selectedObject, value);
│   │   │   80 │         }
│   │   │   81 │ 
│   │   │   82 │         /// <summary>
│   │   │   83 │         /// Command to load an ObjectSet XML file
│   │   │   84 │         /// </summary>
│   │   │   85 │         public IAsyncRelayCommand LoadFileCommand { get; }
│   │   │   86 │ 
│   │   │   87 │         /// <summary>
│   │   │   88 │         /// Creates a new ObjectSet view model
│   │   │   89 │         /// </summary>
│   │   │   90 │         /// <param name="objectSetParser">The ObjectSet parser</param>
│   │   │   91 │         /// <param name="dialogService">The dialog service</param>
│   │   │   92 │         public ObjectSetViewModel(IObjectSetParser objectSetParser, IDialogService dialogService)
│   │   │   93 │         {
│   │   │   94 │             _objectSetParser = objectSetParser ?? throw new ArgumentNullException(nameof(objectSetParser));
│   │   │   95 │             _dialogService = dialogService ?? throw new ArgumentNullException(nameof(dialogService));
│   │   │   96 │ 
│   │   │   97 │             LoadFileCommand = new AsyncRelayCommand(LoadFileAsync);
│   │   │   98 │         }
│   │   │   99 │ 
│   │   │  100 │         /// <summary>
│   │   │  101 │         /// Loads an ObjectSet XML file
│   │   │  102 │         /// </summary>
│   │   │  103 │         private async Task LoadFileAsync()
│   │   │  104 │         {
│   │   │  105 │             var filters = new List<Avalonia.Controls.FileDialogFilter>
│   │   │  106 │     {
│   │   │  107 │         new Avalonia.Controls.FileDialogFilter
│   │   │  108 │         {
│   │   │  109 │             Name = "XML Files",
│   │   │  110 │             Extensions = new List<string> { "xml" }
│   │   │  111 │         }
│   │   │  112 │     };
│   │   │  113 │ 
│   │   │  114 │             var files = await _dialogService.ShowOpenFileDialogAsync("Select ObjectSet XML File", filters);
│   │   │  115 │             if (files == null || files.Length == 0)
│   │   │  116 │                 return;
│   │   │  117 │ 
│   │   │  118 │             FilePath = files[0];
│   │   │  119 │ 
│   │   │  120 │             await ExecuteWithBusyIndicationAsync(async () =>
│   │   │  121 │             {
│   │   │  122 │                 try
│   │   │  123 │                 {
│   │   │  124 │                     // Load XML content
│   │   │  125 │                     var content = await File.ReadAllTextAsync(FilePath);
│   │   │  126 │                     var document = XDocument.Parse(content);
│   │   │  127 │ 
│   │   │  128 │                     // Use parser to extract components
│   │   │  129 │                     var options = new ObjectSetParsingOptions
│   │   │  130 │                     {
│   │   │  131 │                         IncludeMetaInformation = true,
│   │   │  132 │                         IncludeTypeDefinitions = true,
│   │   │  133 │                         IncludeExportedObjects = true
│   │   │  134 │                     };
│   │   │  135 │ 
│   │   │  136 │                     var result = await _objectSetParser.ParseAsync(document, options);
│   │   │  137 │ 
│   │   │  138 │                     if (result.Success)
│   │   │  139 │                     {
│   │   │  140 │                         MetaInfo = result.MetaInfo;
│   │   │  141 │                         TypeDefinitions = new ObservableCollection<ObjectTypeDefinition>(result.Types);
│   │   │  142 │                         ExportedObjects = new ObservableCollection<ExportedObject>(result.ExportedObjects);
│   │   │  143 │                         return true;
│   │   │  144 │                     }
│   │   │  145 │                     else
│   │   │  146 │                     {
│   │   │  147 │                         SetErrorMessage($"Failed to parse ObjectSet XML: {result.ErrorMessage}");
│   │   │  148 │                         return false;
│   │   │  149 │                     }
│   │   │  150 │                 }
│   │   │  151 │                 catch (Exception ex)
│   │   │  152 │                 {
│   │   │  153 │                     SetErrorMessage($"Error loading file: {ex.Message}");
│   │   │  154 │                     return false;
│   │   │  155 │                 }
│   │   │  156 │             }, "ObjectSet XML loaded successfully", "Error loading ObjectSet XML");
│   │   │  157 │         }
│   │   │  158 │     }
│   │   │  159 │ }
│   │   └──────────────────────────────────────────────────────────────────────
│   ├── 📄 ProjectViewModel.cs (10.85 KB, 2025-03-11 09:48:27)
│   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │ FILE CONTENT: ProjectViewModel.cs
│   │   ├──────────────────────────────────────────────────────────────────────
│   │   │    1 │ ﻿using System;
│   │   │    2 │ using System.Collections.Generic;
│   │   │    3 │ using System.Collections.ObjectModel;
│   │   │    4 │ using System.ComponentModel;
│   │   │    5 │ using System.Runtime.CompilerServices;
│   │   │    6 │ using System.Threading.Tasks;
│   │   │    7 │ using Microsoft.Extensions.Logging;
│   │   │    8 │ using test.Application.Services;
│   │   │    9 │ using test.Core.Interfaces;
│   │   │   10 │ 
│   │   │   11 │ namespace test.ViewModels
│   │   │   12 │ {
│   │   │   13 │ 
│   │   │   14 │     /// <summary>
│   │   │   15 │     /// View model for a project
│   │   │   16 │     /// </summary>
│   │   │   17 │     public class ProjectViewModel : ViewModelBase
│   │   │   18 │     {
│   │   │   19 │         private readonly ProjectService _projectService;
│   │   │   20 │         private readonly IErrorHandler _errorHandler;
│   │   │   21 │         private readonly ILogger<ProjectViewModel> _logger;
│   │   │   22 │         private readonly IDialogService _dialogService;
│   │   │   23 │ 
│   │   │   24 │         // Properties from domain model
│   │   │   25 │         private string _projectId;
│   │   │   26 │         private string _name;
│   │   │   27 │         private string _description;
│   │   │   28 │         private DateTime _created;
│   │   │   29 │         private DateTime _lastModified;
│   │   │   30 │         private string _projectDirectory;
│   │   │   31 │ 
│   │   │   32 │         // Collections
│   │   │   33 │         private ObservableCollection<ImportedFileViewModel> _importedFiles = new();
│   │   │   34 │         private ObservableCollection<SharedTypeViewModel> _sharedTypes = new();
│   │   │   35 │         private ObservableCollection<CustomTypeFileViewModel> _customTypeFiles = new();
│   │   │   36 │ 
│   │   │   37 │         /// <summary>
│   │   │   38 │         /// The project ID
│   │   │   39 │         /// </summary>
│   │   │   40 │         public string ProjectId
│   │   │   41 │         {
│   │   │   42 │             get => _projectId;
│   │   │   43 │             set => SetProperty(ref _projectId, value);
│   │   │   44 │         }
│   │   │   45 │ 
│   │   │   46 │         /// <summary>
│   │   │   47 │         /// The project name
│   │   │   48 │         /// </summary>
│   │   │   49 │         public string Name
│   │   │   50 │         {
│   │   │   51 │             get => _name;
│   │   │   52 │             set => SetProperty(ref _name, value);
│   │   │   53 │         }
│   │   │   54 │ 
│   │   │   55 │         /// <summary>
│   │   │   56 │         /// The project description
│   │   │   57 │         /// </summary>
│   │   │   58 │         public string Description
│   │   │   59 │         {
│   │   │   60 │             get => _description;
│   │   │   61 │             set => SetProperty(ref _description, value);
│   │   │   62 │         }
│   │   │   63 │ 
│   │   │   64 │         /// <summary>
│   │   │   65 │         /// The project directory
│   │   │   66 │         /// </summary>
│   │   │   67 │         public string ProjectDirectory
│   │   │   68 │         {
│   │   │   69 │             get => _projectDirectory;
│   │   │   70 │             set => SetProperty(ref _projectDirectory, value);
│   │   │   71 │         }
│   │   │   72 │ 
│   │   │   73 │         /// <summary>
│   │   │   74 │         /// The date the project was created
│   │   │   75 │         /// </summary>
│   │   │   76 │         public DateTime Created
│   │   │   77 │         {
│   │   │   78 │             get => _created;
│   │   │   79 │             set => SetProperty(ref _created, value);
│   │   │   80 │         }
│   │   │   81 │ 
│   │   │   82 │         /// <summary>
│   │   │   83 │         /// The date the project was last modified
│   │   │   84 │         /// </summary>
│   │   │   85 │         public DateTime LastModified
│   │   │   86 │         {
│   │   │   87 │             get => _lastModified;
│   │   │   88 │             set => SetProperty(ref _lastModified, value);
│   │   │   89 │         }
│   │   │   90 │ 
│   │   │   91 │         /// <summary>
│   │   │   92 │         /// The imported files in this project
│   │   │   93 │         /// </summary>
│   │   │   94 │         public ObservableCollection<ImportedFileViewModel> ImportedFiles
│   │   │   95 │         {
│   │   │   96 │             get => _importedFiles;
│   │   │   97 │             set => SetProperty(ref _importedFiles, value);
│   │   │   98 │         }
│   │   │   99 │ 
│   │   │  100 │         /// <summary>
│   │   │  101 │         /// The shared types in this project
│   │   │  102 │         /// </summary>
│   │   │  103 │         public ObservableCollection<SharedTypeViewModel> SharedTypes
│   │   │  104 │         {
│   │   │  105 │             get => _sharedTypes;
│   │   │  106 │             set => SetProperty(ref _sharedTypes, value);
│   │   │  107 │         }
│   │   │  108 │ 
│   │   │  109 │         /// <summary>
│   │   │  110 │         /// The custom type files in this project
│   │   │  111 │         /// </summary>
│   │   │  112 │         public ObservableCollection<CustomTypeFileViewModel> CustomTypeFiles
│   │   │  113 │         {
│   │   │  114 │             get => _customTypeFiles;
│   │   │  115 │             set => SetProperty(ref _customTypeFiles, value);
│   │   │  116 │         }
│   │   │  117 │ 
│   │   │  118 │         /// <summary>
│   │   │  119 │         /// Creates a new project view model for design time
│   │   │  120 │         /// </summary>
│   │   │  121 │         public ProjectViewModel()
│   │   │  122 │         {
│   │   │  123 │             // Design-time constructor
│   │   │  124 │         }
│   │   │  125 │ 
│   │   │  126 │         /// <summary>
│   │   │  127 │         /// Creates a new project view model
│   │   │  128 │         /// </summary>
│   │   │  129 │         public ProjectViewModel(
│   │   │  130 │             ProjectService projectService,
│   │   │  131 │             IErrorHandler errorHandler,
│   │   │  132 │             ILogger<ProjectViewModel> logger,
│   │   │  133 │             IDialogService dialogService)
│   │   │  134 │         {
│   │   │  135 │             _projectService = projectService;
│   │   │  136 │             _errorHandler = errorHandler;
│   │   │  137 │             _logger = logger;
│   │   │  138 │             _dialogService = dialogService;
│   │   │  139 │         }
│   │   │  140 │ 
│   │   │  141 │         // TODO: Add commands and methods for project operations
│   │   │  142 │     }
│   │   │  143 │ 
│   │   │  144 │     /// <summary>
│   │   │  145 │     /// View model for an imported file
│   │   │  146 │     /// </summary>
│   │   │  147 │     public class ImportedFileViewModel : ViewModelBase
│   │   │  148 │     {
│   │   │  149 │         private string _fileName = string.Empty;
│   │   │  150 │         private string _filePath = string.Empty;
│   │   │  151 │         private string _status = string.Empty;
│   │   │  152 │         private DateTime _importDate = DateTime.UtcNow;
│   │   │  153 │         private long _fileSize;
│   │   │  154 │         private string _fileType = string.Empty;
│   │   │  155 │         private bool _isSelected;
│   │   │  156 │ 
│   │   │  157 │         /// <summary>
│   │   │  158 │         /// The file name
│   │   │  159 │         /// </summary>
│   │   │  160 │         public string FileName
│   │   │  161 │         {
│   │   │  162 │             get => _fileName;
│   │   │  163 │             set => SetProperty(ref _fileName, value);
│   │   │  164 │         }
│   │   │  165 │ 
│   │   │  166 │         /// <summary>
│   │   │  167 │         /// The file path
│   │   │  168 │         /// </summary>
│   │   │  169 │         public string FilePath
│   │   │  170 │         {
│   │   │  171 │             get => _filePath;
│   │   │  172 │             set => SetProperty(ref _filePath, value);
│   │   │  173 │         }
│   │   │  174 │ 
│   │   │  175 │         /// <summary>
│   │   │  176 │         /// The file status
│   │   │  177 │         /// </summary>
│   │   │  178 │         public string Status
│   │   │  179 │         {
│   │   │  180 │             get => _status;
│   │   │  181 │             set => SetProperty(ref _status, value);
│   │   │  182 │         }
│   │   │  183 │ 
│   │   │  184 │         /// <summary>
│   │   │  185 │         /// The date the file was imported
│   │   │  186 │         /// </summary>
│   │   │  187 │         public DateTime ImportDate
│   │   │  188 │         {
│   │   │  189 │             get => _importDate;
│   │   │  190 │             set => SetProperty(ref _importDate, value);
│   │   │  191 │         }
│   │   │  192 │ 
│   │   │  193 │         /// <summary>
│   │   │  194 │         /// The file size in bytes
│   │   │  195 │         /// </summary>
│   │   │  196 │         public long FileSize
│   │   │  197 │         {
│   │   │  198 │             get => _fileSize;
│   │   │  199 │             set => SetProperty(ref _fileSize, value);
│   │   │  200 │         }
│   │   │  201 │ 
│   │   │  202 │         /// <summary>
│   │   │  203 │         /// The file type (e.g., DMP, XML)
│   │   │  204 │         /// </summary>
│   │   │  205 │         public string FileType
│   │   │  206 │         {
│   │   │  207 │             get => _fileType;
│   │   │  208 │             set => SetProperty(ref _fileType, value);
│   │   │  209 │         }
│   │   │  210 │ 
│   │   │  211 │         /// <summary>
│   │   │  212 │         /// Whether the file is selected in the UI
│   │   │  213 │         /// </summary>
│   │   │  214 │         public bool IsSelected
│   │   │  215 │         {
│   │   │  216 │             get => _isSelected;
│   │   │  217 │             set => SetProperty(ref _isSelected, value);
│   │   │  218 │         }
│   │   │  219 │     }
│   │   │  220 │ 
│   │   │  221 │     /// <summary>
│   │   │  222 │     /// View model for a shared type
│   │   │  223 │     /// </summary>
│   │   │  224 │     public class SharedTypeViewModel : ViewModelBase
│   │   │  225 │     {
│   │   │  226 │         private string _typeName = string.Empty;
│   │   │  227 │         private string _fileName = string.Empty;
│   │   │  228 │         private string _filePath = string.Empty;
│   │   │  229 │         private string _category = string.Empty;
│   │   │  230 │         private string _description = string.Empty;
│   │   │  231 │         private DateTime _importDate = DateTime.UtcNow;
│   │   │  232 │         private long _fileSize;
│   │   │  233 │         private int _usageCount;
│   │   │  234 │         private int _variableCount;
│   │   │  235 │         private string _defaultTargetName = string.Empty;
│   │   │  236 │         private bool _isSelected;
│   │   │  237 │ 
│   │   │  238 │         /// <summary>
│   │   │  239 │         /// The type name
│   │   │  240 │         /// </summary>
│   │   │  241 │         public string TypeName
│   │   │  242 │         {
│   │   │  243 │             get => _typeName;
│   │   │  244 │             set => SetProperty(ref _typeName, value);
│   │   │  245 │         }
│   │   │  246 │ 
│   │   │  247 │         /// <summary>
│   │   │  248 │         /// The file name
│   │   │  249 │         /// </summary>
│   │   │  250 │         public string FileName
│   │   │  251 │         {
│   │   │  252 │             get => _fileName;
│   │   │  253 │             set => SetProperty(ref _fileName, value);
│   │   │  254 │         }
│   │   │  255 │ 
│   │   │  256 │         /// <summary>
│   │   │  257 │         /// The file path
│   │   │  258 │         /// </summary>
│   │   │  259 │         public string FilePath
│   │   │  260 │         {
│   │   │  261 │             get => _filePath;
│   │   │  262 │             set => SetProperty(ref _filePath, value);
│   │   │  263 │         }
│   │   │  264 │ 
│   │   │  265 │         /// <summary>
│   │   │  266 │         /// The category
│   │   │  267 │         /// </summary>
│   │   │  268 │         public string Category
│   │   │  269 │         {
│   │   │  270 │             get => _category;
│   │   │  271 │             set => SetProperty(ref _category, value);
│   │   │  272 │         }
│   │   │  273 │ 
│   │   │  274 │         /// <summary>
│   │   │  275 │         /// The description
│   │   │  276 │         /// </summary>
│   │   │  277 │         public string Description
│   │   │  278 │         {
│   │   │  279 │             get => _description;
│   │   │  280 │             set => SetProperty(ref _description, value);
│   │   │  281 │         }
│   │   │  282 │ 
│   │   │  283 │         /// <summary>
│   │   │  284 │         /// The date the type was imported
│   │   │  285 │         /// </summary>
│   │   │  286 │         public DateTime ImportDate
│   │   │  287 │         {
│   │   │  288 │             get => _importDate;
│   │   │  289 │             set => SetProperty(ref _importDate, value);
│   │   │  290 │         }
│   │   │  291 │ 
│   │   │  292 │         /// <summary>
│   │   │  293 │         /// The file size in bytes
│   │   │  294 │         /// </summary>
│   │   │  295 │         public long FileSize
│   │   │  296 │         {
│   │   │  297 │             get => _fileSize;
│   │   │  298 │             set => SetProperty(ref _fileSize, value);
│   │   │  299 │         }
│   │   │  300 │ 
│   │   │  301 │         /// <summary>
│   │   │  302 │         /// The number of times the type has been used
│   │   │  303 │         /// </summary>
│   │   │  304 │         public int UsageCount
│   │   │  305 │         {
│   │   │  306 │             get => _usageCount;
│   │   │  307 │             set => SetProperty(ref _usageCount, value);
│   │   │  308 │         }
│   │   │  309 │ 
│   │   │  310 │         /// <summary>
│   │   │  311 │         /// The number of variables in the type
│   │   │  312 │         /// </summary>
│   │   │  313 │         public int VariableCount
│   │   │  314 │         {
│   │   │  315 │             get => _variableCount;
│   │   │  316 │             set => SetProperty(ref _variableCount, value);
│   │   │  317 │         }
│   │   │  318 │ 
│   │   │  319 │         /// <summary>
│   │   │  320 │         /// The default target name
│   │   │  321 │         /// </summary>
│   │   │  322 │         public string DefaultTargetName
│   │   │  323 │         {
│   │   │  324 │             get => _defaultTargetName;
│   │   │  325 │             set => SetProperty(ref _defaultTargetName, value);
│   │   │  326 │         }
│   │   │  327 │ 
│   │   │  328 │         /// <summary>
│   │   │  329 │         /// Whether the type is selected in the UI
│   │   │  330 │         /// </summary>
│   │   │  331 │         public bool IsSelected
│   │   │  332 │         {
│   │   │  333 │             get => _isSelected;
│   │   │  334 │             set => SetProperty(ref _isSelected, value);
│   │   │  335 │         }
│   │   │  336 │     }
│   │   │  337 │ 
│   │   │  338 │     /// <summary>
│   │   │  339 │     /// View model for a custom type file
│   │   │  340 │     /// </summary>
│   │   │  341 │     public class CustomTypeFileViewModel : ViewModelBase
│   │   │  342 │     {
│   │   │  343 │         private string _fileName = string.Empty;
│   │   │  344 │         private int _typeCount;
│   │   │  345 │         private DateTime _lastModified = DateTime.UtcNow;
│   │   │  346 │         private string _description = string.Empty;
│   │   │  347 │         private bool _isSelected;
│   │   │  348 │ 
│   │   │  349 │         /// <summary>
│   │   │  350 │         /// The file name
│   │   │  351 │         /// </summary>
│   │   │  352 │         public string FileName
│   │   │  353 │         {
│   │   │  354 │             get => _fileName;
│   │   │  355 │             set => SetProperty(ref _fileName, value);
│   │   │  356 │         }
│   │   │  357 │ 
│   │   │  358 │         /// <summary>
│   │   │  359 │         /// The number of types in the file
│   │   │  360 │         /// </summary>
│   │   │  361 │         public int TypeCount
│   │   │  362 │         {
│   │   │  363 │             get => _typeCount;
│   │   │  364 │             set => SetProperty(ref _typeCount, value);
│   │   │  365 │         }
│   │   │  366 │ 
│   │   │  367 │         /// <summary>
│   │   │  368 │         /// The date the file was last modified
│   │   │  369 │         /// </summary>
│   │   │  370 │         public DateTime LastModified
│   │   │  371 │         {
│   │   │  372 │             get => _lastModified;
│   │   │  373 │             set => SetProperty(ref _lastModified, value);
│   │   │  374 │         }
│   │   │  375 │ 
│   │   │  376 │         /// <summary>
│   │   │  377 │         /// The description
│   │   │  378 │         /// </summary>
│   │   │  379 │         public string Description
│   │   │  380 │         {
│   │   │  381 │             get => _description;
│   │   │  382 │             set => SetProperty(ref _description, value);
│   │   │  383 │         }
│   │   │  384 │ 
│   │   │  385 │         /// <summary>
│   │   │  386 │         /// Whether the file is selected in the UI
│   │   │  387 │         /// </summary>
│   │   │  388 │         public bool IsSelected
│   │   │  389 │         {
│   │   │  390 │             get => _isSelected;
│   │   │  391 │             set => SetProperty(ref _isSelected, value);
│   │   │  392 │         }
│   │   │  393 │     }
│   │   │  394 │ }
│   │   └──────────────────────────────────────────────────────────────────────
│   ├── 📄 ProjectsViewModel.cs (7.22 KB, 2025-03-11 09:48:27)
│   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │ FILE CONTENT: ProjectsViewModel.cs
│   │   ├──────────────────────────────────────────────────────────────────────
│   │   │    1 │ ﻿using System;
│   │   │    2 │ using System.Collections.ObjectModel;
│   │   │    3 │ using System.Linq;
│   │   │    4 │ using System.Threading.Tasks;
│   │   │    5 │ using CommunityToolkit.Mvvm.Input;
│   │   │    6 │ using Microsoft.Extensions.Logging;
│   │   │    7 │ using test.Application.Services;
│   │   │    8 │ using test.Core.Interfaces;
│   │   │    9 │ 
│   │   │   10 │ namespace test.ViewModels
│   │   │   11 │ {
│   │   │   12 │     /// <summary>
│   │   │   13 │     /// View model for the projects view
│   │   │   14 │     /// </summary>
│   │   │   15 │     public class ProjectsViewModel : ViewModelBase
│   │   │   16 │     {
│   │   │   17 │         private readonly ProjectService _projectService;
│   │   │   18 │         private readonly IErrorHandler _errorHandler;
│   │   │   19 │         private readonly IDialogService _dialogService;
│   │   │   20 │         private readonly ILogger<ProjectsViewModel> _logger;
│   │   │   21 │ 
│   │   │   22 │         private ObservableCollection<ProjectViewModel> _projects = new();
│   │   │   23 │         private ProjectViewModel _selectedProject;
│   │   │   24 │ 
│   │   │   25 │         /// <summary>
│   │   │   26 │         /// The collection of projects
│   │   │   27 │         /// </summary>
│   │   │   28 │         public ObservableCollection<ProjectViewModel> Projects
│   │   │   29 │         {
│   │   │   30 │             get => _projects;
│   │   │   31 │             set => SetProperty(ref _projects, value);
│   │   │   32 │         }
│   │   │   33 │ 
│   │   │   34 │         /// <summary>
│   │   │   35 │         /// The currently selected project
│   │   │   36 │         /// </summary>
│   │   │   37 │         public ProjectViewModel SelectedProject
│   │   │   38 │         {
│   │   │   39 │             get => _selectedProject;
│   │   │   40 │             set => SetProperty(ref _selectedProject, value);
│   │   │   41 │         }
│   │   │   42 │ 
│   │   │   43 │         /// <summary>
│   │   │   44 │         /// Command to add a new project
│   │   │   45 │         /// </summary>
│   │   │   46 │         public IRelayCommand AddProjectCommand { get; }
│   │   │   47 │ 
│   │   │   48 │         /// <summary>
│   │   │   49 │         /// Command to delete a project
│   │   │   50 │         /// </summary>
│   │   │   51 │         public IRelayCommand<ProjectViewModel> DeleteProjectCommand { get; }
│   │   │   52 │ 
│   │   │   53 │         /// <summary>
│   │   │   54 │         /// Command to refresh the projects list
│   │   │   55 │         /// </summary>
│   │   │   56 │         public IAsyncRelayCommand RefreshProjectsCommand { get; }
│   │   │   57 │ 
│   │   │   58 │         /// <summary>
│   │   │   59 │         /// Creates a design-time projects view model
│   │   │   60 │         /// </summary>
│   │   │   61 │         public ProjectsViewModel()
│   │   │   62 │         {
│   │   │   63 │             // Design-time constructor
│   │   │   64 │             try
│   │   │   65 │             {
│   │   │   66 │                 // Add some design-time data for tooling
│   │   │   67 │                 Projects.Add(new ProjectViewModel
│   │   │   68 │                 {
│   │   │   69 │                     ProjectId = "project1",
│   │   │   70 │                     Name = "Sample Project",
│   │   │   71 │                     Description = "This is a sample project for design-time"
│   │   │   72 │                 });
│   │   │   73 │             }
│   │   │   74 │             catch
│   │   │   75 │             {
│   │   │   76 │                 // Ignore any errors in design mode
│   │   │   77 │             }
│   │   │   78 │         }
│   │   │   79 │ 
│   │   │   80 │         /// <summary>
│   │   │   81 │         /// Creates a new projects view model
│   │   │   82 │         /// </summary>
│   │   │   83 │         public ProjectsViewModel(
│   │   │   84 │             ProjectService projectService,
│   │   │   85 │             IErrorHandler errorHandler,
│   │   │   86 │             IDialogService dialogService,
│   │   │   87 │             ILogger<ProjectsViewModel> logger)
│   │   │   88 │         {
│   │   │   89 │             _projectService = projectService ?? throw new ArgumentNullException(nameof(projectService));
│   │   │   90 │             _errorHandler = errorHandler ?? throw new ArgumentNullException(nameof(errorHandler));
│   │   │   91 │             _dialogService = dialogService ?? throw new ArgumentNullException(nameof(dialogService));
│   │   │   92 │             _logger = logger ?? throw new ArgumentNullException(nameof(logger));
│   │   │   93 │ 
│   │   │   94 │             // Initialize commands using CommunityToolkit.Mvvm commands
│   │   │   95 │             AddProjectCommand = new AsyncRelayCommand(AddProjectAsync);
│   │   │   96 │             DeleteProjectCommand = new AsyncRelayCommand<ProjectViewModel>(DeleteProjectAsync, CanDeleteProject);
│   │   │   97 │             RefreshProjectsCommand = new AsyncRelayCommand(LoadProjectsAsync);
│   │   │   98 │ 
│   │   │   99 │             // Load projects on startup
│   │   │  100 │             LoadProjectsAsync().ConfigureAwait(false);
│   │   │  101 │         }
│   │   │  102 │ 
│   │   │  103 │         /// <summary>
│   │   │  104 │         /// Loads projects from the service
│   │   │  105 │         /// </summary>
│   │   │  106 │         private async Task LoadProjectsAsync()
│   │   │  107 │         {
│   │   │  108 │             await ExecuteWithBusyIndicationAsync(async () =>
│   │   │  109 │             {
│   │   │  110 │                 var projectVms = await _projectService.GetAllProjectsAsync();
│   │   │  111 │                 Projects.Clear();
│   │   │  112 │ 
│   │   │  113 │                 foreach (var project in projectVms)
│   │   │  114 │                 {
│   │   │  115 │                     Projects.Add(project);
│   │   │  116 │                 }
│   │   │  117 │ 
│   │   │  118 │                 return true;
│   │   │  119 │             }, $"Loaded {Projects.Count} projects", "Error loading projects");
│   │   │  120 │         }
│   │   │  121 │ 
│   │   │  122 │         /// <summary>
│   │   │  123 │         /// Adds a new project
│   │   │  124 │         /// </summary>
│   │   │  125 │         private async Task AddProjectAsync()
│   │   │  126 │         {
│   │   │  127 │             try
│   │   │  128 │             {
│   │   │  129 │                 string projectName = await _dialogService.ShowInputDialogAsync(
│   │   │  130 │                     "New Project",
│   │   │  131 │                     "Enter project name:",
│   │   │  132 │                     "New Project");
│   │   │  133 │ 
│   │   │  134 │                 if (string.IsNullOrWhiteSpace(projectName))
│   │   │  135 │                     return;
│   │   │  136 │ 
│   │   │  137 │                 string description = await _dialogService.ShowInputDialogAsync(
│   │   │  138 │                     "Project Description",
│   │   │  139 │                     "Enter project description (optional):",
│   │   │  140 │                     "");
│   │   │  141 │ 
│   │   │  142 │                 await ExecuteWithBusyIndicationAsync(async () =>
│   │   │  143 │                 {
│   │   │  144 │                     var project = await _projectService.CreateProjectAsync(projectName, description);
│   │   │  145 │                     Projects.Add(project);
│   │   │  146 │                     SelectedProject = project;
│   │   │  147 │                     return true;
│   │   │  148 │                 }, $"Created project: {projectName}", "Error creating project");
│   │   │  149 │             }
│   │   │  150 │             catch (Exception ex)
│   │   │  151 │             {
│   │   │  152 │                 await _errorHandler.HandleExceptionWithUIAsync(ex, "AddProject");
│   │   │  153 │                 SetErrorMessage($"Error creating project: {ex.Message}");
│   │   │  154 │             }
│   │   │  155 │         }
│   │   │  156 │ 
│   │   │  157 │         /// <summary>
│   │   │  158 │         /// Deletes a project
│   │   │  159 │         /// </summary>
│   │   │  160 │         private async Task DeleteProjectAsync(ProjectViewModel project)
│   │   │  161 │         {
│   │   │  162 │             if (project == null)
│   │   │  163 │                 return;
│   │   │  164 │ 
│   │   │  165 │             try
│   │   │  166 │             {
│   │   │  167 │                 bool confirm = await _dialogService.ShowConfirmDialogAsync(
│   │   │  168 │                     "Delete Project",
│   │   │  169 │                     $"Are you sure you want to delete project '{project.Name}'? This action cannot be undone.");
│   │   │  170 │ 
│   │   │  171 │                 if (!confirm)
│   │   │  172 │                     return;
│   │   │  173 │ 
│   │   │  174 │                 await ExecuteWithBusyIndicationAsync(async () =>
│   │   │  175 │                 {
│   │   │  176 │                     bool success = await _projectService.DeleteProjectAsync(project.ProjectId);
│   │   │  177 │                     if (success)
│   │   │  178 │                     {
│   │   │  179 │                         Projects.Remove(project);
│   │   │  180 │                         if (SelectedProject == project)
│   │   │  181 │                         {
│   │   │  182 │                             SelectedProject = Projects.FirstOrDefault();
│   │   │  183 │                         }
│   │   │  184 │                         return true;
│   │   │  185 │                     }
│   │   │  186 │                     else
│   │   │  187 │                     {
│   │   │  188 │                         SetErrorMessage($"Failed to delete project: {project.Name}");
│   │   │  189 │                         return false;
│   │   │  190 │                     }
│   │   │  191 │                 }, $"Deleted project: {project.Name}", "Error deleting project");
│   │   │  192 │             }
│   │   │  193 │             catch (Exception ex)
│   │   │  194 │             {
│   │   │  195 │                 await _errorHandler.HandleExceptionWithUIAsync(ex, "DeleteProject");
│   │   │  196 │                 SetErrorMessage($"Error deleting project: {ex.Message}");
│   │   │  197 │             }
│   │   │  198 │         }
│   │   │  199 │ 
│   │   │  200 │         /// <summary>
│   │   │  201 │         /// Determines whether a project can be deleted
│   │   │  202 │         /// </summary>
│   │   │  203 │         private bool CanDeleteProject(ProjectViewModel project)
│   │   │  204 │         {
│   │   │  205 │             return project != null;
│   │   │  206 │         }
│   │   │  207 │     }
│   │   │  208 │ }
│   │   └──────────────────────────────────────────────────────────────────────
│   ├── 📄 SettingsViewModel.cs (10.42 KB, 2025-03-12 14:46:55)
│   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │ FILE CONTENT: SettingsViewModel.cs
│   │   ├──────────────────────────────────────────────────────────────────────
│   │   │    1 │ ﻿using System;
│   │   │    2 │ using System.Collections.Generic;
│   │   │    3 │ using System.Threading;
│   │   │    4 │ using System.Threading.Tasks;
│   │   │    5 │ using Avalonia.Controls;
│   │   │    6 │ using Avalonia.Styling;
│   │   │    7 │ using CommunityToolkit.Mvvm.ComponentModel;
│   │   │    8 │ using CommunityToolkit.Mvvm.Input;
│   │   │    9 │ using Microsoft.Extensions.Logging;
│   │   │   10 │ using Serilog.Events;
│   │   │   11 │ using SukiUI;
│   │   │   12 │ using SukiUI.Theme;
│   │   │   13 │ using test.Core.Interfaces;
│   │   │   14 │ using test.Infrastructure;
│   │   │   15 │ 
│   │   │   16 │ namespace test.ViewModels
│   │   │   17 │ {
│   │   │   18 │     public partial class SettingsViewModel : ViewModelBase
│   │   │   19 │     {
│   │   │   20 │         private readonly ISettingsManager _settingsManager;
│   │   │   21 │         private readonly ILoggingService _loggingService;
│   │   │   22 │         private readonly ILogger<SettingsViewModel> _logger;
│   │   │   23 │         private readonly SukiTheme _theme;
│   │   │   24 │         private bool _isDesignMode;
│   │   │   25 │ 
│   │   │   26 │         // Prevent multiple concurrent theme changes
│   │   │   27 │         private readonly SemaphoreSlim _themeSwitchSemaphore = new SemaphoreSlim(1, 1);
│   │   │   28 │ 
│   │   │   29 │         [ObservableProperty]
│   │   │   30 │         private bool _enableLogging;
│   │   │   31 │ 
│   │   │   32 │         [ObservableProperty]
│   │   │   33 │         private string _selectedLogLevel = "Information";
│   │   │   34 │ 
│   │   │   35 │         [ObservableProperty]
│   │   │   36 │         private bool _deleteLogsOnExit;
│   │   │   37 │ 
│   │   │   38 │         [ObservableProperty]
│   │   │   39 │         private string _settingsPath = string.Empty;
│   │   │   40 │ 
│   │   │   41 │         [ObservableProperty]
│   │   │   42 │         private string _logFilePath = string.Empty;
│   │   │   43 │ 
│   │   │   44 │         [ObservableProperty]
│   │   │   45 │         private bool _isLightTheme;
│   │   │   46 │ 
│   │   │   47 │         public List<string> LogLevels { get; } = new()
│   │   │   48 │         {
│   │   │   49 │             "Verbose",
│   │   │   50 │             "Debug",
│   │   │   51 │             "Information",
│   │   │   52 │             "Warning",
│   │   │   53 │             "Error",
│   │   │   54 │             "Fatal"
│   │   │   55 │         };
│   │   │   56 │ 
│   │   │   57 │         public SettingsViewModel()
│   │   │   58 │         {
│   │   │   59 │             // Design-time constructor
│   │   │   60 │             _isDesignMode = Design.IsDesignMode;
│   │   │   61 │             IsLightTheme = true;
│   │   │   62 │             EnableLogging = true;
│   │   │   63 │             SelectedLogLevel = "Information";
│   │   │   64 │             SettingsPath = "C:\\AppData\\Settings.json"; // Fake path for design-time
│   │   │   65 │             LogFilePath = "C:\\AppData\\Logs\\app_20250312.log"; // Fake path for design-time
│   │   │   66 │         }
│   │   │   67 │ 
│   │   │   68 │         public SettingsViewModel(ISettingsManager settingsManager, ILoggingService loggingService = null, ILogger<SettingsViewModel> logger = null)
│   │   │   69 │         {
│   │   │   70 │             // Detect design mode
│   │   │   71 │             _isDesignMode = Design.IsDesignMode;
│   │   │   72 │ 
│   │   │   73 │             // Store services, allowing nulls for design mode
│   │   │   74 │             _settingsManager = settingsManager ?? throw new ArgumentNullException(nameof(settingsManager));
│   │   │   75 │             _loggingService = loggingService;
│   │   │   76 │             _logger = logger;
│   │   │   77 │ 
│   │   │   78 │             try
│   │   │   79 │             {
│   │   │   80 │                 // Get theme instance safely
│   │   │   81 │                 _theme = SukiTheme.GetInstance();
│   │   │   82 │             }
│   │   │   83 │             catch (Exception ex)
│   │   │   84 │             {
│   │   │   85 │                 // In design mode or if theme can't be accessed, just continue
│   │   │   86 │                 if (!_isDesignMode)
│   │   │   87 │                 {
│   │   │   88 │                     _logger?.LogError(ex, "Error getting theme instance");
│   │   │   89 │                 }
│   │   │   90 │             }
│   │   │   91 │ 
│   │   │   92 │             // Set initial values safely
│   │   │   93 │             if (_settingsManager != null)
│   │   │   94 │             {
│   │   │   95 │                 try
│   │   │   96 │                 {
│   │   │   97 │                     SettingsPath = _settingsManager.GetSettingsPath();
│   │   │   98 │ 
│   │   │   99 │                     // Get current settings
│   │   │  100 │                     var settings = _settingsManager.GetCurrentSettings();
│   │   │  101 │                     if (settings != null)
│   │   │  102 │                     {
│   │   │  103 │                         EnableLogging = settings.EnableLogging;
│   │   │  104 │                         SelectedLogLevel = settings.LogLevel ?? "Information";
│   │   │  105 │                         DeleteLogsOnExit = settings.DeleteLogsOnExit;
│   │   │  106 │                         IsLightTheme = settings.IsLightTheme;
│   │   │  107 │                     }
│   │   │  108 │                 }
│   │   │  109 │                 catch (Exception ex)
│   │   │  110 │                 {
│   │   │  111 │                     // Ignore errors in design mode
│   │   │  112 │                     if (!_isDesignMode)
│   │   │  113 │                     {
│   │   │  114 │                         _logger?.LogError(ex, "Error getting settings path");
│   │   │  115 │                     }
│   │   │  116 │                 }
│   │   │  117 │             }
│   │   │  118 │ 
│   │   │  119 │             // Set log file path
│   │   │  120 │             if (_loggingService != null)
│   │   │  121 │             {
│   │   │  122 │                 try
│   │   │  123 │                 {
│   │   │  124 │                     LogFilePath = _loggingService.LogFilePath;
│   │   │  125 │                     _logger?.LogDebug("Log file path set to: {LogFilePath}", LogFilePath);
│   │   │  126 │                 }
│   │   │  127 │                 catch (Exception ex)
│   │   │  128 │                 {
│   │   │  129 │                     if (!_isDesignMode)
│   │   │  130 │                     {
│   │   │  131 │                         _logger?.LogError(ex, "Error getting log file path");
│   │   │  132 │                     }
│   │   │  133 │                 }
│   │   │  134 │             }
│   │   │  135 │ 
│   │   │  136 │             // Try to get the current theme state safely
│   │   │  137 │             if (_theme != null)
│   │   │  138 │             {
│   │   │  139 │                 try
│   │   │  140 │                 {
│   │   │  141 │                     IsLightTheme = _theme.ActiveBaseTheme == ThemeVariant.Light;
│   │   │  142 │                     _logger?.LogDebug("Detected theme from SukiTheme: {Theme}", IsLightTheme ? "Light" : "Dark");
│   │   │  143 │ 
│   │   │  144 │                     // Only subscribe to theme changes if we're not in design mode
│   │   │  145 │                     if (!_isDesignMode)
│   │   │  146 │                     {
│   │   │  147 │                         _theme.OnBaseThemeChanged += OnThemeChanged;
│   │   │  148 │                     }
│   │   │  149 │                 }
│   │   │  150 │                 catch (Exception ex)
│   │   │  151 │                 {
│   │   │  152 │                     // Ignore errors in design mode
│   │   │  153 │                     if (!_isDesignMode)
│   │   │  154 │                     {
│   │   │  155 │                         _logger?.LogError(ex, "Error detecting current theme");
│   │   │  156 │                     }
│   │   │  157 │                 }
│   │   │  158 │             }
│   │   │  159 │ 
│   │   │  160 │             // Only set up property change handlers if we're not in design mode
│   │   │  161 │             if (!_isDesignMode)
│   │   │  162 │             {
│   │   │  163 │                 PropertyChanged += async (s, e) =>
│   │   │  164 │                 {
│   │   │  165 │                     switch (e.PropertyName)
│   │   │  166 │                     {
│   │   │  167 │                         case nameof(EnableLogging):
│   │   │  168 │                             if (_loggingService != null)
│   │   │  169 │                             {
│   │   │  170 │                                 _loggingService.EnableLogging(EnableLogging);
│   │   │  171 │                                 _logger?.LogDebug("Logging enabled set to {EnableLogging}", EnableLogging);
│   │   │  172 │                             }
│   │   │  173 │                             await SaveSettingsAsync();
│   │   │  174 │                             break;
│   │   │  175 │ 
│   │   │  176 │                         case nameof(SelectedLogLevel):
│   │   │  177 │                             if (_loggingService != null && Enum.TryParse<LogEventLevel>(SelectedLogLevel, out var level))
│   │   │  178 │                             {
│   │   │  179 │                                 _loggingService.SetLogLevel(level);
│   │   │  180 │                                 _logger?.LogDebug("Log level set to {Level}", level);
│   │   │  181 │                             }
│   │   │  182 │                             await SaveSettingsAsync();
│   │   │  183 │                             break;
│   │   │  184 │ 
│   │   │  185 │                         case nameof(IsLightTheme):
│   │   │  186 │                             await ApplyThemeChangeAsync();
│   │   │  187 │                             await SaveSettingsAsync();
│   │   │  188 │                             break;
│   │   │  189 │ 
│   │   │  190 │                         case nameof(DeleteLogsOnExit):
│   │   │  191 │                             await SaveSettingsAsync();
│   │   │  192 │                             break;
│   │   │  193 │                     }
│   │   │  194 │                 };
│   │   │  195 │             }
│   │   │  196 │         }
│   │   │  197 │ 
│   │   │  198 │         // Handle theme changes from external sources
│   │   │  199 │         private void OnThemeChanged(ThemeVariant variant)
│   │   │  200 │         {
│   │   │  201 │             try
│   │   │  202 │             {
│   │   │  203 │                 // Avoid overwriting the same value to prevent loops
│   │   │  204 │                 if (IsLightTheme != (variant == ThemeVariant.Light))
│   │   │  205 │                 {
│   │   │  206 │                     _logger?.LogDebug("Theme changed externally to {Theme}", variant);
│   │   │  207 │                     IsLightTheme = variant == ThemeVariant.Light;
│   │   │  208 │                 }
│   │   │  209 │             }
│   │   │  210 │             catch (Exception ex)
│   │   │  211 │             {
│   │   │  212 │                 _logger?.LogError(ex, "Error handling theme change event");
│   │   │  213 │             }
│   │   │  214 │         }
│   │   │  215 │ 
│   │   │  216 │         [RelayCommand]
│   │   │  217 │         private async Task SaveSettingsAsync()
│   │   │  218 │         {
│   │   │  219 │             if (_settingsManager == null || _isDesignMode) return;
│   │   │  220 │ 
│   │   │  221 │             try
│   │   │  222 │             {
│   │   │  223 │                 _logger?.LogDebug("Saving settings: IsLightTheme={IsLightTheme}, EnableLogging={EnableLogging}, LogLevel={LogLevel}",
│   │   │  224 │                     IsLightTheme, EnableLogging, SelectedLogLevel);
│   │   │  225 │ 
│   │   │  226 │                 var settings = new AppSettings
│   │   │  227 │                 {
│   │   │  228 │                     EnableLogging = EnableLogging,
│   │   │  229 │                     LogLevel = SelectedLogLevel,
│   │   │  230 │                     DeleteLogsOnExit = DeleteLogsOnExit,
│   │   │  231 │                     IsLightTheme = IsLightTheme
│   │   │  232 │                 };
│   │   │  233 │ 
│   │   │  234 │                 await _settingsManager.SaveSettingsAsync(settings);
│   │   │  235 │                 SetSuccessMessage("Settings saved successfully");
│   │   │  236 │             }
│   │   │  237 │             catch (Exception ex)
│   │   │  238 │             {
│   │   │  239 │                 _logger?.LogError(ex, "Error saving settings");
│   │   │  240 │                 SetErrorMessage($"Error saving settings: {ex.Message}");
│   │   │  241 │             }
│   │   │  242 │         }
│   │   │  243 │ 
│   │   │  244 │         private async Task ApplyThemeChangeAsync()
│   │   │  245 │         {
│   │   │  246 │             if (_theme == null || _isDesignMode) return;
│   │   │  247 │ 
│   │   │  248 │             try
│   │   │  249 │             {
│   │   │  250 │                 // Use semaphore to prevent multiple concurrent theme changes
│   │   │  251 │                 await _themeSwitchSemaphore.WaitAsync();
│   │   │  252 │ 
│   │   │  253 │                 try
│   │   │  254 │                 {
│   │   │  255 │                     _logger?.LogDebug("Applying theme change to {Theme}", IsLightTheme ? "Light" : "Dark");
│   │   │  256 │ 
│   │   │  257 │                     // Temporarily unsubscribe from theme changes to prevent feedback loops
│   │   │  258 │                     _theme.OnBaseThemeChanged -= OnThemeChanged;
│   │   │  259 │ 
│   │   │  260 │                     // Apply the theme change
│   │   │  261 │                     _theme.ChangeBaseTheme(IsLightTheme ? ThemeVariant.Light : ThemeVariant.Dark);
│   │   │  262 │ 
│   │   │  263 │                     // Also set at application level
│   │   │  264 │                     if (Avalonia.Application.Current != null)
│   │   │  265 │                     {
│   │   │  266 │                         Avalonia.Application.Current.RequestedThemeVariant =
│   │   │  267 │                             IsLightTheme ? ThemeVariant.Light : ThemeVariant.Dark;
│   │   │  268 │                     }
│   │   │  269 │ 
│   │   │  270 │                     // Small delay to ensure the theme change has been applied
│   │   │  271 │                     await Task.Delay(50);
│   │   │  272 │                 }
│   │   │  273 │                 finally
│   │   │  274 │                 {
│   │   │  275 │                     // Re-subscribe to theme changes
│   │   │  276 │                     _theme.OnBaseThemeChanged += OnThemeChanged;
│   │   │  277 │                     _themeSwitchSemaphore.Release();
│   │   │  278 │                 }
│   │   │  279 │             }
│   │   │  280 │             catch (Exception ex)
│   │   │  281 │             {
│   │   │  282 │                 _logger?.LogError(ex, "Error applying theme change");
│   │   │  283 │                 SetErrorMessage($"Error applying theme change: {ex.Message}");
│   │   │  284 │                 // Ignore exceptions in design mode
│   │   │  285 │                 if (!_isDesignMode) throw;
│   │   │  286 │             }
│   │   │  287 │         }
│   │   │  288 │     }
│   │   │  289 │ }
│   │   └──────────────────────────────────────────────────────────────────────
│   └── 📄 ViewModelBase.cs (5.01 KB, 2025-03-12 07:48:23)
│       ┌──────────────────────────────────────────────────────────────────────
│       │ FILE CONTENT: ViewModelBase.cs
│       ├──────────────────────────────────────────────────────────────────────
│       │    1 │ ﻿using System;
│       │    2 │ using System.Collections.Generic;
│       │    3 │ using System.Threading.Tasks;
│       │    4 │ using System.Windows.Input;
│       │    5 │ using CommunityToolkit.Mvvm.ComponentModel;
│       │    6 │ using CommunityToolkit.Mvvm.Input;
│       │    7 │ 
│       │    8 │ namespace test.ViewModels
│       │    9 │ {
│       │   10 │     /// <summary>
│       │   11 │     /// Base class for all view models in the application
│       │   12 │     /// Inherits from ObservableObject to provide property change notification
│       │   13 │     /// Adds common functionality needed across view models
│       │   14 │     /// </summary>
│       │   15 │     public abstract class ViewModelBase : ObservableObject
│       │   16 │     {
│       │   17 │         private bool _isBusy;
│       │   18 │         private string _statusMessage = string.Empty;
│       │   19 │         private bool _hasErrors;
│       │   20 │         private string _errorMessage = string.Empty;
│       │   21 │ 
│       │   22 │         /// <summary>
│       │   23 │         /// Indicates if the view model is currently performing a long-running operation
│       │   24 │         /// </summary>
│       │   25 │         public bool IsBusy
│       │   26 │         {
│       │   27 │             get => _isBusy;
│       │   28 │             protected set => SetProperty(ref _isBusy, value);
│       │   29 │         }
│       │   30 │ 
│       │   31 │         /// <summary>
│       │   32 │         /// Status message to display to the user
│       │   33 │         /// </summary>
│       │   34 │         public string StatusMessage
│       │   35 │         {
│       │   36 │             get => _statusMessage;
│       │   37 │             protected set => SetProperty(ref _statusMessage, value);
│       │   38 │         }
│       │   39 │ 
│       │   40 │         /// <summary>
│       │   41 │         /// Indicates if the view model has errors
│       │   42 │         /// </summary>
│       │   43 │         public bool HasErrors
│       │   44 │         {
│       │   45 │             get => _hasErrors;
│       │   46 │             protected set => SetProperty(ref _hasErrors, value);
│       │   47 │         }
│       │   48 │ 
│       │   49 │         /// <summary>
│       │   50 │         /// Error message to display to the user
│       │   51 │         /// </summary>
│       │   52 │         public string ErrorMessage
│       │   53 │         {
│       │   54 │             get => _errorMessage;
│       │   55 │             protected set => SetProperty(ref _errorMessage, value);
│       │   56 │         }
│       │   57 │ 
│       │   58 │         /// <summary>
│       │   59 │         /// Sets a success status message
│       │   60 │         /// </summary>
│       │   61 │         /// <param name="message">The message to display</param>
│       │   62 │         protected void SetSuccessMessage(string message)
│       │   63 │         {
│       │   64 │             StatusMessage = message;
│       │   65 │             HasErrors = false;
│       │   66 │             ErrorMessage = string.Empty;
│       │   67 │         }
│       │   68 │ 
│       │   69 │         /// <summary>
│       │   70 │         /// Sets an error message
│       │   71 │         /// </summary>
│       │   72 │         /// <param name="message">The error message to display</param>
│       │   73 │         protected void SetErrorMessage(string message)
│       │   74 │         {
│       │   75 │             ErrorMessage = message;
│       │   76 │             HasErrors = true;
│       │   77 │             StatusMessage = string.Empty;
│       │   78 │         }
│       │   79 │ 
│       │   80 │         /// <summary>
│       │   81 │         /// Executes an async operation with busy indication and error handling
│       │   82 │         /// </summary>
│       │   83 │         /// <typeparam name="T">The result type</typeparam>
│       │   84 │         /// <param name="operation">The operation to execute</param>
│       │   85 │         /// <param name="successMessage">The success message to display</param>
│       │   86 │         /// <param name="errorMessage">The error message prefix to display</param>
│       │   87 │         /// <returns>The operation result or default value if an error occurred</returns>
│       │   88 │         protected async Task<T> ExecuteWithBusyIndicationAsync<T>(
│       │   89 │             Func<Task<T>> operation,
│       │   90 │             string successMessage = null,
│       │   91 │             string errorMessage = "Operation failed")
│       │   92 │         {
│       │   93 │             IsBusy = true;
│       │   94 │             HasErrors = false;
│       │   95 │             StatusMessage = "Working...";
│       │   96 │ 
│       │   97 │             try
│       │   98 │             {
│       │   99 │                 var result = await operation();
│       │  100 │                 if (!string.IsNullOrEmpty(successMessage))
│       │  101 │                 {
│       │  102 │                     SetSuccessMessage(successMessage);
│       │  103 │                 }
│       │  104 │                 return result;
│       │  105 │             }
│       │  106 │             catch (Exception ex)
│       │  107 │             {
│       │  108 │                 SetErrorMessage($"{errorMessage}: {ex.Message}");
│       │  109 │                 return default;
│       │  110 │             }
│       │  111 │             finally
│       │  112 │             {
│       │  113 │                 IsBusy = false;
│       │  114 │             }
│       │  115 │         }
│       │  116 │ 
│       │  117 │         /// <summary>
│       │  118 │         /// Executes an async operation with busy indication and error handling
│       │  119 │         /// </summary>
│       │  120 │         /// <param name="operation">The operation to execute</param>
│       │  121 │         /// <param name="successMessage">The success message to display</param>
│       │  122 │         /// <param name="errorMessage">The error message prefix to display</param>
│       │  123 │         /// <returns>True if the operation succeeded, false otherwise</returns>
│       │  124 │         protected async Task<bool> ExecuteWithBusyIndicationAsync(
│       │  125 │             Func<Task> operation,
│       │  126 │             string successMessage = null,
│       │  127 │             string errorMessage = "Operation failed")
│       │  128 │         {
│       │  129 │             IsBusy = true;
│       │  130 │             HasErrors = false;
│       │  131 │             StatusMessage = "Working...";
│       │  132 │ 
│       │  133 │             try
│       │  134 │             {
│       │  135 │                 await operation();
│       │  136 │                 if (!string.IsNullOrEmpty(successMessage))
│       │  137 │                 {
│       │  138 │                     SetSuccessMessage(successMessage);
│       │  139 │                 }
│       │  140 │                 return true;
│       │  141 │             }
│       │  142 │             catch (Exception ex)
│       │  143 │             {
│       │  144 │                 SetErrorMessage($"{errorMessage}: {ex.Message}");
│       │  145 │                 return false;
│       │  146 │             }
│       │  147 │             finally
│       │  148 │             {
│       │  149 │                 IsBusy = false;
│       │  150 │             }
│       │  151 │         }
│       │  152 │     }
│       │  153 │ }
│       └──────────────────────────────────────────────────────────────────────
│   📁 Application
│       📁 Services
│       │   📁 Parsers
│       │   └── 📄 ObjectSetParserImpl.cs (9.82 KB, 2025-03-11 14:56:55)
│       │       ┌──────────────────────────────────────────────────────────────────────
│       │       │ FILE CONTENT: ObjectSetParserImpl.cs
│       │       ├──────────────────────────────────────────────────────────────────────
│       │       │    1 │ ﻿using Microsoft.Extensions.Logging;
│       │       │    2 │ using System;
│       │       │    3 │ using System.Collections.Generic;
│       │       │    4 │ using System.Linq;
│       │       │    5 │ using System.Threading.Tasks;
│       │       │    6 │ using System.Xml.Linq;
│       │       │    7 │ using test.Core.Domain.ObjectSet;
│       │       │    8 │ using test.Core.Interfaces;
│       │       │    9 │ 
│       │       │   10 │ namespace test.Application.Services.Parsers
│       │       │   11 │ {
│       │       │   12 │     /// <summary>
│       │       │   13 │     /// Implementation of the ObjectSet parser
│       │       │   14 │     /// </summary>
│       │       │   15 │     public class ObjectSetParserImpl : IObjectSetParser
│       │       │   16 │     {
│       │       │   17 │         private readonly ILogger<ObjectSetParserImpl> _logger;
│       │       │   18 │ 
│       │       │   19 │         /// <summary>
│       │       │   20 │         /// Creates a new ObjectSet parser
│       │       │   21 │         /// </summary>
│       │       │   22 │         /// <param name="logger">Logger</param>
│       │       │   23 │         public ObjectSetParserImpl(ILogger<ObjectSetParserImpl> logger)
│       │       │   24 │         {
│       │       │   25 │             _logger = logger ?? throw new ArgumentNullException(nameof(logger));
│       │       │   26 │         }
│       │       │   27 │ 
│       │       │   28 │         /// <inheritdoc/>
│       │       │   29 │         public async Task<ObjectSetParseResult> ParseAsync(XDocument document, ObjectSetParsingOptions options)
│       │       │   30 │         {
│       │       │   31 │             var result = new ObjectSetParseResult();
│       │       │   32 │ 
│       │       │   33 │             try
│       │       │   34 │             {
│       │       │   35 │                 if (options.IncludeMetaInformation)
│       │       │   36 │                 {
│       │       │   37 │                     result.MetaInfo = ParseMetaInformation(document);
│       │       │   38 │                 }
│       │       │   39 │ 
│       │       │   40 │                 if (options.IncludeTypeDefinitions)
│       │       │   41 │                 {
│       │       │   42 │                     result.Types = ParseTypeDefinitions(document, options.TypeWhitelist);
│       │       │   43 │                 }
│       │       │   44 │ 
│       │       │   45 │                 if (options.IncludeExportedObjects)
│       │       │   46 │                 {
│       │       │   47 │                     result.ExportedObjects = ParseExportedObjects(document);
│       │       │   48 │                 }
│       │       │   49 │ 
│       │       │   50 │                 result.Success = true;
│       │       │   51 │             }
│       │       │   52 │             catch (Exception ex)
│       │       │   53 │             {
│       │       │   54 │                 result.Success = false;
│       │       │   55 │                 result.ErrorMessage = ex.Message;
│       │       │   56 │                 _logger.LogError(ex, "Error parsing ObjectSet XML");
│       │       │   57 │             }
│       │       │   58 │ 
│       │       │   59 │             return result;
│       │       │   60 │         }
│       │       │   61 │ 
│       │       │   62 │         /// <inheritdoc/>
│       │       │   63 │         public MetaInformation ParseMetaInformation(XDocument doc)
│       │       │   64 │         {
│       │       │   65 │             var metaElement = doc.Root?.Element("MetaInformation");
│       │       │   66 │             if (metaElement == null) return null;
│       │       │   67 │ 
│       │       │   68 │             return new MetaInformation
│       │       │   69 │             {
│       │       │   70 │                 ExportMode = metaElement.Element("ExportMode")?.Attribute("Value")?.Value,
│       │       │   71 │                 SemanticsFilter = metaElement.Element("SemanticsFilter")?.Attribute("Value")?.Value,
│       │       │   72 │                 RuntimeVersion = metaElement.Element("RuntimeVersion")?.Attribute("Value")?.Value,
│       │       │   73 │                 SourceVersion = metaElement.Element("SourceVersion")?.Attribute("Value")?.Value,
│       │       │   74 │                 ServerFullPath = metaElement.Element("ServerFullPath")?.Attribute("Value")?.Value
│       │       │   75 │             };
│       │       │   76 │         }
│       │       │   77 │ 
│       │       │   78 │         /// <inheritdoc/>
│       │       │   79 │         public List<ObjectTypeDefinition> ParseTypeDefinitions(XDocument doc, HashSet<string> typeWhitelist = null)
│       │       │   80 │         {
│       │       │   81 │             var types = new List<ObjectTypeDefinition>();
│       │       │   82 │             var typesElement = doc.Root?.Element("Types");
│       │       │   83 │             if (typesElement == null) return types;
│       │       │   84 │ 
│       │       │   85 │             foreach (var typeElement in typesElement.Elements("ObjectType"))
│       │       │   86 │             {
│       │       │   87 │                 var name = typeElement.Attribute("Name")?.Value;
│       │       │   88 │                 if (string.IsNullOrEmpty(name) || (typeWhitelist?.Any() == true && !typeWhitelist.Contains(name)))
│       │       │   89 │                     continue;
│       │       │   90 │ 
│       │       │   91 │                 var type = new ObjectTypeDefinition
│       │       │   92 │                 {
│       │       │   93 │                     Name = name,
│       │       │   94 │                     DisplayName = typeElement.Attribute("DisplayName")?.Value,
│       │       │   95 │                     Description = typeElement.Attribute("Description")?.Value,
│       │       │   96 │                     PropertyTabs = ParsePropertyTabs(typeElement)
│       │       │   97 │                 };
│       │       │   98 │ 
│       │       │   99 │                 types.Add(type);
│       │       │  100 │             }
│       │       │  101 │ 
│       │       │  102 │             return types;
│       │       │  103 │         }
│       │       │  104 │ 
│       │       │  105 │         /// <inheritdoc/>
│       │       │  106 │         public List<ExportedObject> ParseExportedObjects(XDocument doc)
│       │       │  107 │         {
│       │       │  108 │             var objects = new List<ExportedObject>();
│       │       │  109 │             var exportedElement = doc.Root?.Element("ExportedObjects");
│       │       │  110 │             if (exportedElement == null) return objects;
│       │       │  111 │ 
│       │       │  112 │             foreach (var objElement in exportedElement.Elements("OI"))
│       │       │  113 │             {
│       │       │  114 │                 objects.Add(ParseExportedObject(objElement));
│       │       │  115 │             }
│       │       │  116 │ 
│       │       │  117 │             return objects;
│       │       │  118 │         }
│       │       │  119 │ 
│       │       │  120 │         /// <summary>
│       │       │  121 │         /// Parses property tabs from an object type element
│       │       │  122 │         /// </summary>
│       │       │  123 │         private List<PropertyTab> ParsePropertyTabs(XElement typeElement)
│       │       │  124 │         {
│       │       │  125 │             var tabs = new List<PropertyTab>();
│       │       │  126 │ 
│       │       │  127 │             foreach (var tabElement in typeElement.Elements("PropertyTab"))
│       │       │  128 │             {
│       │       │  129 │                 var tab = new PropertyTab
│       │       │  130 │                 {
│       │       │  131 │                     Name = tabElement.Attribute("Name")?.Value,
│       │       │  132 │                     PropertyGroups = ParsePropertyGroups(tabElement)
│       │       │  133 │                 };
│       │       │  134 │                 tabs.Add(tab);
│       │       │  135 │             }
│       │       │  136 │ 
│       │       │  137 │             return tabs;
│       │       │  138 │         }
│       │       │  139 │ 
│       │       │  140 │         /// <summary>
│       │       │  141 │         /// Parses property groups from a property tab element
│       │       │  142 │         /// </summary>
│       │       │  143 │         private List<PropertyGroup> ParsePropertyGroups(XElement tabElement)
│       │       │  144 │         {
│       │       │  145 │             var groups = new List<PropertyGroup>();
│       │       │  146 │ 
│       │       │  147 │             foreach (var groupElement in tabElement.Elements("PropertyGroup"))
│       │       │  148 │             {
│       │       │  149 │                 var group = new PropertyGroup
│       │       │  150 │                 {
│       │       │  151 │                     Name = groupElement.Attribute("Name")?.Value,
│       │       │  152 │                     Parameters = ParseParameters(groupElement),
│       │       │  153 │                     Variables = ParseVariables(groupElement)
│       │       │  154 │                 };
│       │       │  155 │                 groups.Add(group);
│       │       │  156 │             }
│       │       │  157 │ 
│       │       │  158 │             return groups;
│       │       │  159 │         }
│       │       │  160 │ 
│       │       │  161 │         /// <summary>
│       │       │  162 │         /// Parses parameters from a property group element
│       │       │  163 │         /// </summary>
│       │       │  164 │         private List<Parameter> ParseParameters(XElement groupElement)
│       │       │  165 │         {
│       │       │  166 │             var parameters = new List<Parameter>();
│       │       │  167 │ 
│       │       │  168 │             foreach (var paramElement in groupElement.Elements("Parameter"))
│       │       │  169 │             {
│       │       │  170 │                 var param = new Parameter
│       │       │  171 │                 {
│       │       │  172 │                     Name = paramElement.Attribute("Name")?.Value,
│       │       │  173 │                     DisplayName = paramElement.Attribute("DisplayName")?.Value,
│       │       │  174 │                     Description = paramElement.Attribute("Description")?.Value,
│       │       │  175 │                     Type = new ParameterType { Value = paramElement.Element("Type")?.Attribute("Value")?.Value },
│       │       │  176 │                     Unit = paramElement.Element("Unit")?.Attribute("Value")?.Value,
│       │       │  177 │                     InitValue = paramElement.Element("InitValue")?.Attribute("Value")?.Value,
│       │       │  178 │                     FileContents = paramElement.Element("InitValue")?.Element("FileContents")?.Value
│       │       │  179 │                 };
│       │       │  180 │                 parameters.Add(param);
│       │       │  181 │             }
│       │       │  182 │ 
│       │       │  183 │             return parameters;
│       │       │  184 │         }
│       │       │  185 │ 
│       │       │  186 │         /// <summary>
│       │       │  187 │         /// Parses variables from a property group element
│       │       │  188 │         /// </summary>
│       │       │  189 │         private List<Variable> ParseVariables(XElement groupElement)
│       │       │  190 │         {
│       │       │  191 │             var variables = new List<Variable>();
│       │       │  192 │ 
│       │       │  193 │             foreach (var varElement in groupElement.Elements("Variable"))
│       │       │  194 │             {
│       │       │  195 │                 var variable = new Variable
│       │       │  196 │                 {
│       │       │  197 │                     Name = varElement.Attribute("Name")?.Value,
│       │       │  198 │                     DisplayName = varElement.Attribute("DisplayName")?.Value,
│       │       │  199 │                     Description = varElement.Attribute("Description")?.Value,
│       │       │  200 │                     Type = new ParameterType { Value = varElement.Element("Type")?.Attribute("Value")?.Value },
│       │       │  201 │                     Unit = varElement.Element("Unit")?.Attribute("Value")?.Value,
│       │       │  202 │                     Runtime = ParseRuntime(varElement.Element("Runtime"))
│       │       │  203 │                 };
│       │       │  204 │                 variables.Add(variable);
│       │       │  205 │             }
│       │       │  206 │ 
│       │       │  207 │             return variables;
│       │       │  208 │         }
│       │       │  209 │ 
│       │       │  210 │         /// <summary>
│       │       │  211 │         /// Parses runtime properties from a runtime element
│       │       │  212 │         /// </summary>
│       │       │  213 │         private Runtime ParseRuntime(XElement runtimeElement)
│       │       │  214 │         {
│       │       │  215 │             if (runtimeElement == null) return null;
│       │       │  216 │ 
│       │       │  217 │             return new Runtime
│       │       │  218 │             {
│       │       │  219 │                 ReadOnly = runtimeElement.Element("ReadOnly")?.Attribute("Value")?.Value == "1",
│       │       │  220 │                 RetainLevel = runtimeElement.Element("RetainLevel")?.Attribute("Value")?.Value,
│       │       │  221 │                 Forceable = runtimeElement.Element("Forceable")?.Attribute("Value")?.Value == "1",
│       │       │  222 │                 InitValue = runtimeElement.Element("InitValue")?.Value
│       │       │  223 │             };
│       │       │  224 │         }
│       │       │  225 │ 
│       │       │  226 │         /// <summary>
│       │       │  227 │         /// Parses an exported object from an OI element
│       │       │  228 │         /// </summary>
│       │       │  229 │         private ExportedObject ParseExportedObject(XElement element)
│       │       │  230 │         {
│       │       │  231 │             var obj = new ExportedObject
│       │       │  232 │             {
│       │       │  233 │                 Name = element.Attribute("NAME")?.Value,
│       │       │  234 │                 Children = new List<ExportedObject>(),
│       │       │  235 │                 Properties = new Dictionary<string, string>()
│       │       │  236 │             };
│       │       │  237 │ 
│       │       │  238 │             // Add TYPE as a property
│       │       │  239 │             var type = element.Attribute("TYPE")?.Value;
│       │       │  240 │             if (!string.IsNullOrEmpty(type))
│       │       │  241 │             {
│       │       │  242 │                 obj.Properties["TYPE"] = type;
│       │       │  243 │             }
│       │       │  244 │ 
│       │       │  245 │             // Add DESCR as a property if present
│       │       │  246 │             var descr = element.Attribute("DESCR")?.Value;
│       │       │  247 │             if (!string.IsNullOrEmpty(descr))
│       │       │  248 │             {
│       │       │  249 │                 obj.Properties["DESCR"] = descr;
│       │       │  250 │             }
│       │       │  251 │ 
│       │       │  252 │             // Parse all PI elements
│       │       │  253 │             foreach (var pi in element.Elements("PI"))
│       │       │  254 │             {
│       │       │  255 │                 var name = pi.Attribute("Name")?.Value;
│       │       │  256 │                 var value = pi.Attribute("Value")?.Value;
│       │       │  257 │                 if (!string.IsNullOrEmpty(name))
│       │       │  258 │                 {
│       │       │  259 │                     obj.Properties[name] = value ?? string.Empty;
│       │       │  260 │                 }
│       │       │  261 │             }
│       │       │  262 │ 
│       │       │  263 │             // Recursively parse child objects
│       │       │  264 │             foreach (var childElement in element.Elements("OI"))
│       │       │  265 │             {
│       │       │  266 │                 obj.Children.Add(ParseExportedObject(childElement));
│       │       │  267 │             }
│       │       │  268 │ 
│       │       │  269 │             return obj;
│       │       │  270 │         }
│       │       │  271 │     }
│       │       │  272 │ }
│       │       └──────────────────────────────────────────────────────────────────────
│       │   📁 Writers
│       │   └── 📄 ObjectSetWriterImpl.cs (12.22 KB, 2025-03-11 14:57:20)
│       │       ┌──────────────────────────────────────────────────────────────────────
│       │       │ FILE CONTENT: ObjectSetWriterImpl.cs
│       │       ├──────────────────────────────────────────────────────────────────────
│       │       │    1 │ ﻿using Microsoft.Extensions.Logging;
│       │       │    2 │ using System;
│       │       │    3 │ using System.Collections.Generic;
│       │       │    4 │ using System.Linq;
│       │       │    5 │ using System.Threading.Tasks;
│       │       │    6 │ using System.Xml.Linq;
│       │       │    7 │ using test.Core.Domain;
│       │       │    8 │ using test.Core.Domain.ObjectSet;
│       │       │    9 │ using test.Core.Interfaces;
│       │       │   10 │ 
│       │       │   11 │ namespace test.Application.Services.Writers
│       │       │   12 │ {
│       │       │   13 │     /// <summary>
│       │       │   14 │     /// Implementation of the ObjectSet writer
│       │       │   15 │     /// </summary>
│       │       │   16 │     public class ObjectSetWriterImpl : IObjectSetWriter
│       │       │   17 │     {
│       │       │   18 │         private readonly ILogger<ObjectSetWriterImpl> _logger;
│       │       │   19 │ 
│       │       │   20 │         /// <summary>
│       │       │   21 │         /// Creates a new ObjectSet writer
│       │       │   22 │         /// </summary>
│       │       │   23 │         /// <param name="logger">Logger</param>
│       │       │   24 │         public ObjectSetWriterImpl(ILogger<ObjectSetWriterImpl> logger)
│       │       │   25 │         {
│       │       │   26 │             _logger = logger ?? throw new ArgumentNullException(nameof(logger));
│       │       │   27 │         }
│       │       │   28 │ 
│       │       │   29 │         /// <inheritdoc/>
│       │       │   30 │         public async Task<XDocument> WriteAsync(IEnumerable<Controller> controllers, ObjectSetWriteOptions options = null)
│       │       │   31 │         {
│       │       │   32 │             options ??= new ObjectSetWriteOptions();
│       │       │   33 │ 
│       │       │   34 │             try
│       │       │   35 │             {
│       │       │   36 │                 // Create root element
│       │       │   37 │                 var root = new XElement("ObjectSet");
│       │       │   38 │                 var doc = new XDocument(new XDeclaration("1.0", "utf-8", null), root);
│       │       │   39 │ 
│       │       │   40 │                 // Add meta information if provided
│       │       │   41 │                 if (options.MetaInformation != null)
│       │       │   42 │                 {
│       │       │   43 │                     root.Add(CreateMetaInformationElement(options.MetaInformation));
│       │       │   44 │                 }
│       │       │   45 │ 
│       │       │   46 │                 // Add type definitions if provided
│       │       │   47 │                 if (options.TypeDefinitions != null && options.TypeDefinitions.Any())
│       │       │   48 │                 {
│       │       │   49 │                     root.Add(CreateTypesElement(options.TypeDefinitions));
│       │       │   50 │                 }
│       │       │   51 │ 
│       │       │   52 │                 // Add exported objects from controllers
│       │       │   53 │                 root.Add(CreateExportedObjectsElement(controllers, options.IncludeByteCode));
│       │       │   54 │ 
│       │       │   55 │                 return doc;
│       │       │   56 │             }
│       │       │   57 │             catch (Exception ex)
│       │       │   58 │             {
│       │       │   59 │                 _logger.LogError(ex, "Error creating ObjectSet XML");
│       │       │   60 │                 throw;
│       │       │   61 │             }
│       │       │   62 │         }
│       │       │   63 │ 
│       │       │   64 │         /// <summary>
│       │       │   65 │         /// Creates the meta information element
│       │       │   66 │         /// </summary>
│       │       │   67 │         private XElement CreateMetaInformationElement(MetaInformation metaInfo)
│       │       │   68 │         {
│       │       │   69 │             var element = new XElement("MetaInformation");
│       │       │   70 │ 
│       │       │   71 │             if (!string.IsNullOrEmpty(metaInfo.ExportMode))
│       │       │   72 │             {
│       │       │   73 │                 element.Add(new XElement("ExportMode", new XAttribute("Value", metaInfo.ExportMode)));
│       │       │   74 │             }
│       │       │   75 │ 
│       │       │   76 │             if (!string.IsNullOrEmpty(metaInfo.SemanticsFilter))
│       │       │   77 │             {
│       │       │   78 │                 element.Add(new XElement("SemanticsFilter", new XAttribute("Value", metaInfo.SemanticsFilter)));
│       │       │   79 │             }
│       │       │   80 │ 
│       │       │   81 │             if (!string.IsNullOrEmpty(metaInfo.RuntimeVersion))
│       │       │   82 │             {
│       │       │   83 │                 element.Add(new XElement("RuntimeVersion", new XAttribute("Value", metaInfo.RuntimeVersion)));
│       │       │   84 │             }
│       │       │   85 │ 
│       │       │   86 │             if (!string.IsNullOrEmpty(metaInfo.SourceVersion))
│       │       │   87 │             {
│       │       │   88 │                 element.Add(new XElement("SourceVersion", new XAttribute("Value", metaInfo.SourceVersion)));
│       │       │   89 │             }
│       │       │   90 │ 
│       │       │   91 │             if (!string.IsNullOrEmpty(metaInfo.ServerFullPath))
│       │       │   92 │             {
│       │       │   93 │                 element.Add(new XElement("ServerFullPath", new XAttribute("Value", metaInfo.ServerFullPath)));
│       │       │   94 │             }
│       │       │   95 │ 
│       │       │   96 │             return element;
│       │       │   97 │         }
│       │       │   98 │ 
│       │       │   99 │         /// <summary>
│       │       │  100 │         /// Creates the types element containing type definitions
│       │       │  101 │         /// </summary>
│       │       │  102 │         private XElement CreateTypesElement(IEnumerable<ObjectTypeDefinition> typeDefinitions)
│       │       │  103 │         {
│       │       │  104 │             var element = new XElement("Types");
│       │       │  105 │ 
│       │       │  106 │             foreach (var typeDef in typeDefinitions)
│       │       │  107 │             {
│       │       │  108 │                 var typeElement = new XElement("ObjectType",
│       │       │  109 │                     new XAttribute("Name", typeDef.Name ?? string.Empty));
│       │       │  110 │ 
│       │       │  111 │                 if (!string.IsNullOrEmpty(typeDef.DisplayName))
│       │       │  112 │                 {
│       │       │  113 │                     typeElement.Add(new XAttribute("DisplayName", typeDef.DisplayName));
│       │       │  114 │                 }
│       │       │  115 │ 
│       │       │  116 │                 if (!string.IsNullOrEmpty(typeDef.Description))
│       │       │  117 │                 {
│       │       │  118 │                     typeElement.Add(new XAttribute("Description", typeDef.Description));
│       │       │  119 │                 }
│       │       │  120 │ 
│       │       │  121 │                 // Add property tabs
│       │       │  122 │                 foreach (var tab in typeDef.PropertyTabs)
│       │       │  123 │                 {
│       │       │  124 │                     typeElement.Add(CreatePropertyTabElement(tab));
│       │       │  125 │                 }
│       │       │  126 │ 
│       │       │  127 │                 element.Add(typeElement);
│       │       │  128 │             }
│       │       │  129 │ 
│       │       │  130 │             return element;
│       │       │  131 │         }
│       │       │  132 │ 
│       │       │  133 │         /// <summary>
│       │       │  134 │         /// Creates a property tab element
│       │       │  135 │         /// </summary>
│       │       │  136 │         private XElement CreatePropertyTabElement(PropertyTab tab)
│       │       │  137 │         {
│       │       │  138 │             var element = new XElement("PropertyTab",
│       │       │  139 │                 new XAttribute("Name", tab.Name ?? string.Empty));
│       │       │  140 │ 
│       │       │  141 │             // Add property groups
│       │       │  142 │             foreach (var group in tab.PropertyGroups)
│       │       │  143 │             {
│       │       │  144 │                 element.Add(CreatePropertyGroupElement(group));
│       │       │  145 │             }
│       │       │  146 │ 
│       │       │  147 │             return element;
│       │       │  148 │         }
│       │       │  149 │ 
│       │       │  150 │         /// <summary>
│       │       │  151 │         /// Creates a property group element
│       │       │  152 │         /// </summary>
│       │       │  153 │         private XElement CreatePropertyGroupElement(PropertyGroup group)
│       │       │  154 │         {
│       │       │  155 │             var element = new XElement("PropertyGroup",
│       │       │  156 │                 new XAttribute("Name", group.Name ?? string.Empty));
│       │       │  157 │ 
│       │       │  158 │             // Add parameters
│       │       │  159 │             foreach (var param in group.Parameters)
│       │       │  160 │             {
│       │       │  161 │                 element.Add(CreateParameterElement(param));
│       │       │  162 │             }
│       │       │  163 │ 
│       │       │  164 │             // Add variables
│       │       │  165 │             foreach (var variable in group.Variables)
│       │       │  166 │             {
│       │       │  167 │                 element.Add(CreateVariableElement(variable));
│       │       │  168 │             }
│       │       │  169 │ 
│       │       │  170 │             return element;
│       │       │  171 │         }
│       │       │  172 │ 
│       │       │  173 │         /// <summary>
│       │       │  174 │         /// Creates a parameter element
│       │       │  175 │         /// </summary>
│       │       │  176 │         private XElement CreateParameterElement(Parameter param)
│       │       │  177 │         {
│       │       │  178 │             var element = new XElement("Parameter",
│       │       │  179 │                 new XAttribute("Name", param.Name ?? string.Empty));
│       │       │  180 │ 
│       │       │  181 │             if (!string.IsNullOrEmpty(param.DisplayName))
│       │       │  182 │             {
│       │       │  183 │                 element.Add(new XAttribute("DisplayName", param.DisplayName));
│       │       │  184 │             }
│       │       │  185 │ 
│       │       │  186 │             if (!string.IsNullOrEmpty(param.Description))
│       │       │  187 │             {
│       │       │  188 │                 element.Add(new XAttribute("Description", param.Description));
│       │       │  189 │             }
│       │       │  190 │ 
│       │       │  191 │             if (param.Type != null)
│       │       │  192 │             {
│       │       │  193 │                 element.Add(new XElement("Type",
│       │       │  194 │                     new XAttribute("Value", param.Type.Value ?? string.Empty)));
│       │       │  195 │             }
│       │       │  196 │ 
│       │       │  197 │             if (!string.IsNullOrEmpty(param.Unit))
│       │       │  198 │             {
│       │       │  199 │                 element.Add(new XElement("Unit",
│       │       │  200 │                     new XAttribute("Value", param.Unit)));
│       │       │  201 │             }
│       │       │  202 │ 
│       │       │  203 │             if (!string.IsNullOrEmpty(param.InitValue) || !string.IsNullOrEmpty(param.FileContents))
│       │       │  204 │             {
│       │       │  205 │                 var initValueElement = new XElement("InitValue");
│       │       │  206 │ 
│       │       │  207 │                 if (!string.IsNullOrEmpty(param.InitValue))
│       │       │  208 │                 {
│       │       │  209 │                     initValueElement.Add(new XAttribute("Value", param.InitValue));
│       │       │  210 │                 }
│       │       │  211 │ 
│       │       │  212 │                 if (!string.IsNullOrEmpty(param.FileContents))
│       │       │  213 │                 {
│       │       │  214 │                     initValueElement.Add(new XElement("FileContents", param.FileContents));
│       │       │  215 │                 }
│       │       │  216 │ 
│       │       │  217 │                 element.Add(initValueElement);
│       │       │  218 │             }
│       │       │  219 │ 
│       │       │  220 │             return element;
│       │       │  221 │         }
│       │       │  222 │ 
│       │       │  223 │         /// <summary>
│       │       │  224 │         /// Creates a variable element
│       │       │  225 │         /// </summary>
│       │       │  226 │         private XElement CreateVariableElement(Variable variable)
│       │       │  227 │         {
│       │       │  228 │             var element = new XElement("Variable",
│       │       │  229 │                 new XAttribute("Name", variable.Name ?? string.Empty));
│       │       │  230 │ 
│       │       │  231 │             if (!string.IsNullOrEmpty(variable.DisplayName))
│       │       │  232 │             {
│       │       │  233 │                 element.Add(new XAttribute("DisplayName", variable.DisplayName));
│       │       │  234 │             }
│       │       │  235 │ 
│       │       │  236 │             if (!string.IsNullOrEmpty(variable.Description))
│       │       │  237 │             {
│       │       │  238 │                 element.Add(new XAttribute("Description", variable.Description));
│       │       │  239 │             }
│       │       │  240 │ 
│       │       │  241 │             if (variable.Type != null)
│       │       │  242 │             {
│       │       │  243 │                 element.Add(new XElement("Type",
│       │       │  244 │                     new XAttribute("Value", variable.Type.Value ?? string.Empty)));
│       │       │  245 │             }
│       │       │  246 │ 
│       │       │  247 │             if (!string.IsNullOrEmpty(variable.Unit))
│       │       │  248 │             {
│       │       │  249 │                 element.Add(new XElement("Unit",
│       │       │  250 │                     new XAttribute("Value", variable.Unit)));
│       │       │  251 │             }
│       │       │  252 │ 
│       │       │  253 │             if (variable.Runtime != null)
│       │       │  254 │             {
│       │       │  255 │                 element.Add(CreateRuntimeElement(variable.Runtime));
│       │       │  256 │             }
│       │       │  257 │ 
│       │       │  258 │             return element;
│       │       │  259 │         }
│       │       │  260 │ 
│       │       │  261 │         /// <summary>
│       │       │  262 │         /// Creates a runtime element
│       │       │  263 │         /// </summary>
│       │       │  264 │         private XElement CreateRuntimeElement(Runtime runtime)
│       │       │  265 │         {
│       │       │  266 │             var element = new XElement("Runtime");
│       │       │  267 │ 
│       │       │  268 │             element.Add(new XElement("ReadOnly",
│       │       │  269 │                 new XAttribute("Value", runtime.ReadOnly ? "1" : "0")));
│       │       │  270 │ 
│       │       │  271 │             if (!string.IsNullOrEmpty(runtime.RetainLevel))
│       │       │  272 │             {
│       │       │  273 │                 element.Add(new XElement("RetainLevel",
│       │       │  274 │                     new XAttribute("Value", runtime.RetainLevel)));
│       │       │  275 │             }
│       │       │  276 │ 
│       │       │  277 │             element.Add(new XElement("Forceable",
│       │       │  278 │                 new XAttribute("Value", runtime.Forceable ? "1" : "0")));
│       │       │  279 │ 
│       │       │  280 │             if (!string.IsNullOrEmpty(runtime.InitValue))
│       │       │  281 │             {
│       │       │  282 │                 element.Add(new XElement("InitValue", runtime.InitValue));
│       │       │  283 │             }
│       │       │  284 │ 
│       │       │  285 │             return element;
│       │       │  286 │         }
│       │       │  287 │ 
│       │       │  288 │         /// <summary>
│       │       │  289 │         /// Creates the exported objects element from controllers
│       │       │  290 │         /// </summary>
│       │       │  291 │         private XElement CreateExportedObjectsElement(IEnumerable<Controller> controllers, bool includeByteCode)
│       │       │  292 │         {
│       │       │  293 │             var element = new XElement("ExportedObjects");
│       │       │  294 │ 
│       │       │  295 │             foreach (var controller in controllers)
│       │       │  296 │             {
│       │       │  297 │                 var controllerElement = new XElement("OI",
│       │       │  298 │                     new XAttribute("NAME", controller.Name),
│       │       │  299 │                     new XAttribute("TYPE", "InfinityInfinetCtlr"));
│       │       │  300 │ 
│       │       │  301 │                 // Add controller properties
│       │       │  302 │                 foreach (var prop in controller.Properties)
│       │       │  303 │                 {
│       │       │  304 │                     controllerElement.Add(new XElement("PI",
│       │       │  305 │                         new XAttribute("Name", prop.Key),
│       │       │  306 │                         new XAttribute("Value", prop.Value ?? string.Empty)));
│       │       │  307 │                 }
│       │       │  308 │ 
│       │       │  309 │                 // Add controller objects
│       │       │  310 │                 foreach (var obj in controller.Objects)
│       │       │  311 │                 {
│       │       │  312 │                     controllerElement.Add(CreateObjectElement(obj, includeByteCode));
│       │       │  313 │                 }
│       │       │  314 │ 
│       │       │  315 │                 element.Add(controllerElement);
│       │       │  316 │             }
│       │       │  317 │ 
│       │       │  318 │             return element;
│       │       │  319 │         }
│       │       │  320 │ 
│       │       │  321 │         /// <summary>
│       │       │  322 │         /// Creates an object element
│       │       │  323 │         /// </summary>
│       │       │  324 │         private XElement CreateObjectElement(ControllerObject obj, bool includeByteCode)
│       │       │  325 │         {
│       │       │  326 │             var element = new XElement("OI",
│       │       │  327 │                 new XAttribute("NAME", obj.Name),
│       │       │  328 │                 new XAttribute("TYPE", obj.Type));
│       │       │  329 │ 
│       │       │  330 │             if (!string.IsNullOrEmpty(obj.Alias))
│       │       │  331 │             {
│       │       │  332 │                 element.Add(new XElement("PI",
│       │       │  333 │                     new XAttribute("Name", "Alias"),
│       │       │  334 │                     new XAttribute("Value", obj.Alias)));
│       │       │  335 │             }
│       │       │  336 │ 
│       │       │  337 │             // Add value if not bytecode or if including bytecode
│       │       │  338 │             if (!obj.HasByteCode || includeByteCode)
│       │       │  339 │             {
│       │       │  340 │                 element.Add(new XElement("PI",
│       │       │  341 │                     new XAttribute("Name", "Value"),
│       │       │  342 │                     new XAttribute("Value", obj.Value ?? string.Empty)));
│       │       │  343 │             }
│       │       │  344 │ 
│       │       │  345 │             // Add other properties
│       │       │  346 │             foreach (var prop in obj.Properties)
│       │       │  347 │             {
│       │       │  348 │                 // Skip Alias since we already added it
│       │       │  349 │                 if (prop.Key == "Alias") continue;
│       │       │  350 │ 
│       │       │  351 │                 element.Add(new XElement("PI",
│       │       │  352 │                     new XAttribute("Name", prop.Key),
│       │       │  353 │                     new XAttribute("Value", prop.Value ?? string.Empty)));
│       │       │  354 │             }
│       │       │  355 │ 
│       │       │  356 │             // Add child objects
│       │       │  357 │             foreach (var child in obj.Children)
│       │       │  358 │             {
│       │       │  359 │                 element.Add(CreateObjectElement(child, includeByteCode));
│       │       │  360 │             }
│       │       │  361 │ 
│       │       │  362 │             return element;
│       │       │  363 │         }
│       │       │  364 │     }
│       │       │  365 │ }
│       │       └──────────────────────────────────────────────────────────────────────
│       ├── 📄 ComparisonService.cs (21.68 KB, 2025-03-11 13:29:45)
│       │   ┌──────────────────────────────────────────────────────────────────────
│       │   │ FILE CONTENT: ComparisonService.cs
│       │   ├──────────────────────────────────────────────────────────────────────
│       │   │    1 │ ﻿using Microsoft.Extensions.Logging;
│       │   │    2 │ using System;
│       │   │    3 │ using System.Collections.Generic;
│       │   │    4 │ using System.Linq;
│       │   │    5 │ using System.Threading.Tasks;
│       │   │    6 │ using System.Xml.Linq;
│       │   │    7 │ using test.Core.Domain;
│       │   │    8 │ using test.Core.Dto;
│       │   │    9 │ using test.Core.Exceptions;
│       │   │   10 │ using test.Core.Interfaces;
│       │   │   11 │ using test.Data.Mapping;
│       │   │   12 │ using test.Infrastructure.Logging;
│       │   │   13 │ 
│       │   │   14 │ namespace test.Application.Services
│       │   │   15 │ {
│       │   │   16 │     /// <summary>
│       │   │   17 │     /// Implementation of the comparison service for controller data
│       │   │   18 │     /// </summary>
│       │   │   19 │     public class ComparisonService : IComparisonService
│       │   │   20 │     {
│       │   │   21 │         private readonly IErrorHandler _errorHandler;
│       │   │   22 │         private readonly ILogger<ComparisonService> _logger;
│       │   │   23 │ 
│       │   │   24 │         /// <summary>
│       │   │   25 │         /// Creates a new comparison service
│       │   │   26 │         /// </summary>
│       │   │   27 │         /// <param name="errorHandler">The error handler</param>
│       │   │   28 │         /// <param name="logger">The logger</param>
│       │   │   29 │         public ComparisonService(IErrorHandler errorHandler, ILogger<ComparisonService> logger)
│       │   │   30 │         {
│       │   │   31 │             _errorHandler = errorHandler ?? throw new ArgumentNullException(nameof(errorHandler));
│       │   │   32 │             _logger = logger ?? throw new ArgumentNullException(nameof(logger));
│       │   │   33 │         }
│       │   │   34 │ 
│       │   │   35 │         /// <inheritdoc/>
│       │   │   36 │         public async Task<IEnumerable<ComparisonResult>> CompareWithXmlAsync(string xmlContent, IEnumerable<Controller> controllers)
│       │   │   37 │         {
│       │   │   38 │             return await _errorHandler.WithErrorHandlingAsync(async () =>
│       │   │   39 │             {
│       │   │   40 │                 if (string.IsNullOrWhiteSpace(xmlContent))
│       │   │   41 │                     throw new ArgumentException("XML content cannot be empty", nameof(xmlContent));
│       │   │   42 │ 
│       │   │   43 │                 if (controllers == null || !controllers.Any())
│       │   │   44 │                     throw new ArgumentException("Controllers collection cannot be empty", nameof(controllers));
│       │   │   45 │ 
│       │   │   46 │                 _logger.LogInformation("Comparing {ControllerCount} controllers with XML content", controllers.Count());
│       │   │   47 │ 
│       │   │   48 │                 var comparisons = new List<ComparisonResult>();
│       │   │   49 │                 var doc = XDocument.Parse(xmlContent);
│       │   │   50 │ 
│       │   │   51 │                 // Find the Values folder in XML
│       │   │   52 │                 var valuesFolder = doc.Descendants("OI")
│       │   │   53 │                     .Where(oi => oi.Attribute("NAME")?.Value == "Values")
│       │   │   54 │                     .FirstOrDefault();
│       │   │   55 │ 
│       │   │   56 │                 if (valuesFolder == null)
│       │   │   57 │                 {
│       │   │   58 │                     _logger.LogWarning("No Values folder found in XML content");
│       │   │   59 │                     return Enumerable.Empty<ComparisonResult>();
│       │   │   60 │                 }
│       │   │   61 │ 
│       │   │   62 │                 // Track all values found in XML
│       │   │   63 │                 var xmlValues = new Dictionary<string, (string Value, string Address)>(StringComparer.OrdinalIgnoreCase);
│       │   │   64 │ 
│       │   │   65 │                 // Process all analog and digital values
│       │   │   66 │                 foreach (var valueObj in valuesFolder.Descendants("OI"))
│       │   │   67 │                 {
│       │   │   68 │                     var name = valueObj.Attribute("NAME")?.Value;
│       │   │   69 │                     if (string.IsNullOrEmpty(name)) continue;
│       │   │   70 │ 
│       │   │   71 │                     var address = valueObj.Descendants("PI")
│       │   │   72 │                         .FirstOrDefault(pi => pi.Attribute("Name")?.Value == "ForeignAddress")?
│       │   │   73 │                         .Attribute("Value")?.Value ?? "";
│       │   │   74 │ 
│       │   │   75 │                     var value = valueObj.Descendants("PI")
│       │   │   76 │                         .FirstOrDefault(pi => pi.Attribute("Name")?.Value == "Value")?
│       │   │   77 │                         .Attribute("Value")?.Value ?? "";
│       │   │   78 │ 
│       │   │   79 │                     if (!string.IsNullOrEmpty(value))
│       │   │   80 │                     {
│       │   │   81 │                         xmlValues[name] = (value, address);
│       │   │   82 │                     }
│       │   │   83 │                 }
│       │   │   84 │ 
│       │   │   85 │                 // Compare controllers with XML values
│       │   │   86 │                 foreach (var controller in controllers)
│       │   │   87 │                 {
│       │   │   88 │                     CompareControllerWithXml(controller, xmlValues, comparisons);
│       │   │   89 │                 }
│       │   │   90 │ 
│       │   │   91 │                 _logger.LogInformation("Comparison complete. Found {ComparisonCount} value comparisons", comparisons.Count);
│       │   │   92 │                 return comparisons;
│       │   │   93 │             }, "CompareWithXml");
│       │   │   94 │         }
│       │   │   95 │ 
│       │   │   96 │         /// <inheritdoc/>
│       │   │   97 │         public async Task<string> GenerateModifiedXmlAsync(string originalXmlContent, Controller controller, string targetName = null)
│       │   │   98 │         {
│       │   │   99 │             return await _errorHandler.WithErrorHandlingAsync(async () =>
│       │   │  100 │             {
│       │   │  101 │                 if (string.IsNullOrWhiteSpace(originalXmlContent))
│       │   │  102 │                     throw new ArgumentException("Original XML content cannot be empty", nameof(originalXmlContent));
│       │   │  103 │ 
│       │   │  104 │                 if (controller == null)
│       │   │  105 │                     throw new ArgumentNullException(nameof(controller));
│       │   │  106 │ 
│       │   │  107 │                 _logger.LogInformation("Generating modified XML for controller {ControllerName}", controller.Name);
│       │   │  108 │ 
│       │   │  109 │                 // Parse the XML document
│       │   │  110 │                 var doc = XDocument.Parse(originalXmlContent);
│       │   │  111 │ 
│       │   │  112 │                 // Find the controller name from ExportedObjects section
│       │   │  113 │                 var exportedObject = doc.Descendants("ExportedObjects")
│       │   │  114 │                     .FirstOrDefault()
│       │   │  115 │                     ?.Elements("OI")
│       │   │  116 │                     .FirstOrDefault();
│       │   │  117 │ 
│       │   │  118 │                 var originalControllerName = exportedObject?.Attribute("NAME")?.Value;
│       │   │  119 │ 
│       │   │  120 │                 // Use the specified target name or the controller name
│       │   │  121 │                 var newName = targetName ?? controller.Name;
│       │   │  122 │ 
│       │   │  123 │                 if (!string.IsNullOrEmpty(originalControllerName) && originalControllerName != newName)
│       │   │  124 │                 {
│       │   │  125 │                     // Replace all instances of the original controller name with the new one
│       │   │  126 │                     originalXmlContent = originalXmlContent.Replace(originalControllerName, newName);
│       │   │  127 │                     // Re-parse the modified content
│       │   │  128 │                     doc = XDocument.Parse(originalXmlContent);
│       │   │  129 │                 }
│       │   │  130 │ 
│       │   │  131 │                 // Find the Values folder
│       │   │  132 │                 var valuesFolder = doc.Descendants("OI")
│       │   │  133 │                     .Where(oi => oi.Attribute("NAME")?.Value == "Values")
│       │   │  134 │                     .FirstOrDefault();
│       │   │  135 │ 
│       │   │  136 │                 if (valuesFolder != null)
│       │   │  137 │                 {
│       │   │  138 │                     // Extract controller values into a dictionary for efficient lookup
│       │   │  139 │                     var controllerValues = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
│       │   │  140 │                     ExtractControllerValues(controller.Objects, controllerValues);
│       │   │  141 │ 
│       │   │  142 │                     // Update XML values
│       │   │  143 │                     foreach (var valueObj in valuesFolder.Descendants("OI"))
│       │   │  144 │                     {
│       │   │  145 │                         var name = valueObj.Attribute("NAME")?.Value;
│       │   │  146 │                         if (string.IsNullOrEmpty(name)) continue;
│       │   │  147 │ 
│       │   │  148 │                         // Check if we have a value for this name in the controller
│       │   │  149 │                         if (controllerValues.TryGetValue(name, out var newValue))
│       │   │  150 │                         {
│       │   │  151 │                             var valueElement = valueObj.Descendants("PI")
│       │   │  152 │                                 .FirstOrDefault(pi => pi.Attribute("Name")?.Value == "Value");
│       │   │  153 │ 
│       │   │  154 │                             if (valueElement != null)
│       │   │  155 │                             {
│       │   │  156 │                                 valueElement.SetAttributeValue("Value", newValue);
│       │   │  157 │                             }
│       │   │  158 │                         }
│       │   │  159 │                     }
│       │   │  160 │                 }
│       │   │  161 │ 
│       │   │  162 │                 _logger.LogInformation("XML modification complete for controller {ControllerName}", controller.Name);
│       │   │  163 │                 return doc.ToString();
│       │   │  164 │             }, "GenerateModifiedXml");
│       │   │  165 │         }
│       │   │  166 │ 
│       │   │  167 │         /// <inheritdoc/>
│       │   │  168 │         public async Task<IEnumerable<ControllerGroup>> GroupControllersAsync(IEnumerable<Controller> controllers, GroupingOptions options = null)
│       │   │  169 │         {
│       │   │  170 │             return await _errorHandler.WithErrorHandlingAsync(async () =>
│       │   │  171 │             {
│       │   │  172 │                 if (controllers == null || !controllers.Any())
│       │   │  173 │                     throw new ArgumentException("Controllers collection cannot be empty", nameof(controllers));
│       │   │  174 │ 
│       │   │  175 │                 options ??= new GroupingOptions();
│       │   │  176 │                 _logger.LogInformation("Grouping {ControllerCount} controllers", controllers.Count());
│       │   │  177 │ 
│       │   │  178 │                 var groups = new List<ControllerGroup>();
│       │   │  179 │ 
│       │   │  180 │                 // Process each controller
│       │   │  181 │                 foreach (var controller in controllers)
│       │   │  182 │                 {
│       │   │  183 │                     // Compute a signature for the controller
│       │   │  184 │                     var signature = ComputeControllerSignature(controller, options);
│       │   │  185 │ 
│       │   │  186 │                     // Look for an existing group with the same signature
│       │   │  187 │                     var group = groups.FirstOrDefault(g => g.GroupIdentifier == signature);
│       │   │  188 │ 
│       │   │  189 │                     if (group == null)
│       │   │  190 │                     {
│       │   │  191 │                         // Create a new group
│       │   │  192 │                         group = new ControllerGroup(signature);
│       │   │  193 │ 
│       │   │  194 │                         // Add controller name to the list
│       │   │  195 │                         group.AddControllerName(controller.Name);
│       │   │  196 │ 
│       │   │  197 │                         // Extract values from the controller's objects
│       │   │  198 │                         ExtractControllerValuesWithProcessing(
│       │   │  199 │                             controller.Objects,
│       │   │  200 │                             group.OriginalValues,
│       │   │  201 │                             group.ProcessedValues,
│       │   │  202 │                             group.NameMapping,
│       │   │  203 │                             options.ReplacementRules);
│       │   │  204 │ 
│       │   │  205 │                         groups.Add(group);
│       │   │  206 │                     }
│       │   │  207 │                     else
│       │   │  208 │                     {
│       │   │  209 │                         // Add the controller to the existing group
│       │   │  210 │                         group.AddControllerName(controller.Name);
│       │   │  211 │                     }
│       │   │  212 │                 }
│       │   │  213 │ 
│       │   │  214 │                 _logger.LogInformation("Controller grouping complete. Found {GroupCount} distinct groups", groups.Count);
│       │   │  215 │                 return groups;
│       │   │  216 │             }, "GroupControllers");
│       │   │  217 │         }
│       │   │  218 │ 
│       │   │  219 │         /// <inheritdoc/>
│       │   │  220 │         public async Task<IEnumerable<SimilarityResultDto>> FindSimilarControllersAsync(
│       │   │  221 │             string xmlContent,
│       │   │  222 │             IEnumerable<Controller> controllers,
│       │   │  223 │             GroupingOptions options = null)
│       │   │  224 │         {
│       │   │  225 │             return await _errorHandler.WithErrorHandlingAsync(async () =>
│       │   │  226 │             {
│       │   │  227 │                 if (string.IsNullOrWhiteSpace(xmlContent))
│       │   │  228 │                     throw new ArgumentException("XML content cannot be empty", nameof(xmlContent));
│       │   │  229 │ 
│       │   │  230 │                 if (controllers == null || !controllers.Any())
│       │   │  231 │                     throw new ArgumentException("Controllers collection cannot be empty", nameof(controllers));
│       │   │  232 │ 
│       │   │  233 │                 options ??= new GroupingOptions();
│       │   │  234 │                 _logger.LogInformation("Finding similar controllers in XML content for {ControllerCount} controllers",
│       │   │  235 │                     controllers.Count());
│       │   │  236 │ 
│       │   │  237 │                 // Extract values from XML
│       │   │  238 │                 var xmlValues = ExtractXmlValues(xmlContent);
│       │   │  239 │                 _logger.LogInformation("Extracted {ValueCount} values from XML content", xmlValues.Count);
│       │   │  240 │ 
│       │   │  241 │                 // Group controllers
│       │   │  242 │                 var controllerGroups = await GroupControllersAsync(controllers, options);
│       │   │  243 │                 _logger.LogInformation("Created {GroupCount} controller groups", controllerGroups.Count());
│       │   │  244 │ 
│       │   │  245 │                 var results = new List<SimilarityResultDto>();
│       │   │  246 │ 
│       │   │  247 │                 // Calculate similarity for each group
│       │   │  248 │                 foreach (var group in controllerGroups)
│       │   │  249 │                 {
│       │   │  250 │                     var similarity = CalculateSimilarity(group.ProcessedValues, xmlValues);
│       │   │  251 │ 
│       │   │  252 │                     // Create similarity result
│       │   │  253 │                     var result = SimilarityResultMapper.FromControllerGroup(group, similarity);
│       │   │  254 │                     results.Add(result);
│       │   │  255 │                 }
│       │   │  256 │ 
│       │   │  257 │                 // Sort by similarity score and apply threshold
│       │   │  258 │                 var sortedResults = results
│       │   │  259 │                     .OrderByDescending(r => r.SimilarityScore)
│       │   │  260 │                     .ToList();
│       │   │  261 │ 
│       │   │  262 │                 if (!options.ReturnBestMatchesRegardless)
│       │   │  263 │                 {
│       │   │  264 │                     sortedResults = sortedResults
│       │   │  265 │                         .Where(r => r.SimilarityScore >= options.MinimumSimilarityThreshold)
│       │   │  266 │                         .ToList();
│       │   │  267 │                 }
│       │   │  268 │ 
│       │   │  269 │                 // Limit to requested number of groups
│       │   │  270 │                 if (options.NumberOfGroupsToMatch > 0 && sortedResults.Count > options.NumberOfGroupsToMatch)
│       │   │  271 │                 {
│       │   │  272 │                     sortedResults = sortedResults.Take(options.NumberOfGroupsToMatch).ToList();
│       │   │  273 │                 }
│       │   │  274 │ 
│       │   │  275 │                 _logger.LogInformation("Found {ResultCount} similar controller groups", sortedResults.Count);
│       │   │  276 │                 return sortedResults;
│       │   │  277 │             }, "FindSimilarControllers");
│       │   │  278 │         }
│       │   │  279 │ 
│       │   │  280 │         #region Helper Methods
│       │   │  281 │ 
│       │   │  282 │         /// <summary>
│       │   │  283 │         /// Compares a controller with XML values and adds results to the comparisons list
│       │   │  284 │         /// </summary>
│       │   │  285 │         private void CompareControllerWithXml(
│       │   │  286 │             Controller controller,
│       │   │  287 │             Dictionary<string, (string Value, string Address)> xmlValues,
│       │   │  288 │             List<ComparisonResult> comparisons)
│       │   │  289 │         {
│       │   │  290 │             // Process all objects in the controller
│       │   │  291 │             foreach (var obj in controller.Objects)
│       │   │  292 │             {
│       │   │  293 │                 CompareObjectWithXml(obj, xmlValues, comparisons);
│       │   │  294 │             }
│       │   │  295 │         }
│       │   │  296 │ 
│       │   │  297 │         /// <summary>
│       │   │  298 │         /// Compares an object with XML values and adds results to the comparisons list
│       │   │  299 │         /// </summary>
│       │   │  300 │         private void CompareObjectWithXml(
│       │   │  301 │             ControllerObject obj,
│       │   │  302 │             Dictionary<string, (string Value, string Address)> xmlValues,
│       │   │  303 │             List<ComparisonResult> comparisons)
│       │   │  304 │         {
│       │   │  305 │             if (!string.IsNullOrEmpty(obj.Value))
│       │   │  306 │             {
│       │   │  307 │                 var xmlData = xmlValues.TryGetValue(obj.Name, out var data) ? data : (null, null);
│       │   │  308 │ 
│       │   │  309 │                 comparisons.Add(new ComparisonResult
│       │   │  310 │                 {
│       │   │  311 │                     Name = obj.Name,
│       │   │  312 │                     ControllerValue = obj.Value,
│       │   │  313 │                     XmlValue = xmlData.Value,
│       │   │  314 │                     XmlAddress = xmlData.Address,
│       │   │  315 │                     IsMatch = obj.Value == xmlData.Value
│       │   │  316 │                 });
│       │   │  317 │             }
│       │   │  318 │ 
│       │   │  319 │             // Process children recursively
│       │   │  320 │             foreach (var child in obj.Children)
│       │   │  321 │             {
│       │   │  322 │                 CompareObjectWithXml(child, xmlValues, comparisons);
│       │   │  323 │             }
│       │   │  324 │         }
│       │   │  325 │ 
│       │   │  326 │         /// <summary>
│       │   │  327 │         /// Extracts values from controller objects
│       │   │  328 │         /// </summary>
│       │   │  329 │         private void ExtractControllerValues(IEnumerable<ControllerObject> objects, Dictionary<string, string> values)
│       │   │  330 │         {
│       │   │  331 │             foreach (var obj in objects)
│       │   │  332 │             {
│       │   │  333 │                 if (!string.IsNullOrEmpty(obj.Value))
│       │   │  334 │                 {
│       │   │  335 │                     values[obj.Name] = obj.Value;
│       │   │  336 │                 }
│       │   │  337 │ 
│       │   │  338 │                 // Process children recursively
│       │   │  339 │                 ExtractControllerValues(obj.Children, values);
│       │   │  340 │             }
│       │   │  341 │         }
│       │   │  342 │ 
│       │   │  343 │         /// <summary>
│       │   │  344 │         /// Extracts values from controller objects with name processing
│       │   │  345 │         /// </summary>
│       │   │  346 │         private void ExtractControllerValuesWithProcessing(
│       │   │  347 │             IEnumerable<ControllerObject> objects,
│       │   │  348 │             IDictionary<string, string> originalValues,
│       │   │  349 │             IDictionary<string, string> processedValues,
│       │   │  350 │             IDictionary<string, string> nameMapping,
│       │   │  351 │             IEnumerable<ReplacementRule> replacementRules)
│       │   │  352 │         {
│       │   │  353 │             foreach (var obj in objects)
│       │   │  354 │             {
│       │   │  355 │                 if (!string.IsNullOrEmpty(obj.Value))
│       │   │  356 │                 {
│       │   │  357 │                     // Store original value
│       │   │  358 │                     originalValues[obj.Name] = obj.Value;
│       │   │  359 │ 
│       │   │  360 │                     // Process name
│       │   │  361 │                     var processedName = ProcessName(obj.Name, replacementRules);
│       │   │  362 │                     nameMapping[obj.Name] = processedName;
│       │   │  363 │ 
│       │   │  364 │                     // Store processed value
│       │   │  365 │                     processedValues[processedName] = obj.Value;
│       │   │  366 │                 }
│       │   │  367 │ 
│       │   │  368 │                 // Process children recursively
│       │   │  369 │                 if (obj.Children.Any())
│       │   │  370 │                 {
│       │   │  371 │                     ExtractControllerValuesWithProcessing(
│       │   │  372 │                         obj.Children,
│       │   │  373 │                         originalValues,
│       │   │  374 │                         processedValues,
│       │   │  375 │                         nameMapping,
│       │   │  376 │                         replacementRules);
│       │   │  377 │                 }
│       │   │  378 │             }
│       │   │  379 │         }
│       │   │  380 │ 
│       │   │  381 │         /// <summary>
│       │   │  382 │         /// Processes a name using replacement rules
│       │   │  383 │         /// </summary>
│       │   │  384 │         private string ProcessName(string name, IEnumerable<ReplacementRule> replacementRules)
│       │   │  385 │         {
│       │   │  386 │             if (string.IsNullOrEmpty(name) || replacementRules == null || !replacementRules.Any())
│       │   │  387 │                 return name;
│       │   │  388 │ 
│       │   │  389 │             var result = name;
│       │   │  390 │ 
│       │   │  391 │             // Apply prefix rules first
│       │   │  392 │             foreach (var rule in replacementRules.Where(r => r.IsPrefix).OrderByDescending(r => r.Priority))
│       │   │  393 │             {
│       │   │  394 │                 if (result.StartsWith(rule.Pattern, StringComparison.OrdinalIgnoreCase))
│       │   │  395 │                 {
│       │   │  396 │                     result = rule.Replacement + result.Substring(rule.Pattern.Length);
│       │   │  397 │                     break; // Only apply one prefix rule
│       │   │  398 │                 }
│       │   │  399 │             }
│       │   │  400 │ 
│       │   │  401 │             // Then apply suffix rules
│       │   │  402 │             foreach (var rule in replacementRules.Where(r => !r.IsPrefix).OrderByDescending(r => r.Priority))
│       │   │  403 │             {
│       │   │  404 │                 if (result.EndsWith(rule.Pattern, StringComparison.OrdinalIgnoreCase))
│       │   │  405 │                 {
│       │   │  406 │                     result = result.Substring(0, result.Length - rule.Pattern.Length) + rule.Replacement;
│       │   │  407 │                     break; // Only apply one suffix rule
│       │   │  408 │                 }
│       │   │  409 │             }
│       │   │  410 │ 
│       │   │  411 │             return result;
│       │   │  412 │         }
│       │   │  413 │ 
│       │   │  414 │         /// <summary>
│       │   │  415 │         /// Extracts values from XML content
│       │   │  416 │         /// </summary>
│       │   │  417 │         private Dictionary<string, string> ExtractXmlValues(string xmlContent)
│       │   │  418 │         {
│       │   │  419 │             var values = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
│       │   │  420 │             var doc = XDocument.Parse(xmlContent);
│       │   │  421 │ 
│       │   │  422 │             try
│       │   │  423 │             {
│       │   │  424 │                 var exportedObjects = doc.Root?.Element("ExportedObjects");
│       │   │  425 │                 if (exportedObjects != null)
│       │   │  426 │                 {
│       │   │  427 │                     ProcessOIElements(exportedObjects, values);
│       │   │  428 │                 }
│       │   │  429 │             }
│       │   │  430 │             catch (Exception ex)
│       │   │  431 │             {
│       │   │  432 │                 _logger.LogError(ex, "Error extracting XML values");
│       │   │  433 │             }
│       │   │  434 │ 
│       │   │  435 │             return values;
│       │   │  436 │         }
│       │   │  437 │ 
│       │   │  438 │         /// <summary>
│       │   │  439 │         /// Processes OI elements recursively
│       │   │  440 │         /// </summary>
│       │   │  441 │         private void ProcessOIElements(XElement element, Dictionary<string, string> values)
│       │   │  442 │         {
│       │   │  443 │             foreach (var oi in element.Elements("OI"))
│       │   │  444 │             {
│       │   │  445 │                 var name = oi.Attribute("NAME")?.Value;
│       │   │  446 │                 var type = oi.Attribute("TYPE")?.Value;
│       │   │  447 │ 
│       │   │  448 │                 if (!string.IsNullOrEmpty(name))
│       │   │  449 │                 {
│       │   │  450 │                     bool shouldProcess = false;
│       │   │  451 │                     if (type != null)
│       │   │  452 │                     {
│       │   │  453 │                         var typeLower = type.ToLowerInvariant();
│       │   │  454 │                         shouldProcess = typeLower.Contains("value") ||
│       │   │  455 │                                         typeLower.Contains("input") ||
│       │   │  456 │                                         typeLower.Contains("output");
│       │   │  457 │                     }
│       │   │  458 │ 
│       │   │  459 │                     if (shouldProcess)
│       │   │  460 │                     {
│       │   │  461 │                         // Get the value
│       │   │  462 │                         var valuePi = oi.Elements("PI")
│       │   │  463 │                             .FirstOrDefault(pi => pi.Attribute("Name")?.Value?.Equals("Value", StringComparison.OrdinalIgnoreCase) == true);
│       │   │  464 │ 
│       │   │  465 │                         if (valuePi != null)
│       │   │  466 │                         {
│       │   │  467 │                             var value = valuePi.Attribute("Value")?.Value ?? "";
│       │   │  468 │                             values[name] = value;
│       │   │  469 │                         }
│       │   │  470 │                     }
│       │   │  471 │                 }
│       │   │  472 │ 
│       │   │  473 │                 // Process children recursively
│       │   │  474 │                 ProcessOIElements(oi, values);
│       │   │  475 │             }
│       │   │  476 │         }
│       │   │  477 │ 
│       │   │  478 │         /// <summary>
│       │   │  479 │         /// Computes a signature for a controller
│       │   │  480 │         /// </summary>
│       │   │  481 │         private string ComputeControllerSignature(Controller controller, GroupingOptions options)
│       │   │  482 │         {
│       │   │  483 │             // Get model
│       │   │  484 │             var model = controller.Model;
│       │   │  485 │ 
│       │   │  486 │             // Extract values
│       │   │  487 │             var values = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
│       │   │  488 │             ExtractControllerValues(controller.Objects, values);
│       │   │  489 │ 
│       │   │  490 │             // Hash based on objects types, names, and values
│       │   │  491 │             var objSigs = values.OrderBy(o => o.Key)
│       │   │  492 │                                 .Select(o => $"{o.Key}|{o.Value}");
│       │   │  493 │ 
│       │   │  494 │             return $"{model}_{string.Join("_", objSigs.Take(5))}";
│       │   │  495 │         }
│       │   │  496 │ 
│       │   │  497 │         /// <summary>
│       │   │  498 │         /// Calculates similarity between two value sets
│       │   │  499 │         /// </summary>
│       │   │  500 │         private double CalculateSimilarity(
│       │   │  501 │             IDictionary<string, string> groupValues,
│       │   │  502 │             Dictionary<string, string> xmlValues)
│       │   │  503 │         {
│       │   │  504 │             if (!groupValues.Any() || !xmlValues.Any())
│       │   │  505 │                 return 0;
│       │   │  506 │ 
│       │   │  507 │             // Create case-insensitive dictionaries for comparison
│       │   │  508 │             var caseInsensitiveGroup = new Dictionary<string, string>(groupValues, StringComparer.OrdinalIgnoreCase);
│       │   │  509 │             var caseInsensitiveXml = new Dictionary<string, string>(xmlValues, StringComparer.OrdinalIgnoreCase);
│       │   │  510 │ 
│       │   │  511 │             // Get all unique keys using case-insensitive comparison
│       │   │  512 │             var allKeys = new HashSet<string>(
│       │   │  513 │                 caseInsensitiveGroup.Keys.Concat(caseInsensitiveXml.Keys),
│       │   │  514 │                 StringComparer.OrdinalIgnoreCase
│       │   │  515 │             );
│       │   │  516 │ 
│       │   │  517 │             // Count matching keys
│       │   │  518 │             int matchingKeys = 0;
│       │   │  519 │             foreach (var key in allKeys)
│       │   │  520 │             {
│       │   │  521 │                 bool inGroup = caseInsensitiveGroup.ContainsKey(key);
│       │   │  522 │                 bool inXml = caseInsensitiveXml.ContainsKey(key);
│       │   │  523 │ 
│       │   │  524 │                 if (inGroup && inXml)
│       │   │  525 │                 {
│       │   │  526 │                     matchingKeys++;
│       │   │  527 │                 }
│       │   │  528 │             }
│       │   │  529 │ 
│       │   │  530 │             return (double)matchingKeys / allKeys.Count;
│       │   │  531 │         }
│       │   │  532 │ 
│       │   │  533 │         #endregion
│       │   │  534 │     }
│       │   │  535 │ }
│       │   └──────────────────────────────────────────────────────────────────────
│       ├── 📄 ControllerModelService.cs (2.47 KB, 2025-03-11 13:54:58)
│       │   ┌──────────────────────────────────────────────────────────────────────
│       │   │ FILE CONTENT: ControllerModelService.cs
│       │   ├──────────────────────────────────────────────────────────────────────
│       │   │    1 │ ﻿using Microsoft.Extensions.Logging;
│       │   │    2 │ using System;
│       │   │    3 │ using System.Collections.Generic;
│       │   │    4 │ using System.Linq;
│       │   │    5 │ using System.Text;
│       │   │    6 │ using System.Threading.Tasks;
│       │   │    7 │ using test.Core.Interfaces;
│       │   │    8 │ using test.Core.Domain;
│       │   │    9 │ 
│       │   │   10 │ namespace test.Application.Services
│       │   │   11 │ {
│       │   │   12 │     /// <summary>
│       │   │   13 │     /// Implementation of controller model service
│       │   │   14 │     /// </summary>
│       │   │   15 │     public class ControllerModelService : IControllerModelService
│       │   │   16 │     {
│       │   │   17 │         private readonly ILogger<ControllerModelService> _logger;
│       │   │   18 │ 
│       │   │   19 │         public ControllerModelService(ILogger<ControllerModelService> logger)
│       │   │   20 │         {
│       │   │   21 │             _logger = logger;
│       │   │   22 │         }
│       │   │   23 │ 
│       │   │   24 │         public ControllerModelInfo.ControllerFamily DetermineFamily(string modelNumber)
│       │   │   25 │         {
│       │   │   26 │             var family = ControllerModelInfo.DetermineControllerFamily(modelNumber);
│       │   │   27 │             _logger.LogDebug("Determined family {Family} for model {ModelNumber}", family, modelNumber);
│       │   │   28 │             return family;
│       │   │   29 │         }
│       │   │   30 │ 
│       │   │   31 │         public ControllerModelInfo.ModelProperties GetModelProperties(string modelNumber)
│       │   │   32 │         {
│       │   │   33 │             return ControllerModelInfo.GetModelProperties(modelNumber);
│       │   │   34 │         }
│       │   │   35 │ 
│       │   │   36 │         public void SetModelProperties(string modelNumber, ControllerModelInfo.ModelProperties properties)
│       │   │   37 │         {
│       │   │   38 │             ControllerModelInfo.SetModelProperties(modelNumber, properties);
│       │   │   39 │             _logger.LogInformation("Updated model properties for {ModelNumber}", modelNumber);
│       │   │   40 │         }
│       │   │   41 │ 
│       │   │   42 │         public IEnumerable<string> GetAllKnownModels()
│       │   │   43 │         {
│       │   │   44 │             // Combine both model lists
│       │   │   45 │             var models = new List<string>();
│       │   │   46 │ 
│       │   │   47 │             // Access these via reflection since they're private fields in ControllerModelInfo
│       │   │   48 │             // Alternative: Make them accessible methods in ControllerModelInfo
│       │   │   49 │             var infinityModelsField = typeof(ControllerModelInfo).GetField("InfinityModels",
│       │   │   50 │                 System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static);
│       │   │   51 │ 
│       │   │   52 │             var i2ModelsField = typeof(ControllerModelInfo).GetField("I2Models",
│       │   │   53 │                 System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static);
│       │   │   54 │ 
│       │   │   55 │             if (infinityModelsField?.GetValue(null) is HashSet<string> infinityModels)
│       │   │   56 │             {
│       │   │   57 │                 models.AddRange(infinityModels);
│       │   │   58 │             }
│       │   │   59 │ 
│       │   │   60 │             if (i2ModelsField?.GetValue(null) is HashSet<string> i2Models)
│       │   │   61 │             {
│       │   │   62 │                 models.AddRange(i2Models);
│       │   │   63 │             }
│       │   │   64 │ 
│       │   │   65 │             return models;
│       │   │   66 │         }
│       │   │   67 │     }
│       │   │   68 │ }
│       │   └──────────────────────────────────────────────────────────────────────
│       ├── 📄 ControllerService.cs (11.99 KB, 2025-03-11 15:09:39)
│       │   ┌──────────────────────────────────────────────────────────────────────
│       │   │ FILE CONTENT: ControllerService.cs
│       │   ├──────────────────────────────────────────────────────────────────────
│       │   │    1 │ ﻿using Microsoft.Extensions.Logging;
│       │   │    2 │ using System;
│       │   │    3 │ using System.Collections.Generic;
│       │   │    4 │ using System.Diagnostics;
│       │   │    5 │ using System.Linq;
│       │   │    6 │ using System.Threading.Tasks;
│       │   │    7 │ using test.Core.Domain;
│       │   │    8 │ using test.Core.Interfaces;
│       │   │    9 │ using test.Data;
│       │   │   10 │ using test.Infrastructure.Logging;
│       │   │   11 │ 
│       │   │   12 │ namespace test.Application.Services
│       │   │   13 │ {
│       │   │   14 │     /// <summary>
│       │   │   15 │     /// Service for controller-related operations
│       │   │   16 │     /// </summary>
│       │   │   17 │     public class ControllerService
│       │   │   18 │     {
│       │   │   19 │         private readonly IControllerRepository _controllerRepository;
│       │   │   20 │         private readonly IErrorHandler _errorHandler;
│       │   │   21 │         private readonly ILogger<ControllerService> _logger;
│       │   │   22 │ 
│       │   │   23 │         /// <summary>
│       │   │   24 │         /// Creates a new controller service
│       │   │   25 │         /// </summary>
│       │   │   26 │         /// <param name="controllerRepository">The controller repository</param>
│       │   │   27 │         /// <param name="errorHandler">The error handler</param>
│       │   │   28 │         /// <param name="logger">The logger</param>
│       │   │   29 │         public ControllerService(
│       │   │   30 │             IControllerRepository controllerRepository,
│       │   │   31 │             IErrorHandler errorHandler,
│       │   │   32 │             ILogger<ControllerService> logger)
│       │   │   33 │         {
│       │   │   34 │             _controllerRepository = controllerRepository ?? throw new ArgumentNullException(nameof(controllerRepository));
│       │   │   35 │             _errorHandler = errorHandler ?? throw new ArgumentNullException(nameof(errorHandler));
│       │   │   36 │             _logger = logger ?? throw new ArgumentNullException(nameof(logger));
│       │   │   37 │         }
│       │   │   38 │ 
│       │   │   39 │         /// <summary>
│       │   │   40 │         /// Gets controllers by session ID
│       │   │   41 │         /// </summary>
│       │   │   42 │         /// <param name="sessionId">The session ID</param>
│       │   │   43 │         /// <param name="page">The page number (0-based)</param>
│       │   │   44 │         /// <param name="pageSize">The page size</param>
│       │   │   45 │         /// <returns>A list of controllers</returns>
│       │   │   46 │         public async Task<List<Controller>> GetControllersBySessionAsync(string sessionId, int page = 0, int pageSize = 50)
│       │   │   47 │         {
│       │   │   48 │             return await _errorHandler.WithErrorHandlingAsync(async () =>
│       │   │   49 │             {
│       │   │   50 │                 var skip = page * pageSize;
│       │   │   51 │                 var controllers = await _controllerRepository.GetControllersBySessionAsync(sessionId, skip, pageSize);
│       │   │   52 │                 return controllers.ToList();
│       │   │   53 │             }, "GetControllersBySession");
│       │   │   54 │         }
│       │   │   55 │ 
│       │   │   56 │         /// <summary>
│       │   │   57 │         /// Gets all sessions
│       │   │   58 │         /// </summary>
│       │   │   59 │         /// <returns>A list of session information</returns>
│       │   │   60 │         public async Task<List<SessionInfo>> GetAllSessionsAsync()
│       │   │   61 │         {
│       │   │   62 │             return await _errorHandler.WithErrorHandlingAsync(async () =>
│       │   │   63 │             {
│       │   │   64 │                 var sessions = await _controllerRepository.GetAllSessionsAsync();
│       │   │   65 │                 return sessions.ToList();
│       │   │   66 │             }, "GetAllSessions");
│       │   │   67 │         }
│       │   │   68 │ 
│       │   │   69 │         /// <summary>
│       │   │   70 │         /// Gets session information
│       │   │   71 │         /// </summary>
│       │   │   72 │         /// <param name="sessionId">The session ID</param>
│       │   │   73 │         /// <returns>The session information</returns>
│       │   │   74 │         public async Task<SessionInfo> GetSessionInfoAsync(string sessionId)
│       │   │   75 │         {
│       │   │   76 │             return await _errorHandler.WithErrorHandlingAsync(async () =>
│       │   │   77 │             {
│       │   │   78 │                 return await _controllerRepository.GetSessionInfoAsync(sessionId);
│       │   │   79 │             }, "GetSessionInfo");
│       │   │   80 │         }
│       │   │   81 │ 
│       │   │   82 │         /// <summary>
│       │   │   83 │         /// Gets sessions by project ID
│       │   │   84 │         /// </summary>
│       │   │   85 │         /// <param name="projectId">The project ID</param>
│       │   │   86 │         /// <returns>A list of session information</returns>
│       │   │   87 │         public async Task<List<SessionInfo>> GetSessionsByProjectAsync(string projectId)
│       │   │   88 │         {
│       │   │   89 │             return await _errorHandler.WithErrorHandlingAsync(async () =>
│       │   │   90 │             {
│       │   │   91 │                 var sessions = await _controllerRepository.GetSessionsByProjectAsync(projectId);
│       │   │   92 │                 return sessions.ToList();
│       │   │   93 │             }, "GetSessionsByProject");
│       │   │   94 │         }
│       │   │   95 │ 
│       │   │   96 │         /// <summary>
│       │   │   97 │         /// Deletes a session
│       │   │   98 │         /// </summary>
│       │   │   99 │         /// <param name="sessionId">The session ID</param>
│       │   │  100 │         /// <returns>True if deleted, false if not found</returns>
│       │   │  101 │         public async Task<bool> DeleteSessionAsync(string sessionId)
│       │   │  102 │         {
│       │   │  103 │             return await _errorHandler.WithErrorHandlingAsync(async () =>
│       │   │  104 │             {
│       │   │  105 │                 return await _controllerRepository.DeleteSessionAsync(sessionId);
│       │   │  106 │             }, "DeleteSession");
│       │   │  107 │         }
│       │   │  108 │ 
│       │   │  109 │         /// <summary>
│       │   │  110 │         /// Cleans up old sessions
│       │   │  111 │         /// </summary>
│       │   │  112 │         /// <param name="maxAgeDays">The maximum age in days</param>
│       │   │  113 │         /// <returns>The number of sessions deleted</returns>
│       │   │  114 │         public async Task<int> CleanupOldSessionsAsync(int maxAgeDays)
│       │   │  115 │         {
│       │   │  116 │             return await _errorHandler.WithErrorHandlingAsync(async () =>
│       │   │  117 │             {
│       │   │  118 │                 var maxAge = TimeSpan.FromDays(maxAgeDays);
│       │   │  119 │                 return await _controllerRepository.CleanupOldSessionsAsync(maxAge);
│       │   │  120 │             }, "CleanupOldSessions");
│       │   │  121 │         }
│       │   │  122 │ 
│       │   │  123 │         /// <summary>
│       │   │  124 │         /// Optimizes the database
│       │   │  125 │         /// </summary>
│       │   │  126 │         public async Task OptimizeDatabaseAsync()
│       │   │  127 │         {
│       │   │  128 │             await _errorHandler.WithErrorHandlingAsync(async () =>
│       │   │  129 │             {
│       │   │  130 │                 await _controllerRepository.OptimizeDatabaseAsync();
│       │   │  131 │             }, "OptimizeDatabase");
│       │   │  132 │         }
│       │   │  133 │ 
│       │   │  134 │         /// <summary>
│       │   │  135 │         /// Gets a database health report
│       │   │  136 │         /// </summary>
│       │   │  137 │         /// <returns>A health report string</returns>
│       │   │  138 │         public async Task<string> GetDatabaseHealthReportAsync()
│       │   │  139 │         {
│       │   │  140 │             return await _errorHandler.WithErrorHandlingAsync(async () =>
│       │   │  141 │             {
│       │   │  142 │                 return await _controllerRepository.GetDatabaseHealthReportAsync();
│       │   │  143 │             }, "GetDatabaseHealthReport");
│       │   │  144 │         }
│       │   │  145 │ 
│       │   │  146 │         /// <summary>
│       │   │  147 │         /// Filters controllers based on specified criteria
│       │   │  148 │         /// </summary>
│       │   │  149 │         /// <param name="controllers">The controllers to filter</param>
│       │   │  150 │         /// <param name="typeWhitelist">Types to include</param>
│       │   │  151 │         /// <param name="nameFilters">Name filters</param>
│       │   │  152 │         /// <param name="isWhitelist">Whether name filters are a whitelist (true) or blacklist (false)</param>
│       │   │  153 │         /// <param name="ignoreEmptyValues">Whether to ignore empty values</param>
│       │   │  154 │         /// <param name="includeByteCode">Whether to include byte code</param>
│       │   │  155 │         /// <returns>A filtered list of controllers</returns>
│       │   │  156 │         public List<Controller> FilterControllers(
│       │   │  157 │             IEnumerable<Controller> controllers,
│       │   │  158 │             HashSet<string> typeWhitelist = null,
│       │   │  159 │             HashSet<string> nameFilters = null,
│       │   │  160 │             bool isWhitelist = true,
│       │   │  161 │             bool ignoreEmptyValues = false,
│       │   │  162 │             bool includeByteCode = true)
│       │   │  163 │         {
│       │   │  164 │             return _errorHandler.WithErrorHandlingAsync(() =>
│       │   │  165 │             {
│       │   │  166 │                 var filteredControllers = new List<Controller>();
│       │   │  167 │                 var sw = Stopwatch.StartNew();
│       │   │  168 │ 
│       │   │  169 │                 foreach (var controller in controllers)
│       │   │  170 │                 {
│       │   │  171 │                     var filteredObjects = FilterObjects(
│       │   │  172 │                         controller.Objects,
│       │   │  173 │                         typeWhitelist,
│       │   │  174 │                         nameFilters,
│       │   │  175 │                         isWhitelist,
│       │   │  176 │                         ignoreEmptyValues,
│       │   │  177 │                         includeByteCode);
│       │   │  178 │ 
│       │   │  179 │                     if (filteredObjects.Count > 0)
│       │   │  180 │                     {
│       │   │  181 │                         // Create a new controller with filtered objects
│       │   │  182 │                         var newController = new Controller(controller.Name, controller.Model);
│       │   │  183 │ 
│       │   │  184 │                         // Copy properties
│       │   │  185 │                         foreach (var prop in controller.Properties)
│       │   │  186 │                         {
│       │   │  187 │                             newController.SetProperty(prop.Key, prop.Value);
│       │   │  188 │                         }
│       │   │  189 │ 
│       │   │  190 │                         // Set connection info
│       │   │  191 │                         newController.SetConnectionInfo(
│       │   │  192 │                             controller.Port,
│       │   │  193 │                             controller.SerialNumber,
│       │   │  194 │                             controller.InfinetId);
│       │   │  195 │ 
│       │   │  196 │                         // Add filtered objects
│       │   │  197 │                         foreach (var obj in filteredObjects)
│       │   │  198 │                         {
│       │   │  199 │                             newController.AddObject(obj);
│       │   │  200 │                         }
│       │   │  201 │ 
│       │   │  202 │                         filteredControllers.Add(newController);
│       │   │  203 │                     }
│       │   │  204 │                 }
│       │   │  205 │ 
│       │   │  206 │                 sw.Stop();
│       │   │  207 │                 _logger.LogDebug("Filtered {ControllerCount} controllers in {ElapsedMs}ms",
│       │   │  208 │                     filteredControllers.Count, sw.ElapsedMilliseconds);
│       │   │  209 │ 
│       │   │  210 │                 return Task.FromResult(filteredControllers);
│       │   │  211 │             }, "FilterControllers").GetAwaiter().GetResult();
│       │   │  212 │         }
│       │   │  213 │ 
│       │   │  214 │         #region Private Helper Methods
│       │   │  215 │ 
│       │   │  216 │         private List<ControllerObject> FilterObjects(
│       │   │  217 │             IEnumerable<ControllerObject> objects,
│       │   │  218 │             HashSet<string> typeWhitelist,
│       │   │  219 │             HashSet<string> nameFilters,
│       │   │  220 │             bool isWhitelist,
│       │   │  221 │             bool ignoreEmptyValues,
│       │   │  222 │             bool includeByteCode)
│       │   │  223 │         {
│       │   │  224 │             if (objects == null)
│       │   │  225 │                 return new List<ControllerObject>();
│       │   │  226 │ 
│       │   │  227 │             var filteredObjects = new List<ControllerObject>();
│       │   │  228 │ 
│       │   │  229 │             foreach (var obj in objects)
│       │   │  230 │             {
│       │   │  231 │                 bool shouldInclude = ShouldIncludeObject(
│       │   │  232 │                     obj, typeWhitelist, nameFilters, isWhitelist, ignoreEmptyValues);
│       │   │  233 │ 
│       │   │  234 │                 if (shouldInclude)
│       │   │  235 │                 {
│       │   │  236 │                     // Create a filtered copy of the object
│       │   │  237 │                     var newObject = new ControllerObject(
│       │   │  238 │                         obj.Type,
│       │   │  239 │                         obj.Name,
│       │   │  240 │                         includeByteCode || !obj.HasByteCode ? obj.Value : string.Empty);
│       │   │  241 │ 
│       │   │  242 │                     // Set properties
│       │   │  243 │                     if (!string.IsNullOrEmpty(obj.Alias))
│       │   │  244 │                     {
│       │   │  245 │                         newObject.SetAlias(obj.Alias);
│       │   │  246 │                     }
│       │   │  247 │ 
│       │   │  248 │                     newObject.SetHasByteCode(obj.HasByteCode);
│       │   │  249 │ 
│       │   │  250 │                     foreach (var prop in obj.Properties)
│       │   │  251 │                     {
│       │   │  252 │                         newObject.SetProperty(prop.Key, prop.Value);
│       │   │  253 │                     }
│       │   │  254 │ 
│       │   │  255 │                     // Recursively filter children
│       │   │  256 │                     if (obj.Children.Any())
│       │   │  257 │                     {
│       │   │  258 │                         var filteredChildren = FilterObjects(
│       │   │  259 │                             obj.Children,
│       │   │  260 │                             typeWhitelist,
│       │   │  261 │                             nameFilters,
│       │   │  262 │                             isWhitelist,
│       │   │  263 │                             ignoreEmptyValues,
│       │   │  264 │                             includeByteCode);
│       │   │  265 │ 
│       │   │  266 │                         foreach (var child in filteredChildren)
│       │   │  267 │                         {
│       │   │  268 │                             newObject.AddChild(child);
│       │   │  269 │                         }
│       │   │  270 │                     }
│       │   │  271 │ 
│       │   │  272 │                     filteredObjects.Add(newObject);
│       │   │  273 │                 }
│       │   │  274 │             }
│       │   │  275 │ 
│       │   │  276 │             return filteredObjects;
│       │   │  277 │         }
│       │   │  278 │ 
│       │   │  279 │         private bool ShouldIncludeObject(
│       │   │  280 │             ControllerObject obj,
│       │   │  281 │             HashSet<string> typeWhitelist,
│       │   │  282 │             HashSet<string> nameFilters,
│       │   │  283 │             bool isWhitelist,
│       │   │  284 │             bool ignoreEmptyValues)
│       │   │  285 │         {
│       │   │  286 │             // Check if we should ignore empty values
│       │   │  287 │             if (ignoreEmptyValues && string.IsNullOrWhiteSpace(obj.Value))
│       │   │  288 │                 return false;
│       │   │  289 │ 
│       │   │  290 │             // Check type whitelist
│       │   │  291 │             if (typeWhitelist?.Count > 0 && !typeWhitelist.Contains(obj.Type))
│       │   │  292 │                 return false;
│       │   │  293 │ 
│       │   │  294 │             // If no name filters, include the object
│       │   │  295 │             if (nameFilters == null || nameFilters.Count == 0)
│       │   │  296 │                 return true;
│       │   │  297 │ 
│       │   │  298 │             // Check if the object's name or alias matches any filter
│       │   │  299 │             bool nameMatches = nameFilters.Contains(obj.Name, StringComparer.OrdinalIgnoreCase) ||
│       │   │  300 │                               (!string.IsNullOrEmpty(obj.Alias) &&
│       │   │  301 │                                nameFilters.Contains(obj.Alias, StringComparer.OrdinalIgnoreCase));
│       │   │  302 │ 
│       │   │  303 │             // For whitelist, include if name matches; for blacklist, include if name doesn't match
│       │   │  304 │             return isWhitelist ? nameMatches : !nameMatches;
│       │   │  305 │         }
│       │   │  306 │ 
│       │   │  307 │         #endregion
│       │   │  308 │     }
│       │   │  309 │ }
│       │   └──────────────────────────────────────────────────────────────────────
│       ├── 📄 ExportService.cs (23.47 KB, 2025-03-11 15:06:06)
│       │   ┌──────────────────────────────────────────────────────────────────────
│       │   │ FILE CONTENT: ExportService.cs
│       │   ├──────────────────────────────────────────────────────────────────────
│       │   │    1 │ ﻿using System;
│       │   │    2 │ using System.Collections.Generic;
│       │   │    3 │ using System.IO;
│       │   │    4 │ using System.Linq;
│       │   │    5 │ using System.Text;
│       │   │    6 │ using System.Threading.Tasks;
│       │   │    7 │ using System.Xml.Linq;
│       │   │    8 │ using ClosedXML.Excel;
│       │   │    9 │ using Microsoft.Extensions.DependencyInjection;
│       │   │   10 │ using Microsoft.Extensions.Logging;
│       │   │   11 │ using test.Core.Domain;
│       │   │   12 │ using test.Core.Exceptions;
│       │   │   13 │ using test.Core.Interfaces;
│       │   │   14 │ using test.Infrastructure.Logging;
│       │   │   15 │ using test.Core.Domain;
│       │   │   16 │ using Domain = test.Core.Domain;
│       │   │   17 │ 
│       │   │   18 │ namespace test.Application.Services
│       │   │   19 │ {
│       │   │   20 │     /// <summary>
│       │   │   21 │     /// Implementation of export service for controller data
│       │   │   22 │     /// </summary>
│       │   │   23 │     public class ExportService : IExportService
│       │   │   24 │     {
│       │   │   25 │         private readonly IErrorHandler _errorHandler;
│       │   │   26 │         private readonly ILogger<ExportService> _logger;
│       │   │   27 │         private readonly IFileSystem _fileSystem;
│       │   │   28 │         private readonly IServiceProvider _serviceProvider; 
│       │   │   29 │ 
│       │   │   30 │         // Pre-defined formats
│       │   │   31 │         private readonly List<ExportFormat> _formats = new List<ExportFormat>
│       │   │   32 │         {
│       │   │   33 │             new ExportFormat
│       │   │   34 │             {
│       │   │   35 │                 Id = "xml",
│       │   │   36 │                 DisplayName = "XML",
│       │   │   37 │                 Extension = ".xml",
│       │   │   38 │                 MimeType = "application/xml",
│       │   │   39 │                 SupportsById = true,
│       │   │   40 │                 Description = "Industry-standard XML format."
│       │   │   41 │             },
│       │   │   42 │             new ExportFormat
│       │   │   43 │             {
│       │   │   44 │                 Id = "excel",
│       │   │   45 │                 DisplayName = "Excel Workbook",
│       │   │   46 │                 Extension = ".xlsx",
│       │   │   47 │                 MimeType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
│       │   │   48 │                 SupportsById = false,
│       │   │   49 │                 Description = "Microsoft Excel workbook with multiple sheets."
│       │   │   50 │             },
│       │   │   51 │             new ExportFormat
│       │   │   52 │             {
│       │   │   53 │                 Id = "csv-grouped",
│       │   │   54 │                 DisplayName = "Grouped CSV",
│       │   │   55 │                 Extension = ".csv",
│       │   │   56 │                 MimeType = "text/csv",
│       │   │   57 │                 SupportsById = false,
│       │   │   58 │                 Description = "CSV with controller grouping for similarity comparison."
│       │   │   59 │             },
│       │   │   60 │             new ExportFormat
│       │   │   61 │             {
│       │   │   62 │                 Id = "objectset",
│       │   │   63 │                 DisplayName = "ObjectSet XML",
│       │   │   64 │                 Extension = ".xml",
│       │   │   65 │                 MimeType = "application/xml",
│       │   │   66 │                 SupportsById = true,
│       │   │   67 │                 Description = "Vendor-specific ObjectSet XML format."
│       │   │   68 │             }
│       │   │   69 │         };
│       │   │   70 │ 
│       │   │   71 │         /// <summary>
│       │   │   72 │         /// Creates a new export service
│       │   │   73 │         /// </summary>
│       │   │   74 │         /// <param name="errorHandler">The error handler</param>
│       │   │   75 │         /// <param name="logger">The logger</param>
│       │   │   76 │         /// <param name="fileSystem">The file system</param>
│       │   │   77 │         public ExportService(IErrorHandler errorHandler, ILogger<ExportService> logger, IFileSystem fileSystem)
│       │   │   78 │         {
│       │   │   79 │             _errorHandler = errorHandler ?? throw new ArgumentNullException(nameof(errorHandler));
│       │   │   80 │             _logger = logger ?? throw new ArgumentNullException(nameof(logger));
│       │   │   81 │             _fileSystem = fileSystem ?? throw new ArgumentNullException(nameof(fileSystem));
│       │   │   82 │         }
│       │   │   83 │         /// <summary>
│       │   │   84 │         /// Exports controllers to ObjectSet XML format
│       │   │   85 │         /// </summary>
│       │   │   86 │         /// <param name="controllers">The controllers to export</param>
│       │   │   87 │         /// <param name="filePath">The output file path</param>
│       │   │   88 │         /// <param name="options">Export options</param>
│       │   │   89 │         /// <returns>True if successful, false otherwise</returns>
│       │   │   90 │         public async Task<bool> ExportToObjectSetXmlAsync(
│       │   │   91 │             IEnumerable<Controller> controllers,
│       │   │   92 │             string filePath,
│       │   │   93 │             ExportOptions options = null)
│       │   │   94 │         {
│       │   │   95 │             return await _errorHandler.WithErrorHandlingAsync<bool>(async () =>
│       │   │   96 │             {
│       │   │   97 │                 options ??= new ExportOptions();
│       │   │   98 │                 _logger.LogInformation("Exporting {ControllerCount} controllers to ObjectSet XML at {FilePath}",
│       │   │   99 │                     controllers.Count(), filePath);
│       │   │  100 │ 
│       │   │  101 │                 // Get the ObjectSet writer
│       │   │  102 │                 var objectSetWriter = _serviceProvider.GetRequiredService<IObjectSetWriter>();
│       │   │  103 │ 
│       │   │  104 │                 // Configure writer options
│       │   │  105 │                 var writerOptions = new ObjectSetWriteOptions
│       │   │  106 │                 {
│       │   │  107 │                     IncludeByteCode = options.IncludeByteCode,
│       │   │  108 │                     PrettyPrint = options.PrettyPrint,
│       │   │  109 │                     // Create basic meta information
│       │   │  110 │                     MetaInformation = new Domain.ObjectSet.MetaInformation
│       │   │  111 │                     {
│       │   │  112 │                         ExportMode = "Manual",
│       │   │  113 │                         RuntimeVersion = "4.0",
│       │   │  114 │                         SourceVersion = "3.0"
│       │   │  115 │                     }
│       │   │  116 │                 };
│       │   │  117 │ 
│       │   │  118 │                 // Generate the XML document
│       │   │  119 │                 var document = await objectSetWriter.WriteAsync(controllers, writerOptions);
│       │   │  120 │ 
│       │   │  121 │                 // Save to file
│       │   │  122 │                 using (var stream = _fileSystem.OpenWrite(filePath))
│       │   │  123 │                 {
│       │   │  124 │                     if (options.PrettyPrint)
│       │   │  125 │                     {
│       │   │  126 │                         await document.SaveAsync(stream, System.Xml.Linq.SaveOptions.None, default);
│       │   │  127 │                     }
│       │   │  128 │                     else
│       │   │  129 │                     {
│       │   │  130 │                         await document.SaveAsync(stream,System.Xml.Linq.SaveOptions.DisableFormatting, default);
│       │   │  131 │                     }
│       │   │  132 │                 }
│       │   │  133 │ 
│       │   │  134 │                 _logger.LogInformation("ObjectSet XML export completed successfully");
│       │   │  135 │                 return true;
│       │   │  136 │             }, "ExportToObjectSetXml", (filePath != null && !string.IsNullOrWhiteSpace(filePath)));
│       │   │  137 │         }
│       │   │  138 │         /// <inheritdoc/>
│       │   │  139 │         public async Task<bool> ExportToXmlAsync(IEnumerable<Controller> controllers, string filePath, ExportOptions options = null)
│       │   │  140 │         {
│       │   │  141 │             return await _errorHandler.WithErrorHandlingAsync<bool>(async () =>
│       │   │  142 │             {
│       │   │  143 │                 options ??= new ExportOptions();
│       │   │  144 │                 _logger.LogInformation("Exporting {ControllerCount} controllers to XML at {FilePath}",
│       │   │  145 │                     controllers.Count(), filePath);
│       │   │  146 │ 
│       │   │  147 │                 // Create root element
│       │   │  148 │                 var root = new XElement("Controllers");
│       │   │  149 │ 
│       │   │  150 │                 // Add controllers
│       │   │  151 │                 foreach (var controller in controllers)
│       │   │  152 │                 {
│       │   │  153 │                     var controllerElement = new XElement("Controller",
│       │   │  154 │                         new XAttribute("Name", controller.Name),
│       │   │  155 │                         new XAttribute("Model", controller.Model));
│       │   │  156 │ 
│       │   │  157 │                     // Add controller properties
│       │   │  158 │                     foreach (var property in controller.Properties)
│       │   │  159 │                     {
│       │   │  160 │                         controllerElement.Add(new XElement("Property",
│       │   │  161 │                             new XAttribute("Name", property.Key),
│       │   │  162 │                             new XAttribute("Value", property.Value ?? string.Empty)));
│       │   │  163 │                     }
│       │   │  164 │ 
│       │   │  165 │                     // Add controller objects
│       │   │  166 │                     var filteredObjects = FilterObjects(controller.Objects, options);
│       │   │  167 │                     foreach (var obj in filteredObjects)
│       │   │  168 │                     {
│       │   │  169 │                         controllerElement.Add(CreateObjectElement(obj, options));
│       │   │  170 │                     }
│       │   │  171 │ 
│       │   │  172 │                     root.Add(controllerElement);
│       │   │  173 │                 }
│       │   │  174 │ 
│       │   │  175 │                 // Create document
│       │   │  176 │                 var document = new XDocument(
│       │   │  177 │                     new XDeclaration("1.0", "utf-8", null),
│       │   │  178 │                     root);
│       │   │  179 │ 
│       │   │  180 │                 // Save document
│       │   │  181 │                 using (var stream = _fileSystem.OpenWrite(filePath))
│       │   │  182 │                 {
│       │   │  183 │                     await Task.Run(() => {
│       │   │  184 │                         document.Save(stream, options.PrettyPrint ? System.Xml.Linq.SaveOptions.None : System.Xml.Linq.SaveOptions.DisableFormatting);
│       │   │  185 │                         return Task.CompletedTask;
│       │   │  186 │                     });
│       │   │  187 │                 }
│       │   │  188 │ 
│       │   │  189 │                 _logger.LogInformation("XML export completed successfully");
│       │   │  190 │                 return true;
│       │   │  191 │             }, "ExportToXml", (filePath != null && !string.IsNullOrWhiteSpace(filePath)));
│       │   │  192 │         }
│       │   │  193 │ 
│       │   │  194 │         /// <inheritdoc/>
│       │   │  195 │         public async Task<bool> ExportToExcelAsync(IEnumerable<Controller> controllers, string filePath, ExportOptions options = null)
│       │   │  196 │         {
│       │   │  197 │             return await _errorHandler.WithErrorHandlingAsync<bool>(async () =>
│       │   │  198 │             {
│       │   │  199 │                 options ??= new ExportOptions();
│       │   │  200 │                 _logger.LogInformation("Exporting {ControllerCount} controllers to Excel at {FilePath}",
│       │   │  201 │                     controllers.Count(), filePath);
│       │   │  202 │ 
│       │   │  203 │                 using (var workbook = new XLWorkbook())
│       │   │  204 │                 {
│       │   │  205 │                     // Create summary sheet
│       │   │  206 │                     var summarySheet = workbook.Worksheets.Add("Summary");
│       │   │  207 │ 
│       │   │  208 │                     // Add headers
│       │   │  209 │                     summarySheet.Cell(1, 1).Value = "Controller Name";
│       │   │  210 │                     summarySheet.Cell(1, 2).Value = "Model";
│       │   │  211 │                     summarySheet.Cell(1, 3).Value = "Object Count";
│       │   │  212 │ 
│       │   │  213 │                     // Add data
│       │   │  214 │                     int row = 2;
│       │   │  215 │                     foreach (var controller in controllers)
│       │   │  216 │                     {
│       │   │  217 │                         summarySheet.Cell(row, 1).Value = controller.Name;
│       │   │  218 │                         summarySheet.Cell(row, 2).Value = controller.Model;
│       │   │  219 │ 
│       │   │  220 │                         var filteredObjects = FilterObjects(controller.Objects, options);
│       │   │  221 │                         summarySheet.Cell(row, 3).Value = filteredObjects.Count;
│       │   │  222 │ 
│       │   │  223 │                         // Create controller sheet
│       │   │  224 │                         var controllerName = SanitizeSheetName(controller.Name);
│       │   │  225 │                         if (workbook.Worksheets.Contains(controllerName))
│       │   │  226 │                         {
│       │   │  227 │                             // Append numeric suffix for duplicates
│       │   │  228 │                             int suffix = 1;
│       │   │  229 │                             while (workbook.Worksheets.Contains($"{controllerName}_{suffix}"))
│       │   │  230 │                             {
│       │   │  231 │                                 suffix++;
│       │   │  232 │                             }
│       │   │  233 │                             controllerName = $"{controllerName}_{suffix}";
│       │   │  234 │                         }
│       │   │  235 │ 
│       │   │  236 │                         var controllerSheet = workbook.Worksheets.Add(controllerName);
│       │   │  237 │ 
│       │   │  238 │                         // Add headers
│       │   │  239 │                         controllerSheet.Cell(1, 1).Value = "Type";
│       │   │  240 │                         controllerSheet.Cell(1, 2).Value = "Name";
│       │   │  241 │                         controllerSheet.Cell(1, 3).Value = "Alias";
│       │   │  242 │                         controllerSheet.Cell(1, 4).Value = "Value";
│       │   │  243 │ 
│       │   │  244 │                         // Add objects
│       │   │  245 │                         int objRow = 2;
│       │   │  246 │                         AddControllerObjectsToSheet(controllerSheet, ref objRow, filteredObjects, options);
│       │   │  247 │ 
│       │   │  248 │                         row++;
│       │   │  249 │                     }
│       │   │  250 │ 
│       │   │  251 │                     // Auto-fit columns
│       │   │  252 │                     summarySheet.Columns().AdjustToContents();
│       │   │  253 │ 
│       │   │  254 │                     // Save workbook
│       │   │  255 │                     await Task.Run(() => {
│       │   │  256 │                         workbook.SaveAs(filePath);
│       │   │  257 │                         return Task.CompletedTask;
│       │   │  258 │                     });
│       │   │  259 │                 }
│       │   │  260 │ 
│       │   │  261 │                 _logger.LogInformation("Excel export completed successfully");
│       │   │  262 │                 return true;
│       │   │  263 │             }, "ExportToExcel", (filePath != null && !string.IsNullOrWhiteSpace(filePath)));
│       │   │  264 │         }
│       │   │  265 │ 
│       │   │  266 │         /// <inheritdoc/>
│       │   │  267 │         public async Task<IEnumerable<GroupComparison>> ExportToGroupedCsvAsync(IEnumerable<Controller> controllers, string filePath, ExportOptions options = null)
│       │   │  268 │         {
│       │   │  269 │             return await _errorHandler.WithErrorHandlingAsync<IEnumerable<GroupComparison>>(async () =>
│       │   │  270 │             {
│       │   │  271 │                 options ??= new ExportOptions();
│       │   │  272 │                 _logger.LogInformation("Exporting {ControllerCount} controllers to grouped CSV at {FilePath}",
│       │   │  273 │                     controllers.Count(), filePath);
│       │   │  274 │ 
│       │   │  275 │                 // Filter objects based on options
│       │   │  276 │                 var groupedControllers = new List<ControllerGroup>();
│       │   │  277 │                 foreach (var controller in controllers)
│       │   │  278 │                 {
│       │   │  279 │                     var filteredObjects = FilterObjects(controller.Objects, options);
│       │   │  280 │ 
│       │   │  281 │                     // Find or create group
│       │   │  282 │                     var signature = ComputeControllerSignature(controller, filteredObjects);
│       │   │  283 │                     var group = groupedControllers.FirstOrDefault(g => g.GroupIdentifier == signature);
│       │   │  284 │ 
│       │   │  285 │                     if (group == null)
│       │   │  286 │                     {
│       │   │  287 │                         group = new ControllerGroup(signature);
│       │   │  288 │                         groupedControllers.Add(group);
│       │   │  289 │                     }
│       │   │  290 │ 
│       │   │  291 │                     // Add controller to group
│       │   │  292 │                     group.AddControllerName(controller.Name);
│       │   │  293 │ 
│       │   │  294 │                     // Extract and store values
│       │   │  295 │                     ExtractObjectValues(filteredObjects, group.OriginalValues, group.ProcessedValues, group.NameMapping);
│       │   │  296 │                 }
│       │   │  297 │ 
│       │   │  298 │                 _logger.LogInformation("Found {GroupCount} distinct controller groups", groupedControllers.Count);
│       │   │  299 │ 
│       │   │  300 │                 // Create CSV content
│       │   │  301 │                 var sb = new StringBuilder();
│       │   │  302 │ 
│       │   │  303 │                 // Write headers
│       │   │  304 │                 sb.AppendLine("Group,Controller,Type,Name,Alias,Value");
│       │   │  305 │ 
│       │   │  306 │                 // Write data
│       │   │  307 │                 foreach (var group in groupedControllers)
│       │   │  308 │                 {
│       │   │  309 │                     int groupIndex = groupedControllers.IndexOf(group) + 1;
│       │   │  310 │ 
│       │   │  311 │                     foreach (var controllerName in group.ControllerNames)
│       │   │  312 │                     {
│       │   │  313 │                         foreach (var value in group.OriginalValues)
│       │   │  314 │                         {
│       │   │  315 │                             sb.AppendLine($"{groupIndex},{EscapeCsvValue(controllerName)},Object,{EscapeCsvValue(value.Key)},,{EscapeCsvValue(value.Value)}");
│       │   │  316 │                         }
│       │   │  317 │                     }
│       │   │  318 │                 }
│       │   │  319 │ 
│       │   │  320 │                 // Save file
│       │   │  321 │                 await _fileSystem.WriteAllTextAsync(filePath, sb.ToString());
│       │   │  322 │ 
│       │   │  323 │                 // Generate comparisons
│       │   │  324 │                 var comparisons = GenerateGroupComparisons(groupedControllers);
│       │   │  325 │ 
│       │   │  326 │                 _logger.LogInformation("CSV export completed successfully with {ComparisonCount} group comparisons",
│       │   │  327 │                     comparisons.Count);
│       │   │  328 │ 
│       │   │  329 │                 return comparisons;
│       │   │  330 │             }, "ExportToGroupedCsv", (filePath != null && !string.IsNullOrWhiteSpace(filePath)));
│       │   │  331 │         }
│       │   │  332 │ 
│       │   │  333 │         /// <inheritdoc/>
│       │   │  334 │         public IEnumerable<ExportFormat> GetAvailableFormats()
│       │   │  335 │         {
│       │   │  336 │             return _formats;
│       │   │  337 │         }
│       │   │  338 │ 
│       │   │  339 │         #region Helper Methods
│       │   │  340 │ 
│       │   │  341 │         /// <summary>
│       │   │  342 │         /// Filters objects based on export options
│       │   │  343 │         /// </summary>
│       │   │  344 │         private List<ControllerObject> FilterObjects(IEnumerable<ControllerObject> objects, ExportOptions options)
│       │   │  345 │         {
│       │   │  346 │             if (objects == null)
│       │   │  347 │                 return new List<ControllerObject>();
│       │   │  348 │ 
│       │   │  349 │             var result = new List<ControllerObject>();
│       │   │  350 │ 
│       │   │  351 │             foreach (var obj in objects)
│       │   │  352 │             {
│       │   │  353 │                 // Check type filter
│       │   │  354 │                 if (options.IncludedTypes.Count > 0 && !options.IncludedTypes.Contains(obj.Type))
│       │   │  355 │                     continue;
│       │   │  356 │ 
│       │   │  357 │                 // Check name filter
│       │   │  358 │                 if (options.ExcludedNames.Contains(obj.Name))
│       │   │  359 │                     continue;
│       │   │  360 │ 
│       │   │  361 │                 // Check empty value filter
│       │   │  362 │                 if (!options.IncludeEmptyValues && string.IsNullOrWhiteSpace(obj.Value))
│       │   │  363 │                     continue;
│       │   │  364 │ 
│       │   │  365 │                 // Check byte code filter
│       │   │  366 │                 if (!options.IncludeByteCode && obj.HasByteCode)
│       │   │  367 │                     continue;
│       │   │  368 │ 
│       │   │  369 │                 // Clone object (to avoid modifying original)
│       │   │  370 │                 var clonedObj = new ControllerObject(obj.Type, obj.Name, obj.Value);
│       │   │  371 │                 if (!string.IsNullOrEmpty(obj.Alias))
│       │   │  372 │                     clonedObj.SetAlias(obj.Alias);
│       │   │  373 │ 
│       │   │  374 │                 clonedObj.SetHasByteCode(obj.HasByteCode);
│       │   │  375 │ 
│       │   │  376 │                 // Add properties
│       │   │  377 │                 foreach (var prop in obj.Properties)
│       │   │  378 │                 {
│       │   │  379 │                     clonedObj.SetProperty(prop.Key, prop.Value);
│       │   │  380 │                 }
│       │   │  381 │ 
│       │   │  382 │                 // Add filtered children
│       │   │  383 │                 foreach (var child in FilterObjects(obj.Children, options))
│       │   │  384 │                 {
│       │   │  385 │                     clonedObj.AddChild(child);
│       │   │  386 │                 }
│       │   │  387 │ 
│       │   │  388 │                 result.Add(clonedObj);
│       │   │  389 │             }
│       │   │  390 │ 
│       │   │  391 │             return result;
│       │   │  392 │         }
│       │   │  393 │ 
│       │   │  394 │         /// <summary>
│       │   │  395 │         /// Creates XML element for an object
│       │   │  396 │         /// </summary>
│       │   │  397 │         private XElement CreateObjectElement(ControllerObject obj, ExportOptions options)
│       │   │  398 │         {
│       │   │  399 │             var element = new XElement("Object",
│       │   │  400 │                 new XAttribute("Type", obj.Type),
│       │   │  401 │                 new XAttribute("Name", obj.Name));
│       │   │  402 │ 
│       │   │  403 │             if (!string.IsNullOrEmpty(obj.Alias))
│       │   │  404 │                 element.Add(new XAttribute("Alias", obj.Alias));
│       │   │  405 │ 
│       │   │  406 │             element.Add(new XAttribute("Value", obj.Value ?? string.Empty));
│       │   │  407 │ 
│       │   │  408 │             // Add properties
│       │   │  409 │             foreach (var property in obj.Properties)
│       │   │  410 │             {
│       │   │  411 │                 element.Add(new XElement("Property",
│       │   │  412 │                     new XAttribute("Name", property.Key),
│       │   │  413 │                     new XAttribute("Value", property.Value ?? string.Empty)));
│       │   │  414 │             }
│       │   │  415 │ 
│       │   │  416 │             // Add children recursively
│       │   │  417 │             foreach (var child in obj.Children)
│       │   │  418 │             {
│       │   │  419 │                 element.Add(CreateObjectElement(child, options));
│       │   │  420 │             }
│       │   │  421 │ 
│       │   │  422 │             return element;
│       │   │  423 │         }
│       │   │  424 │ 
│       │   │  425 │         /// <summary>
│       │   │  426 │         /// Adds objects to an Excel sheet recursively
│       │   │  427 │         /// </summary>
│       │   │  428 │         private void AddControllerObjectsToSheet(IXLWorksheet sheet, ref int row, IEnumerable<ControllerObject> objects, ExportOptions options, int depth = 0)
│       │   │  429 │         {
│       │   │  430 │             foreach (var obj in objects)
│       │   │  431 │             {
│       │   │  432 │                 string indent = new string(' ', depth * 2);
│       │   │  433 │ 
│       │   │  434 │                 sheet.Cell(row, 1).Value = obj.Type;
│       │   │  435 │                 sheet.Cell(row, 2).Value = indent + obj.Name;
│       │   │  436 │                 sheet.Cell(row, 3).Value = obj.Alias;
│       │   │  437 │                 sheet.Cell(row, 4).Value = obj.Value;
│       │   │  438 │ 
│       │   │  439 │                 row++;
│       │   │  440 │ 
│       │   │  441 │                 // Add children recursively
│       │   │  442 │                 if (obj.Children.Any())
│       │   │  443 │                 {
│       │   │  444 │                     AddControllerObjectsToSheet(sheet, ref row, obj.Children, options, depth + 1);
│       │   │  445 │                 }
│       │   │  446 │             }
│       │   │  447 │         }
│       │   │  448 │ 
│       │   │  449 │         /// <summary>
│       │   │  450 │         /// Sanitizes a sheet name to be valid in Excel
│       │   │  451 │         /// </summary>
│       │   │  452 │         private string SanitizeSheetName(string name)
│       │   │  453 │         {
│       │   │  454 │             if (string.IsNullOrEmpty(name))
│       │   │  455 │                 return "Sheet";
│       │   │  456 │ 
│       │   │  457 │             // Remove invalid characters
│       │   │  458 │             var invalidChars = new char[] { ':', '\\', '/', '?', '*', '[', ']' };
│       │   │  459 │             string sanitized = new string(name.Where(c => !invalidChars.Contains(c)).ToArray());
│       │   │  460 │ 
│       │   │  461 │             // Truncate to max length (31 characters for Excel)
│       │   │  462 │             if (sanitized.Length > 31)
│       │   │  463 │                 sanitized = sanitized.Substring(0, 31);
│       │   │  464 │ 
│       │   │  465 │             // Ensure it's not empty
│       │   │  466 │             if (string.IsNullOrWhiteSpace(sanitized))
│       │   │  467 │                 return "Sheet";
│       │   │  468 │ 
│       │   │  469 │             return sanitized;
│       │   │  470 │         }
│       │   │  471 │ 
│       │   │  472 │         /// <summary>
│       │   │  473 │         /// Computes a signature for a controller based on its objects
│       │   │  474 │         /// </summary>
│       │   │  475 │         private string ComputeControllerSignature(Controller controller, IEnumerable<ControllerObject> objects)
│       │   │  476 │         {
│       │   │  477 │             // Get model and fixed properties
│       │   │  478 │             var model = controller.Model;
│       │   │  479 │ 
│       │   │  480 │             // Hash based on objects types, names, and values
│       │   │  481 │             var objSigs = objects
│       │   │  482 │                 .OrderBy(o => o.Type)
│       │   │  483 │                 .ThenBy(o => o.Name)
│       │   │  484 │                 .Select(o => $"{o.Type}|{o.Name}|{o.Value}");
│       │   │  485 │ 
│       │   │  486 │             return $"{model}_{string.Join("_", objSigs.Take(5))}";
│       │   │  487 │         }
│       │   │  488 │ 
│       │   │  489 │         /// <summary>
│       │   │  490 │         /// Extracts values from objects and adds them to value dictionaries
│       │   │  491 │         /// </summary>
│       │   │  492 │         private void ExtractObjectValues(
│       │   │  493 │             IEnumerable<ControllerObject> objects,
│       │   │  494 │             IDictionary<string, string> originalValues,
│       │   │  495 │             IDictionary<string, string> processedValues,
│       │   │  496 │             IDictionary<string, string> nameMapping)
│       │   │  497 │         {
│       │   │  498 │             foreach (var obj in objects)
│       │   │  499 │             {
│       │   │  500 │                 // Store original mapping
│       │   │  501 │                 originalValues[obj.Name] = obj.Value ?? string.Empty;
│       │   │  502 │ 
│       │   │  503 │                 // Store processed name mapping
│       │   │  504 │                 string processedName = obj.Name;
│       │   │  505 │                 nameMapping[obj.Name] = processedName;
│       │   │  506 │ 
│       │   │  507 │                 // Add to processed values with processed name
│       │   │  508 │                 processedValues[processedName] = obj.Value ?? string.Empty;
│       │   │  509 │ 
│       │   │  510 │                 // Process children recursively
│       │   │  511 │                 if (obj.Children.Any())
│       │   │  512 │                 {
│       │   │  513 │                     ExtractObjectValues(obj.Children, originalValues, processedValues, nameMapping);
│       │   │  514 │                 }
│       │   │  515 │             }
│       │   │  516 │         }
│       │   │  517 │ 
│       │   │  518 │         /// <summary>
│       │   │  519 │         /// Generates group comparisons between all groups
│       │   │  520 │         /// </summary>
│       │   │  521 │         private List<GroupComparison> GenerateGroupComparisons(List<ControllerGroup> groups)
│       │   │  522 │         {
│       │   │  523 │             var comparisons = new List<GroupComparison>();
│       │   │  524 │ 
│       │   │  525 │             // Compare each group with every other group
│       │   │  526 │             for (int i = 0; i < groups.Count; i++)
│       │   │  527 │             {
│       │   │  528 │                 var group1 = groups[i];
│       │   │  529 │ 
│       │   │  530 │                 for (int j = i + 1; j < groups.Count; j++)
│       │   │  531 │                 {
│       │   │  532 │                     var group2 = groups[j];
│       │   │  533 │ 
│       │   │  534 │                     // Skip if identical
│       │   │  535 │                     if (group1.GroupIdentifier == group2.GroupIdentifier)
│       │   │  536 │                         continue;
│       │   │  537 │ 
│       │   │  538 │                     // Find differences
│       │   │  539 │                     var allKeys = new HashSet<string>(
│       │   │  540 │                         group1.SharedValues.Keys.Concat(group2.SharedValues.Keys),
│       │   │  541 │                         StringComparer.OrdinalIgnoreCase);
│       │   │  542 │ 
│       │   │  543 │                     var differences = new List<string>();
│       │   │  544 │ 
│       │   │  545 │                     foreach (var key in allKeys)
│       │   │  546 │                     {
│       │   │  547 │                         string value1 = group1.SharedValues.TryGetValue(key, out var v1) ? v1 : null;
│       │   │  548 │                         string value2 = group2.SharedValues.TryGetValue(key, out var v2) ? v2 : null;
│       │   │  549 │ 
│       │   │  550 │                         if (value1 != value2)
│       │   │  551 │                         {
│       │   │  552 │                             differences.Add(key);
│       │   │  553 │                         }
│       │   │  554 │                     }
│       │   │  555 │ 
│       │   │  556 │                     // Create comparison
│       │   │  557 │                     if (differences.Count > 0)
│       │   │  558 │                     {
│       │   │  559 │                         var comparison = new GroupComparison
│       │   │  560 │                         {
│       │   │  561 │                             Group1Key = group1.GroupIdentifier,
│       │   │  562 │                             Group2Key = group2.GroupIdentifier,
│       │   │  563 │                             ControllersInGroup1 = group1.ControllerNames.Count,
│       │   │  564 │                             ControllersInGroup2 = group2.ControllerNames.Count,
│       │   │  565 │                             DifferentProperties = differences,
│       │   │  566 │                             FirstControllerGroup1 = group1.ControllerNames.FirstOrDefault(),
│       │   │  567 │                             FirstControllerGroup2 = group2.ControllerNames.FirstOrDefault()
│       │   │  568 │                         };
│       │   │  569 │ 
│       │   │  570 │                         comparisons.Add(comparison);
│       │   │  571 │                     }
│       │   │  572 │                 }
│       │   │  573 │             }
│       │   │  574 │ 
│       │   │  575 │             return comparisons;
│       │   │  576 │         }
│       │   │  577 │ 
│       │   │  578 │         /// <summary>
│       │   │  579 │         /// Escapes a value for CSV format
│       │   │  580 │         /// </summary>
│       │   │  581 │         private string EscapeCsvValue(string value)
│       │   │  582 │         {
│       │   │  583 │             if (string.IsNullOrEmpty(value))
│       │   │  584 │                 return string.Empty;
│       │   │  585 │ 
│       │   │  586 │             bool needsQuoting = value.Contains(',') || value.Contains('"') ||
│       │   │  587 │                                 value.Contains('\r') || value.Contains('\n');
│       │   │  588 │ 
│       │   │  589 │             if (needsQuoting)
│       │   │  590 │                 return $"\"{value.Replace("\"", "\"\"")}\"";
│       │   │  591 │ 
│       │   │  592 │             return value;
│       │   │  593 │         }
│       │   │  594 │ 
│       │   │  595 │         #endregion
│       │   │  596 │     }
│       │   │  597 │ }
│       │   └──────────────────────────────────────────────────────────────────────
│       ├── 📄 ParsingService.cs (59.43 KB, 2025-03-11 17:45:01)
│       │   ┌──────────────────────────────────────────────────────────────────────
│       │   │ FILE CONTENT: ParsingService.cs
│       │   ├──────────────────────────────────────────────────────────────────────
│       │   │    1 │ ﻿using Microsoft.Extensions.DependencyInjection;
│       │   │    2 │ using Microsoft.Extensions.Logging;
│       │   │    3 │ using System;
│       │   │    4 │ using System.Collections.Generic;
│       │   │    5 │ using System.IO;
│       │   │    6 │ using System.Linq;
│       │   │    7 │ using System.Text;
│       │   │    8 │ using System.Text.RegularExpressions;
│       │   │    9 │ using System.Threading.Tasks;
│       │   │   10 │ using System.Xml.Linq;
│       │   │   11 │ using test.Core.Domain;
│       │   │   12 │ using test.Core.Exceptions;
│       │   │   13 │ using test.Core.Interfaces;
│       │   │   14 │ using test.Infrastructure.Logging;
│       │   │   15 │ using test.ViewModels;
│       │   │   16 │ using test.Core.Domain.ObjectSet;
│       │   │   17 │ 
│       │   │   18 │ 
│       │   │   19 │ // Using domain model ControllerGroup, not the interface version
│       │   │   20 │ using ControllerGroup = test.Core.Domain.ControllerGroup;
│       │   │   21 │ 
│       │   │   22 │ namespace test.Application.Services
│       │   │   23 │ {
│       │   │   24 │     /// <summary>
│       │   │   25 │     /// Enhanced service for parsing controller files
│       │   │   26 │     /// </summary>
│       │   │   27 │     public class ParsingService
│       │   │   28 │     {
│       │   │   29 │         private readonly IControllerRepository _controllerRepository;
│       │   │   30 │         private readonly IFileSystem _fileSystem;
│       │   │   31 │         private readonly IErrorHandler _errorHandler;
│       │   │   32 │         private readonly ILogger<ParsingService> _logger;
│       │   │   33 │         private readonly ILoggerFactory _loggerFactory;
│       │   │   34 │         private readonly IServiceProvider _serviceProvider;
│       │   │   35 │ 
│       │   │   36 │         // Static collections for controller type identification
│       │   │   37 │         private static readonly HashSet<string> InfinityModels = new HashSet<string>
│       │   │   38 │         {
│       │   │   39 │             "800", "810", "843", "846", "850", "851", "853", "890",
│       │   │   40 │             "700", "891", "892", "920", "780", "865", "866", "867",
│       │   │   41 │             "701", "781"
│       │   │   42 │         };
│       │   │   43 │ 
│       │   │   44 │         private static readonly HashSet<string> I2Models = new HashSet<string>
│       │   │   45 │         {
│       │   │   46 │             "i2624", "i2608", "i2800", "i2804", "i2850", "i2851",
│       │   │   47 │             "i2853", "i2865", "i2866", "i2885", "i2867", "i2920"
│       │   │   48 │         };
│       │   │   49 │ 
│       │   │   50 │         // Static collections for bytecode identification and reserved types
│       │   │   51 │         private static readonly HashSet<string> ByteCodeTypes = new HashSet<string>
│       │   │   52 │         {
│       │   │   53 │             "InfinityProgram",
│       │   │   54 │             "InfinityFunction"
│       │   │   55 │         };
│       │   │   56 │ 
│       │   │   57 │         private static readonly HashSet<string> ReservedTypes = new HashSet<string>
│       │   │   58 │         {
│       │   │   59 │             "InfinitySystemVariable",
│       │   │   60 │             "Group"
│       │   │   61 │         };
│       │   │   62 │ 
│       │   │   63 │         /// <summary>
│       │   │   64 │         /// Creates a new parsing service
│       │   │   65 │         /// </summary>
│       │   │   66 │         /// <param name="controllerRepository">The controller repository</param>
│       │   │   67 │         /// <param name="fileSystem">The file system</param>
│       │   │   68 │         /// <param name="errorHandler">The error handler</param>
│       │   │   69 │         /// <param name="logger">The logger</param>
│       │   │   70 │         // Update the constructor:
│       │   │   71 │         public ParsingService(
│       │   │   72 │             IControllerRepository controllerRepository,
│       │   │   73 │             IFileSystem fileSystem,
│       │   │   74 │             IErrorHandler errorHandler,
│       │   │   75 │             ILogger<ParsingService> logger,
│       │   │   76 │             IServiceProvider serviceProvider)  // Add this parameter
│       │   │   77 │         {
│       │   │   78 │             _controllerRepository = controllerRepository ?? throw new ArgumentNullException(nameof(controllerRepository));
│       │   │   79 │             _fileSystem = fileSystem ?? throw new ArgumentNullException(nameof(fileSystem));
│       │   │   80 │             _errorHandler = errorHandler ?? throw new ArgumentNullException(nameof(errorHandler));
│       │   │   81 │             _logger = logger ?? throw new ArgumentNullException(nameof(logger));
│       │   │   82 │             _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));
│       │   │   83 │         }
│       │   │   84 │ 
│       │   │   85 │         /// <summary>
│       │   │   86 │         /// Parses a file and saves the controllers to the repository
│       │   │   87 │         /// </summary>
│       │   │   88 │         /// <param name="filePath">The file path</param>
│       │   │   89 │         /// <param name="options">The parsing options</param>
│       │   │   90 │         /// <returns>The session ID and the number of controllers parsed</returns>
│       │   │   91 │         public async Task<(string SessionId, int ControllerCount)> ParseFileAsync(string filePath, ParsingOptions options = null)
│       │   │   92 │         {
│       │   │   93 │             return await _errorHandler.WithTimingAsync(async () =>
│       │   │   94 │             {
│       │   │   95 │                 if (!_fileSystem.FileExists(filePath))
│       │   │   96 │                     throw new ParsingException($"File not found: {filePath}", filePath);
│       │   │   97 │ 
│       │   │   98 │                 options ??= new ParsingOptions();
│       │   │   99 │                 _logger.LogInformation("Parsing file {FilePath} with options: {Options}", filePath, options);
│       │   │  100 │ 
│       │   │  101 │                 // Read the file content
│       │   │  102 │                 string content = await _fileSystem.ReadAllTextAsync(filePath);
│       │   │  103 │                 if (string.IsNullOrWhiteSpace(content))
│       │   │  104 │                     throw new ParsingException("File is empty", filePath);
│       │   │  105 │ 
│       │   │  106 │                 // Determine the file type based on extension
│       │   │  107 │                 string extension = Path.GetExtension(filePath).ToLowerInvariant();
│       │   │  108 │                 var controllers = extension switch
│       │   │  109 │                 {
│       │   │  110 │                     ".dmp" => ParseDmpFile(content, options),
│       │   │  111 │                     ".xml" => await ParseXmlFile(content, options),
│       │   │  112 │                     _ => throw new ParsingException($"Unsupported file type: {extension}", filePath)
│       │   │  113 │                 };
│       │   │  114 │ 
│       │   │  115 │                 if (controllers.Count == 0)
│       │   │  116 │                     throw new ParsingException("No controllers found in file", filePath);
│       │   │  117 │ 
│       │   │  118 │                 _logger.LogInformation("Parsed {ControllerCount} controllers from {FilePath}", controllers.Count, filePath);
│       │   │  119 │ 
│       │   │  120 │                 // Generate a session prefix if project ID is provided
│       │   │  121 │                 string sessionPrefix = null;
│       │   │  122 │                 if (!string.IsNullOrEmpty(options.ProjectId))
│       │   │  123 │                 {
│       │   │  124 │                     sessionPrefix = $"project_{options.ProjectId}_";
│       │   │  125 │                 }
│       │   │  126 │ 
│       │   │  127 │                 // Save to repository
│       │   │  128 │                 string sessionId = await _controllerRepository.SaveControllerBatchAsync(controllers, filePath, sessionPrefix);
│       │   │  129 │                 return (sessionId, controllers.Count);
│       │   │  130 │             }, "ParseFile");
│       │   │  131 │         }
│       │   │  132 │ 
│       │   │  133 │         /// <summary>
│       │   │  134 │         /// Parses multiple files for a project
│       │   │  135 │         /// </summary>
│       │   │  136 │         /// <param name="projectId">The project ID</param>
│       │   │  137 │         /// <param name="filePaths">The file paths</param>
│       │   │  138 │         /// <param name="options">The parsing options</param>
│       │   │  139 │         /// <returns>A list of parsing results</returns>
│       │   │  140 │         public async Task<List<ParsingResult>> ParseProjectFilesAsync(string projectId, IEnumerable<string> filePaths, ParsingOptions options = null)
│       │   │  141 │         {
│       │   │  142 │             var results = new List<ParsingResult>();
│       │   │  143 │             options ??= new ParsingOptions { ProjectId = projectId };
│       │   │  144 │             options.ProjectId = projectId; // Ensure project ID is set
│       │   │  145 │ 
│       │   │  146 │             foreach (var filePath in filePaths)
│       │   │  147 │             {
│       │   │  148 │                 try
│       │   │  149 │                 {
│       │   │  150 │                     var (sessionId, controllerCount) = await ParseFileAsync(filePath, options);
│       │   │  151 │                     results.Add(new ParsingResult
│       │   │  152 │                     {
│       │   │  153 │                         FilePath = filePath,
│       │   │  154 │                         FileName = Path.GetFileName(filePath),
│       │   │  155 │                         Success = true,
│       │   │  156 │                         SessionId = sessionId,
│       │   │  157 │                         ControllerCount = controllerCount
│       │   │  158 │                     });
│       │   │  159 │                 }
│       │   │  160 │                 catch (Exception ex)
│       │   │  161 │                 {
│       │   │  162 │                     _errorHandler.HandleException(ex, "ParseProjectFiles");
│       │   │  163 │                     results.Add(new ParsingResult
│       │   │  164 │                     {
│       │   │  165 │                         FilePath = filePath,
│       │   │  166 │                         FileName = Path.GetFileName(filePath),
│       │   │  167 │                         Success = false,
│       │   │  168 │                         ErrorMessage = ex.Message
│       │   │  169 │                     });
│       │   │  170 │                 }
│       │   │  171 │             }
│       │   │  172 │ 
│       │   │  173 │             return results;
│       │   │  174 │         }
│       │   │  175 │ 
│       │   │  176 │         /// <summary>
│       │   │  177 │         /// Groups controllers based on their signature
│       │   │  178 │         /// </summary>
│       │   │  179 │         /// <param name="controllers">The controllers to group</param>
│       │   │  180 │         /// <param name="nameTemplate">Optional name replacement template</param>
│       │   │  181 │         /// <returns>A list of controller groups</returns>
│       │   │  182 │         public List<ControllerGroup> CreateControllerGroups(IEnumerable<Controller> controllers, NameReplacementTemplate nameTemplate = null)
│       │   │  183 │         {
│       │   │  184 │             _logger.LogInformation("Creating controller groups from {ControllerCount} controllers", controllers.Count());
│       │   │  185 │ 
│       │   │  186 │             var groups = new Dictionary<string, ControllerGroup>();
│       │   │  187 │ 
│       │   │  188 │             foreach (var controller in controllers)
│       │   │  189 │             {
│       │   │  190 │                 // Compute a signature for the controller
│       │   │  191 │                 var signature = ComputeControllerSignature(controller);
│       │   │  192 │ 
│       │   │  193 │                 // Look for an existing group with the same signature
│       │   │  194 │                 if (!groups.TryGetValue(signature, out var group))
│       │   │  195 │                 {
│       │   │  196 │                     group = new ControllerGroup(signature);
│       │   │  197 │                     groups[signature] = group;
│       │   │  198 │                 }
│       │   │  199 │ 
│       │   │  200 │                 // Add controller to group
│       │   │  201 │                 group.ControllerNames.Add(controller.Name);
│       │   │  202 │ 
│       │   │  203 │                 // Extract values with name replacements
│       │   │  204 │                 ExtractControllerValuesWithProcessing(
│       │   │  205 │                     controller.Objects,
│       │   │  206 │                     group.OriginalValues,
│       │   │  207 │                     group.SharedValues,
│       │   │  208 │                     group.NameMapping,
│       │   │  209 │                     nameTemplate?.Replacements);
│       │   │  210 │             }
│       │   │  211 │ 
│       │   │  212 │             return groups.Values.ToList();
│       │   │  213 │         }
│       │   │  214 │ 
│       │   │  215 │         /// <summary>
│       │   │  216 │         /// Extracts available types from controllers
│       │   │  217 │         /// </summary>
│       │   │  218 │         /// <param name="controllers">The controllers to examine</param>
│       │   │  219 │         /// <returns>A set of type names</returns>
│       │   │  220 │         public HashSet<string> GetAvailableTypes(IEnumerable<Controller> controllers)
│       │   │  221 │         {
│       │   │  222 │             var types = new HashSet<string>();
│       │   │  223 │ 
│       │   │  224 │             foreach (var controller in controllers)
│       │   │  225 │             {
│       │   │  226 │                 foreach (var obj in controller.Objects)
│       │   │  227 │                 {
│       │   │  228 │                     ExtractTypes(obj, types);
│       │   │  229 │                 }
│       │   │  230 │             }
│       │   │  231 │ 
│       │   │  232 │             return types;
│       │   │  233 │         }
│       │   │  234 │ 
│       │   │  235 │         /// <summary>
│       │   │  236 │         /// Applies filtering to controllers
│       │   │  237 │         /// </summary>
│       │   │  238 │         /// <param name="controllers">The controllers to filter</param>
│       │   │  239 │         /// <param name="options">The filter options</param>
│       │   │  240 │         /// <returns>A filtered list of controllers</returns>
│       │   │  241 │         public List<Controller> FilterControllers(IEnumerable<Controller> controllers, FilterOptions options)
│       │   │  242 │         {
│       │   │  243 │             _logger.LogInformation("Filtering controllers with options: {Options}", options);
│       │   │  244 │ 
│       │   │  245 │             if (controllers == null || !controllers.Any())
│       │   │  246 │                 return new List<Controller>();
│       │   │  247 │ 
│       │   │  248 │             var result = new List<Controller>();
│       │   │  249 │ 
│       │   │  250 │             foreach (var controller in controllers)
│       │   │  251 │             {
│       │   │  252 │                 // Create a new controller with filtered objects
│       │   │  253 │                 var filteredObjects = FilterObjects(
│       │   │  254 │                     controller.Objects,
│       │   │  255 │                     options.IncludedTypes,
│       │   │  256 │                     options.NameFilters,
│       │   │  257 │                     options.IsWhitelist,
│       │   │  258 │                     options.IgnoreEmptyValues,
│       │   │  259 │                     options.IncludeByteCode);
│       │   │  260 │ 
│       │   │  261 │                 if (filteredObjects.Any())
│       │   │  262 │                 {
│       │   │  263 │                     // Create a new controller with filtered objects
│       │   │  264 │                     var newController = new Controller(controller.Name, controller.Model);
│       │   │  265 │ 
│       │   │  266 │                     // Copy properties
│       │   │  267 │                     foreach (var prop in controller.Properties)
│       │   │  268 │                     {
│       │   │  269 │                         newController.SetProperty(prop.Key, prop.Value);
│       │   │  270 │                     }
│       │   │  271 │ 
│       │   │  272 │                     // Set connection info
│       │   │  273 │                     newController.SetConnectionInfo(
│       │   │  274 │                         controller.Port,
│       │   │  275 │                         controller.SerialNumber,
│       │   │  276 │                         controller.InfinetId);
│       │   │  277 │ 
│       │   │  278 │                     // Add filtered objects
│       │   │  279 │                     foreach (var obj in filteredObjects)
│       │   │  280 │                     {
│       │   │  281 │                         newController.AddObject(obj);
│       │   │  282 │                     }
│       │   │  283 │ 
│       │   │  284 │                     result.Add(newController);
│       │   │  285 │                 }
│       │   │  286 │             }
│       │   │  287 │ 
│       │   │  288 │             return result;
│       │   │  289 │         }
│       │   │  290 │ 
│       │   │  291 │         #region DMP File Parsing
│       │   │  292 │ 
│       │   │  293 │         /// <summary>
│       │   │  294 │         /// Parses a DMP file
│       │   │  295 │         /// </summary>
│       │   │  296 │         /// <param name="content">The file content</param>
│       │   │  297 │         /// <param name="options">The parsing options</param>
│       │   │  298 │         /// <returns>A list of controllers</returns>
│       │   │  299 │         private List<Controller> ParseDmpFile(string content, ParsingOptions options)
│       │   │  300 │         {
│       │   │  301 │             _logger.LogInformation("Parsing DMP file content ({ContentLength} bytes) with options: {Options}",
│       │   │  302 │                 content?.Length ?? 0, options);
│       │   │  303 │ 
│       │   │  304 │             var controllers = new List<Controller>();
│       │   │  305 │             var dictionaryEntries = new Dictionary<string, Dictionary<string, string>>();
│       │   │  306 │             Dictionary<int, string> currentColumnMap = null;
│       │   │  307 │ 
│       │   │  308 │             using (var reader = new StringReader(content))
│       │   │  309 │             {
│       │   │  310 │                 // First pass: Read dictionary entries
│       │   │  311 │                 string line;
│       │   │  312 │                 bool inDictionary = false;
│       │   │  313 │                 string currentDictionaryName = null;
│       │   │  314 │ 
│       │   │  315 │                 while ((line = reader.ReadLine()) != null)
│       │   │  316 │                 {
│       │   │  317 │                     line = line.Trim();
│       │   │  318 │ 
│       │   │  319 │                     // Check for dictionary start
│       │   │  320 │                     if (line.StartsWith("Dictionary : "))
│       │   │  321 │                     {
│       │   │  322 │                         inDictionary = true;
│       │   │  323 │                         currentDictionaryName = line.Substring("Dictionary : ".Length).Trim();
│       │   │  324 │                         continue;
│       │   │  325 │                     }
│       │   │  326 │ 
│       │   │  327 │                     // Check for dictionary end
│       │   │  328 │                     if (line == "EndDictionary")
│       │   │  329 │                     {
│       │   │  330 │                         inDictionary = false;
│       │   │  331 │                         currentDictionaryName = null;
│       │   │  332 │                         currentColumnMap = null;
│       │   │  333 │                         continue;
│       │   │  334 │                     }
│       │   │  335 │ 
│       │   │  336 │                     if (!inDictionary) continue;
│       │   │  337 │ 
│       │   │  338 │                     // Update column map when we find a type header
│       │   │  339 │                     if (line.StartsWith("'TYPE"))
│       │   │  340 │                     {
│       │   │  341 │                         currentColumnMap = ParseColumnHeaders(line);
│       │   │  342 │                         continue;
│       │   │  343 │                     }
│       │   │  344 │ 
│       │   │  345 │                     // Parse InfinityInfinetCtlr entries using current column map
│       │   │  346 │                     if (line.StartsWith("InfinityInfinetCtlr") && currentColumnMap != null)
│       │   │  347 │                     {
│       │   │  348 │                         var parts = line.Split(new[] { ':' }, StringSplitOptions.RemoveEmptyEntries)
│       │   │  349 │                             .Select(p => p.Trim())
│       │   │  350 │                             .ToArray();
│       │   │  351 │ 
│       │   │  352 │                         if (parts.Length >= currentColumnMap.Count)
│       │   │  353 │                         {
│       │   │  354 │                             var properties = new Dictionary<string, string>();
│       │   │  355 │ 
│       │   │  356 │                             // Use current column map to create properties
│       │   │  357 │                             for (int i = 0; i < parts.Length && i < currentColumnMap.Count; i++)
│       │   │  358 │                             {
│       │   │  359 │                                 if (i != 1) // Skip NAME as it's used as the key
│       │   │  360 │                                 {
│       │   │  361 │                                     string columnName = currentColumnMap[i];
│       │   │  362 │                                     string value = parts[i];
│       │   │  363 │ 
│       │   │  364 │                                     // Only add non-empty values
│       │   │  365 │                                     if (!string.IsNullOrWhiteSpace(value) && value != "False")
│       │   │  366 │                                     {
│       │   │  367 │                                         properties[columnName] = value;
│       │   │  368 │                                     }
│       │   │  369 │                                 }
│       │   │  370 │                             }
│       │   │  371 │ 
│       │   │  372 │                             // Add the dictionary name as a property
│       │   │  373 │                             if (!string.IsNullOrWhiteSpace(currentDictionaryName))
│       │   │  374 │                             {
│       │   │  375 │                                 properties["DictionaryName"] = currentDictionaryName;
│       │   │  376 │                             }
│       │   │  377 │ 
│       │   │  378 │                             // Determine and add controller family if we have a model
│       │   │  379 │                             if (properties.TryGetValue("Model", out string modelNumber))
│       │   │  380 │                             {
│       │   │  381 │                                 var family = DetermineControllerFamily(modelNumber);
│       │   │  382 │                                 properties["ControllerFamily"] = family.ToString();
│       │   │  383 │                             }
│       │   │  384 │ 
│       │   │  385 │                             dictionaryEntries[parts[1]] = properties; // Use NAME column value as key
│       │   │  386 │                         }
│       │   │  387 │                     }
│       │   │  388 │                 }
│       │   │  389 │             }
│       │   │  390 │ 
│       │   │  391 │             // Create controller objects from dictionary entries
│       │   │  392 │             foreach (var entry in dictionaryEntries)
│       │   │  393 │             {
│       │   │  394 │                 var controller = new Controller(entry.Key, entry.Value.GetValueOrDefault("Model", "Unknown"));
│       │   │  395 │ 
│       │   │  396 │                 // Copy all other properties
│       │   │  397 │                 foreach (var prop in entry.Value)
│       │   │  398 │                 {
│       │   │  399 │                     controller.SetProperty(prop.Key, prop.Value);
│       │   │  400 │                 }
│       │   │  401 │ 
│       │   │  402 │                 // Set connection info if available
│       │   │  403 │                 controller.SetConnectionInfo(
│       │   │  404 │                     entry.Value.GetValueOrDefault("Port", ""),
│       │   │  405 │                     entry.Value.GetValueOrDefault("SerialNumber", ""),
│       │   │  406 │                     entry.Value.GetValueOrDefault("InfinetId", "")
│       │   │  407 │                 );
│       │   │  408 │ 
│       │   │  409 │                 controllers.Add(controller);
│       │   │  410 │             }
│       │   │  411 │ 
│       │   │  412 │             // Second pass: Process controller contents (objects, etc.)
│       │   │  413 │             using (var reader = new StringReader(content))
│       │   │  414 │             {
│       │   │  415 │                 string line;
│       │   │  416 │                 Controller currentController = null;
│       │   │  417 │                 Stack<ControllerObject> objectStack = new Stack<ControllerObject>();
│       │   │  418 │ 
│       │   │  419 │                 while ((line = reader.ReadLine()) != null)
│       │   │  420 │                 {
│       │   │  421 │                     line = line.Trim();
│       │   │  422 │ 
│       │   │  423 │                     if (string.IsNullOrWhiteSpace(line) || line.StartsWith("'"))
│       │   │  424 │                         continue;
│       │   │  425 │ 
│       │   │  426 │                     if (line.StartsWith("InfinetCtlr :"))
│       │   │  427 │                     {
│       │   │  428 │                         var controllerName = line.Substring("InfinetCtlr :".Length).Trim();
│       │   │  429 │                         currentController = controllers.FirstOrDefault(c => c.Name == controllerName);
│       │   │  430 │                         continue;
│       │   │  431 │                     }
│       │   │  432 │ 
│       │   │  433 │                     // Controller end
│       │   │  434 │                     if (line == "EndInfinetCtlr")
│       │   │  435 │                     {
│       │   │  436 │                         currentController = null;
│       │   │  437 │                         objectStack.Clear();
│       │   │  438 │                         continue;
│       │   │  439 │                     }
│       │   │  440 │ 
│       │   │  441 │                     // Only process objects if we're in a controller section
│       │   │  442 │                     if (currentController == null)
│       │   │  443 │                         continue;
│       │   │  444 │ 
│       │   │  445 │                     // Object start
│       │   │  446 │                     if (line.StartsWith("Object :"))
│       │   │  447 │                     {
│       │   │  448 │                         var objName = line.Substring("Object :".Length).Trim();
│       │   │  449 │                         var newObject = new ControllerObject("Unknown", objName);
│       │   │  450 │ 
│       │   │  451 │                         if (objectStack.Count == 0)
│       │   │  452 │                         {
│       │   │  453 │                             // Top-level object
│       │   │  454 │                             currentController.AddObject(newObject);
│       │   │  455 │                         }
│       │   │  456 │                         else
│       │   │  457 │                         {
│       │   │  458 │                             // Child object
│       │   │  459 │                             objectStack.Peek().AddChild(newObject);
│       │   │  460 │                         }
│       │   │  461 │                         objectStack.Push(newObject);
│       │   │  462 │                         continue;
│       │   │  463 │                     }
│       │   │  464 │ 
│       │   │  465 │                     // Object end
│       │   │  466 │                     if (line == "EndObject" && objectStack.Count > 0)
│       │   │  467 │                     {
│       │   │  468 │                         objectStack.Pop();
│       │   │  469 │                         continue;
│       │   │  470 │                     }
│       │   │  471 │ 
│       │   │  472 │                     // Process properties
│       │   │  473 │                     if (objectStack.Count > 0 && line.Contains(" :"))
│       │   │  474 │                     {
│       │   │  475 │                         var parts = line.Split(new[] { " :" }, StringSplitOptions.None);
│       │   │  476 │                         if (parts.Length == 2)
│       │   │  477 │                         {
│       │   │  478 │                             var key = parts[0].Trim();
│       │   │  479 │                             var value = parts[1].Trim();
│       │   │  480 │ 
│       │   │  481 │                             var currentObject = objectStack.Peek();
│       │   │  482 │ 
│       │   │  483 │                             switch (key.ToLower())
│       │   │  484 │                             {
│       │   │  485 │                                 case "type":
│       │   │  486 │                                     // We need to replace the object since Type is immutable
│       │   │  487 │                                     var replacement = new ControllerObject(value, currentObject.Name, currentObject.Value);
│       │   │  488 │ 
│       │   │  489 │                                     // Copy all properties
│       │   │  490 │                                     if (currentObject.Alias != null)
│       │   │  491 │                                         replacement.SetAlias(currentObject.Alias);
│       │   │  492 │ 
│       │   │  493 │                                     foreach (var prop in currentObject.Properties)
│       │   │  494 │                                         replacement.SetProperty(prop.Key, prop.Value);
│       │   │  495 │ 
│       │   │  496 │                                     // Copy children
│       │   │  497 │                                     foreach (var child in currentObject.Children)
│       │   │  498 │                                         replacement.AddChild(child);
│       │   │  499 │ 
│       │   │  500 │                                     // Replace in parent or controller
│       │   │  501 │                                     if (objectStack.Count > 1)
│       │   │  502 │                                     {
│       │   │  503 │                                         var parentObject = objectStack.ElementAt(1);
│       │   │  504 │                                         // Remove old and add new - requires recreating the children list
│       │   │  505 │                                         // This is a limitation of the domain model design that type is immutable
│       │   │  506 │                                         var newChildren = parentObject.Children.Where(c => c != currentObject).ToList();
│       │   │  507 │                                         newChildren.Add(replacement);
│       │   │  508 │ 
│       │   │  509 │                                         // This would ideally use a ReplaceChild method on the domain model
│       │   │  510 │                                         // but we need to work with what we have
│       │   │  511 │                                     }
│       │   │  512 │                                     else
│       │   │  513 │                                     {
│       │   │  514 │                                         // Remove from controller and add back
│       │   │  515 │                                         currentController.RemoveObject(currentObject.Name);
│       │   │  516 │                                         currentController.AddObject(replacement);
│       │   │  517 │                                     }
│       │   │  518 │ 
│       │   │  519 │                                     // Update stack
│       │   │  520 │                                     objectStack.Pop();
│       │   │  521 │                                     objectStack.Push(replacement);
│       │   │  522 │ 
│       │   │  523 │                                     break;
│       │   │  524 │ 
│       │   │  525 │                                 case "alias":
│       │   │  526 │                                     currentObject.SetAlias(value);
│       │   │  527 │                                     break;
│       │   │  528 │ 
│       │   │  529 │                                 case "value":
│       │   │  530 │                                     currentObject.UpdateValue(value);
│       │   │  531 │                                     break;
│       │   │  532 │ 
│       │   │  533 │                                 case "bytecode":
│       │   │  534 │                                     if (options.IncludeByteCode)
│       │   │  535 │                                     {
│       │   │  536 │                                         var byteCodeContent = new StringBuilder();
│       │   │  537 │                                         string nextLine;
│       │   │  538 │ 
│       │   │  539 │                                         while ((nextLine = reader.ReadLine()) != null)
│       │   │  540 │                                         {
│       │   │  541 │                                             nextLine = nextLine.TrimEnd();
│       │   │  542 │                                             if (nextLine.Contains("EndByteCode"))
│       │   │  543 │                                             {
│       │   │  544 │                                                 break;
│       │   │  545 │                                             }
│       │   │  546 │ 
│       │   │  547 │                                             // Add the content line
│       │   │  548 │                                             byteCodeContent.AppendLine(nextLine);
│       │   │  549 │ 
│       │   │  550 │                                             // Skip the next line (empty line)
│       │   │  551 │                                             reader.ReadLine();
│       │   │  552 │                                         }
│       │   │  553 │ 
│       │   │  554 │                                         currentObject.UpdateValue(byteCodeContent.ToString());
│       │   │  555 │                                         currentObject.SetHasByteCode(true);
│       │   │  556 │                                     }
│       │   │  557 │                                     else
│       │   │  558 │                                     {
│       │   │  559 │                                         // Skip bytecode if not including it
│       │   │  560 │                                         SkipUntil(reader, "EndByteCode");
│       │   │  561 │                                         currentObject.SetHasByteCode(true);
│       │   │  562 │                                     }
│       │   │  563 │                                     break;
│       │   │  564 │ 
│       │   │  565 │                                 case "triggers":
│       │   │  566 │                                     SkipUntil(reader, "EndOfCDT");
│       │   │  567 │                                     break;
│       │   │  568 │ 
│       │   │  569 │                                 case "panelobjectlist":
│       │   │  570 │                                     SkipUntil(reader, "}");
│       │   │  571 │                                     break;
│       │   │  572 │ 
│       │   │  573 │                                 case "alarmlinks":
│       │   │  574 │                                     SkipUntil(reader, "EndAlarmLinks");
│       │   │  575 │                                     break;
│       │   │  576 │ 
│       │   │  577 │                                 default:
│       │   │  578 │                                     // Store all other properties
│       │   │  579 │                                     if (!key.StartsWith("EndOf") && !key.StartsWith("Begin"))
│       │   │  580 │                                     {
│       │   │  581 │                                         currentObject.SetProperty(key, value);
│       │   │  582 │                                     }
│       │   │  583 │                                     break;
│       │   │  584 │                             }
│       │   │  585 │                         }
│       │   │  586 │                     }
│       │   │  587 │                 }
│       │   │  588 │             }
│       │   │  589 │ 
│       │   │  590 │             // Apply filtering based on options
│       │   │  591 │             if (options.TypeWhitelist.Count > 0 || options.NameFilters.Count > 0 || options.IgnoreEmptyValues)
│       │   │  592 │             {
│       │   │  593 │                 controllers = FilterControllers(controllers, new FilterOptions
│       │   │  594 │                 {
│       │   │  595 │                     IncludeByteCode = options.IncludeByteCode,
│       │   │  596 │                     IgnoreEmptyValues = options.IgnoreEmptyValues,
│       │   │  597 │                     IncludedTypes = options.TypeWhitelist,
│       │   │  598 │                     NameFilters = options.NameFilters,
│       │   │  599 │                     IsWhitelist = options.IsWhitelist
│       │   │  600 │                 });
│       │   │  601 │             }
│       │   │  602 │ 
│       │   │  603 │             return controllers;
│       │   │  604 │         }
│       │   │  605 │ 
│       │   │  606 │         /// <summary>
│       │   │  607 │         /// Parses column headers from a DMP file
│       │   │  608 │         /// </summary>
│       │   │  609 │         private Dictionary<int, string> ParseColumnHeaders(string headerLine)
│       │   │  610 │         {
│       │   │  611 │             var columnMap = new Dictionary<int, string>();
│       │   │  612 │             var columns = headerLine.Substring(1).Split(new[] { ':' }, StringSplitOptions.RemoveEmptyEntries)
│       │   │  613 │                 .Select(c => c.Trim())
│       │   │  614 │                 .ToArray();
│       │   │  615 │ 
│       │   │  616 │             for (int i = 0; i < columns.Length; i++)
│       │   │  617 │             {
│       │   │  618 │                 // Clean up the column names and store them
│       │   │  619 │                 string columnName = columns[i].Trim();
│       │   │  620 │ 
│       │   │  621 │                 // Handle special cases in column names
│       │   │  622 │                 switch (columnName)
│       │   │  623 │                 {
│       │   │  624 │                     case "SERIALNUM":
│       │   │  625 │                         columnName = "SerialNumber";
│       │   │  626 │                         break;
│       │   │  627 │                     case "INFINETID":
│       │   │  628 │                         columnName = "InfinetId";
│       │   │  629 │                         break;
│       │   │  630 │                     default:
│       │   │  631 │                         // Convert to proper case and remove spaces
│       │   │  632 │                         columnName = string.Concat(columnName.Split(' ')
│       │   │  633 │                             .Select(word => char.ToUpper(word[0]) + word.Substring(1).ToLower()));
│       │   │  634 │                         break;
│       │   │  635 │                 }
│       │   │  636 │ 
│       │   │  637 │                 columnMap[i] = columnName;
│       │   │  638 │             }
│       │   │  639 │ 
│       │   │  640 │             return columnMap;
│       │   │  641 │         }
│       │   │  642 │ 
│       │   │  643 │         /// <summary>
│       │   │  644 │         /// Skips lines in a reader until a marker is found
│       │   │  645 │         /// </summary>
│       │   │  646 │         private void SkipUntil(StringReader reader, string endMarker)
│       │   │  647 │         {
│       │   │  648 │             string line;
│       │   │  649 │             while ((line = reader.ReadLine()) != null)
│       │   │  650 │             {
│       │   │  651 │                 if (line.Trim().Contains(endMarker))
│       │   │  652 │                     break;
│       │   │  653 │             }
│       │   │  654 │         }
│       │   │  655 │ 
│       │   │  656 │         #endregion
│       │   │  657 │ 
│       │   │  658 │         #region XML File Parsing
│       │   │  659 │ 
│       │   │  660 │         /// <summary>
│       │   │  661 │         /// Parses an XML file
│       │   │  662 │         /// </summary>
│       │   │  663 │         /// <param name="content">The file content</param>
│       │   │  664 │         /// <param name="options">The parsing options</param>
│       │   │  665 │         /// <returns>A list of controllers</returns>
│       │   │  666 │         private async Task<List<Controller>> ParseXmlFile(string content, ParsingOptions options)
│       │   │  667 │         {
│       │   │  668 │             _logger.LogInformation("Parsing XML file content ({ContentLength} bytes) with options: {Options}",
│       │   │  669 │                 content?.Length ?? 0, options);
│       │   │  670 │ 
│       │   │  671 │             var controllers = new List<Controller>();
│       │   │  672 │ 
│       │   │  673 │             try
│       │   │  674 │             {
│       │   │  675 │                 var doc = XDocument.Parse(content);
│       │   │  676 │ 
│       │   │  677 │                 // Look for different possible root elements
│       │   │  678 │                 if (doc.Root?.Name.LocalName == "InfinityControllers" ||
│       │   │  679 │                     doc.Root?.Name.LocalName == "Controllers")
│       │   │  680 │                 {
│       │   │  681 │                     // Parse PaapeConversionKit export format
│       │   │  682 │                     foreach (var controllerElement in doc.Root.Elements("Controller"))
│       │   │  683 │                     {
│       │   │  684 │                         var name = controllerElement.Attribute("Name")?.Value;
│       │   │  685 │                         if (string.IsNullOrEmpty(name))
│       │   │  686 │                             continue;
│       │   │  687 │ 
│       │   │  688 │                         var model = controllerElement.Attribute("Model")?.Value ?? "Unknown";
│       │   │  689 │                         var controller = new Controller(name, model);
│       │   │  690 │ 
│       │   │  691 │                         // Set connection info
│       │   │  692 │                         controller.SetConnectionInfo(
│       │   │  693 │                             controllerElement.Attribute("Port")?.Value ?? "",
│       │   │  694 │                             controllerElement.Attribute("SerialNumber")?.Value ?? "",
│       │   │  695 │                             controllerElement.Attribute("InfinetId")?.Value ?? ""
│       │   │  696 │                         );
│       │   │  697 │ 
│       │   │  698 │                         // Process properties
│       │   │  699 │                         var propertiesElement = controllerElement.Element("Properties");
│       │   │  700 │                         if (propertiesElement != null)
│       │   │  701 │                         {
│       │   │  702 │                             foreach (var propElement in propertiesElement.Elements("Property"))
│       │   │  703 │                             {
│       │   │  704 │                                 var key = propElement.Attribute("Key")?.Value ??
│       │   │  705 │                                           propElement.Attribute("Name")?.Value;
│       │   │  706 │                                 var value = propElement.Attribute("Value")?.Value;
│       │   │  707 │ 
│       │   │  708 │                                 if (!string.IsNullOrEmpty(key))
│       │   │  709 │                                 {
│       │   │  710 │                                     controller.SetProperty(key, value ?? "");
│       │   │  711 │                                 }
│       │   │  712 │                             }
│       │   │  713 │                         }
│       │   │  714 │ 
│       │   │  715 │                         // Process objects
│       │   │  716 │                         var objectsElement = controllerElement.Element("Objects");
│       │   │  717 │                         if (objectsElement != null)
│       │   │  718 │                         {
│       │   │  719 │                             foreach (var objElement in objectsElement.Elements("Object"))
│       │   │  720 │                             {
│       │   │  721 │                                 var obj = ParseXmlObject(objElement, options.IncludeByteCode);
│       │   │  722 │                                 if (obj != null)
│       │   │  723 │                                 {
│       │   │  724 │                                     controller.AddObject(obj);
│       │   │  725 │                                 }
│       │   │  726 │                             }
│       │   │  727 │                         }
│       │   │  728 │ 
│       │   │  729 │                         controllers.Add(controller);
│       │   │  730 │                     }
│       │   │  731 │                 }
│       │   │  732 │                 else if (doc.Root?.Name.LocalName == "ObjectSet")
│       │   │  733 │                 {
│       │   │  734 │                     // Use specialized ObjectSet parser
│       │   │  735 │                     var objectSetParser = _serviceProvider.GetRequiredService<IObjectSetParser>();
│       │   │  736 │ 
│       │   │  737 │                     // Configure ObjectSet parsing options
│       │   │  738 │                     var objectSetOptions = new ObjectSetParsingOptions
│       │   │  739 │                     {
│       │   │  740 │                         IncludeMetaInformation = true,
│       │   │  741 │                         IncludeTypeDefinitions = options.TypeWhitelist.Count > 0,
│       │   │  742 │                         IncludeExportedObjects = true,
│       │   │  743 │                         TypeWhitelist = options.TypeWhitelist
│       │   │  744 │                     };
│       │   │  745 │ 
│       │   │  746 │                     // Parse the ObjectSet document
│       │   │  747 │                     var parseResult = await objectSetParser.ParseAsync(doc, objectSetOptions);
│       │   │  748 │ 
│       │   │  749 │                     if (!parseResult.Success)
│       │   │  750 │                     {
│       │   │  751 │                         throw new ParsingException($"Failed to parse ObjectSet XML: {parseResult.ErrorMessage}", "ObjectSet");
│       │   │  752 │                     }
│       │   │  753 │ 
│       │   │  754 │                     // Extract controllers from exported objects
│       │   │  755 │                     if (parseResult.ExportedObjects != null)
│       │   │  756 │                     {
│       │   │  757 │                         // Find controller elements (top-level only)
│       │   │  758 │                         var controllerObjects = parseResult.ExportedObjects
│       │   │  759 │                             .Where(e => e.Properties.TryGetValue("TYPE", out var type) &&
│       │   │  760 │                                         (type == "InfinityInfinetCtlr" || type == "Controller"));
│       │   │  761 │ 
│       │   │  762 │                         foreach (var controllerObj in controllerObjects)
│       │   │  763 │                         {
│       │   │  764 │                             var controllerName = controllerObj.Name;
│       │   │  765 │                             if (string.IsNullOrEmpty(controllerName))
│       │   │  766 │                                 continue;
│       │   │  767 │ 
│       │   │  768 │                             // Get model from properties if available
│       │   │  769 │                             string model = "Unknown";
│       │   │  770 │                             controllerObj.Properties.TryGetValue("Model", out model);
│       │   │  771 │ 
│       │   │  772 │                             var controller = new Controller(controllerName, model);
│       │   │  773 │ 
│       │   │  774 │                             // Add properties
│       │   │  775 │                             foreach (var prop in controllerObj.Properties)
│       │   │  776 │                             {
│       │   │  777 │                                 controller.SetProperty(prop.Key, prop.Value);
│       │   │  778 │ 
│       │   │  779 │                                 // Check for special properties
│       │   │  780 │                                 if (prop.Key == "SerialNumber")
│       │   │  781 │                                 {
│       │   │  782 │                                     controller.SetConnectionInfo(controller.Port, prop.Value, controller.InfinetId);
│       │   │  783 │                                 }
│       │   │  784 │                                 else if (prop.Key == "InfinetId")
│       │   │  785 │                                 {
│       │   │  786 │                                     controller.SetConnectionInfo(controller.Port, controller.SerialNumber, prop.Value);
│       │   │  787 │                                 }
│       │   │  788 │                                 else if (prop.Key == "Port")
│       │   │  789 │                                 {
│       │   │  790 │                                     controller.SetConnectionInfo(prop.Value, controller.SerialNumber, controller.InfinetId);
│       │   │  791 │                                 }
│       │   │  792 │                             }
│       │   │  793 │ 
│       │   │  794 │                             // Process all children recursively
│       │   │  795 │                             foreach (var childObj in controllerObj.Children)
│       │   │  796 │                             {
│       │   │  797 │                                 ProcessObjectSetChild(childObj, controller, null, options.IncludeByteCode);
│       │   │  798 │                             }
│       │   │  799 │ 
│       │   │  800 │                             controllers.Add(controller);
│       │   │  801 │                         }
│       │   │  802 │                     }
│       │   │  803 │ 
│       │   │  804 │                     // Store parsed meta information and type definitions in session properties if available
│       │   │  805 │                     if (parseResult.MetaInfo != null || parseResult.Types.Any())
│       │   │  806 │                     {
│       │   │  807 │                         // This is a placeholder for potentially storing this information
│       │   │  808 │                         // You could serialize and store these in controller properties, session properties, or a separate storage
│       │   │  809 │                         _logger.LogInformation("Parsed ObjectSet with {TypeCount} type definitions",
│       │   │  810 │                             parseResult.Types?.Count ?? 0);
│       │   │  811 │                     }
│       │   │  812 │                 }
│       │   │  813 │             }
│       │   │  814 │             catch (Exception ex)
│       │   │  815 │             {
│       │   │  816 │                 _logger.LogError(ex, "Error parsing XML content");
│       │   │  817 │                 throw new ParsingException("Failed to parse XML content: " + ex.Message, "unknown");
│       │   │  818 │             }
│       │   │  819 │ 
│       │   │  820 │             // Apply filtering based on options
│       │   │  821 │             if (options.TypeWhitelist.Count > 0 || options.NameFilters.Count > 0 || options.IgnoreEmptyValues)
│       │   │  822 │             {
│       │   │  823 │                 controllers = FilterControllers(controllers, new FilterOptions
│       │   │  824 │                 {
│       │   │  825 │                     IncludeByteCode = options.IncludeByteCode,
│       │   │  826 │                     IgnoreEmptyValues = options.IgnoreEmptyValues,
│       │   │  827 │                     IncludedTypes = options.TypeWhitelist,
│       │   │  828 │                     NameFilters = options.NameFilters,
│       │   │  829 │                     IsWhitelist = options.IsWhitelist
│       │   │  830 │                 });
│       │   │  831 │             }
│       │   │  832 │ 
│       │   │  833 │             return controllers;
│       │   │  834 │         }
│       │   │  835 │ 
│       │   │  836 │ 
│       │   │  837 │         private void ProcessObjectSetChild(
│       │   │  838 │             ExportedObject obj,
│       │   │  839 │             Controller controller,
│       │   │  840 │             ControllerObject parent,
│       │   │  841 │             bool includeByteCode)
│       │   │  842 │         {
│       │   │  843 │             // Extract type from properties
│       │   │  844 │             string type = "Unknown";
│       │   │  845 │             obj.Properties.TryGetValue("TYPE", out type);
│       │   │  846 │ 
│       │   │  847 │             // Extract value if available
│       │   │  848 │             string value = string.Empty;
│       │   │  849 │             obj.Properties.TryGetValue("Value", out value);
│       │   │  850 │ 
│       │   │  851 │             // Create controller object
│       │   │  852 │             var controllerObj = new ControllerObject(type, obj.Name, value);
│       │   │  853 │ 
│       │   │  854 │             // Extract alias if available
│       │   │  855 │             string alias = null;
│       │   │  856 │             if (obj.Properties.TryGetValue("Alias", out alias) && !string.IsNullOrEmpty(alias))
│       │   │  857 │             {
│       │   │  858 │                 controllerObj.SetAlias(alias);
│       │   │  859 │             }
│       │   │  860 │ 
│       │   │  861 │             // Check if this is bytecode
│       │   │  862 │             bool hasByteCode = type == "InfinityProgram" || type == "InfinityFunction";
│       │   │  863 │             controllerObj.SetHasByteCode(hasByteCode);
│       │   │  864 │ 
│       │   │  865 │             if (hasByteCode && !includeByteCode)
│       │   │  866 │             {
│       │   │  867 │                 controllerObj.UpdateValue(string.Empty);
│       │   │  868 │             }
│       │   │  869 │ 
│       │   │  870 │             // Add all properties
│       │   │  871 │             foreach (var prop in obj.Properties)
│       │   │  872 │             {
│       │   │  873 │                 // Skip Value and Alias as they are handled specially
│       │   │  874 │                 if (prop.Key == "Value" || prop.Key == "Alias" || prop.Key == "TYPE")
│       │   │  875 │                     continue;
│       │   │  876 │ 
│       │   │  877 │                 controllerObj.SetProperty(prop.Key, prop.Value);
│       │   │  878 │             }
│       │   │  879 │ 
│       │   │  880 │             // Process children recursively
│       │   │  881 │             foreach (var childObj in obj.Children)
│       │   │  882 │             {
│       │   │  883 │                 ProcessObjectSetChild(childObj, controller, controllerObj, includeByteCode);
│       │   │  884 │             }
│       │   │  885 │ 
│       │   │  886 │             // Add to parent or controller
│       │   │  887 │             if (parent != null)
│       │   │  888 │             {
│       │   │  889 │                 parent.AddChild(controllerObj);
│       │   │  890 │             }
│       │   │  891 │             else
│       │   │  892 │             {
│       │   │  893 │                 controller.AddObject(controllerObj);
│       │   │  894 │             }
│       │   │  895 │         }
│       │   │  896 │         /// <summary>
│       │   │  897 │         /// Parses an XML controller object
│       │   │  898 │         /// </summary>
│       │   │  899 │         private ControllerObject ParseXmlObject(XElement element, bool includeByteCode)
│       │   │  900 │         {
│       │   │  901 │             var type = element.Element("Type")?.Value ??
│       │   │  902 │                        element.Attribute("Type")?.Value ??
│       │   │  903 │                        "Unknown";
│       │   │  904 │ 
│       │   │  905 │             var name = element.Element("Name")?.Value ??
│       │   │  906 │                        element.Attribute("Name")?.Value;
│       │   │  907 │ 
│       │   │  908 │             if (string.IsNullOrEmpty(name))
│       │   │  909 │                 return null;
│       │   │  910 │ 
│       │   │  911 │             var value = element.Element("Value")?.Value ??
│       │   │  912 │                         element.Attribute("Value")?.Value ??
│       │   │  913 │                         "";
│       │   │  914 │ 
│       │   │  915 │             var obj = new ControllerObject(type, name, value);
│       │   │  916 │ 
│       │   │  917 │             // Set alias if present
│       │   │  918 │             var alias = element.Element("Alias")?.Value ??
│       │   │  919 │                         element.Attribute("Alias")?.Value;
│       │   │  920 │ 
│       │   │  921 │             if (!string.IsNullOrEmpty(alias))
│       │   │  922 │             {
│       │   │  923 │                 obj.SetAlias(alias);
│       │   │  924 │             }
│       │   │  925 │ 
│       │   │  926 │             // Set bytecode flag if needed
│       │   │  927 │             bool hasByteCode = ByteCodeTypes.Contains(type);
│       │   │  928 │             if (hasByteCode)
│       │   │  929 │             {
│       │   │  930 │                 obj.SetHasByteCode(true);
│       │   │  931 │                 if (!includeByteCode)
│       │   │  932 │                 {
│       │   │  933 │                     obj.UpdateValue(string.Empty);
│       │   │  934 │                 }
│       │   │  935 │             }
│       │   │  936 │ 
│       │   │  937 │             // Process properties
│       │   │  938 │             var propertiesElement = element.Element("Properties");
│       │   │  939 │             if (propertiesElement != null)
│       │   │  940 │             {
│       │   │  941 │                 foreach (var propElement in propertiesElement.Elements("Property"))
│       │   │  942 │                 {
│       │   │  943 │                     var key = propElement.Attribute("Key")?.Value ??
│       │   │  944 │                               propElement.Attribute("Name")?.Value;
│       │   │  945 │                     var value2 = propElement.Attribute("Value")?.Value;
│       │   │  946 │ 
│       │   │  947 │                     if (!string.IsNullOrEmpty(key))
│       │   │  948 │                     {
│       │   │  949 │                         obj.SetProperty(key, value2 ?? "");
│       │   │  950 │                     }
│       │   │  951 │                 }
│       │   │  952 │             }
│       │   │  953 │ 
│       │   │  954 │             // Process children
│       │   │  955 │             var childrenElement = element.Element("Children");
│       │   │  956 │             if (childrenElement != null)
│       │   │  957 │             {
│       │   │  958 │                 foreach (var childElement in childrenElement.Elements("Object"))
│       │   │  959 │                 {
│       │   │  960 │                     var child = ParseXmlObject(childElement, includeByteCode);
│       │   │  961 │                     if (child != null)
│       │   │  962 │                     {
│       │   │  963 │                         obj.AddChild(child);
│       │   │  964 │                     }
│       │   │  965 │                 }
│       │   │  966 │             }
│       │   │  967 │ 
│       │   │  968 │             return obj;
│       │   │  969 │         }
│       │   │  970 │ 
│       │   │  971 │         /// <summary>
│       │   │  972 │         /// Parses XML child objects for ObjectSet format
│       │   │  973 │         /// </summary>
│       │   │  974 │         private void ParseXmlChildObjects(XElement element, Controller controller, bool includeByteCode, ControllerObject parent = null)
│       │   │  975 │         {
│       │   │  976 │             foreach (var childElement in element.Elements("OI"))
│       │   │  977 │             {
│       │   │  978 │                 var type = childElement.Attribute("TYPE")?.Value ?? "Unknown";
│       │   │  979 │                 var name = childElement.Attribute("NAME")?.Value;
│       │   │  980 │ 
│       │   │  981 │                 if (string.IsNullOrEmpty(name))
│       │   │  982 │                     continue;
│       │   │  983 │ 
│       │   │  984 │                 // Get value from PI element with name "Value"
│       │   │  985 │                 var valueElement = childElement.Elements("PI")
│       │   │  986 │                     .FirstOrDefault(e => e.Attribute("Name")?.Value == "Value");
│       │   │  987 │                 var value = valueElement?.Attribute("Value")?.Value ?? "";
│       │   │  988 │ 
│       │   │  989 │                 var obj = new ControllerObject(type, name, value);
│       │   │  990 │ 
│       │   │  991 │                 // Set alias if present
│       │   │  992 │                 var aliasElement = childElement.Elements("PI")
│       │   │  993 │                     .FirstOrDefault(e => e.Attribute("Name")?.Value == "Alias");
│       │   │  994 │                 var alias = aliasElement?.Attribute("Value")?.Value;
│       │   │  995 │ 
│       │   │  996 │                 if (!string.IsNullOrEmpty(alias))
│       │   │  997 │                 {
│       │   │  998 │                     obj.SetAlias(alias);
│       │   │  999 │                 }
│       │   │ 1000 │ 
│       │   │ ... (truncated after 1000 lines, 533 more lines)
│       │   └──────────────────────────────────────────────────────────────────────
│       ├── 📄 ProjectService.cs (8.47 KB, 2025-03-11 14:52:44)
│       │   ┌──────────────────────────────────────────────────────────────────────
│       │   │ FILE CONTENT: ProjectService.cs
│       │   ├──────────────────────────────────────────────────────────────────────
│       │   │    1 │ ﻿using Microsoft.Extensions.Logging;
│       │   │    2 │ using System;
│       │   │    3 │ using System.Collections.Generic;
│       │   │    4 │ using System.Threading.Tasks;
│       │   │    5 │ using test.Core.Domain;
│       │   │    6 │ using test.Core.Interfaces;
│       │   │    7 │ using test.Data.Mapping;
│       │   │    8 │ using test.Infrastructure.Logging;
│       │   │    9 │ using test.ViewModels;
│       │   │   10 │ 
│       │   │   11 │ namespace test.Application.Services
│       │   │   12 │ {
│       │   │   13 │     /// <summary>
│       │   │   14 │     /// Service for project-related operations
│       │   │   15 │     /// </summary>
│       │   │   16 │     public class ProjectService
│       │   │   17 │     {
│       │   │   18 │         private readonly IProjectRepository _projectRepository;
│       │   │   19 │         private readonly IErrorHandler _errorHandler;
│       │   │   20 │         private readonly ILogger<ProjectService> _logger;
│       │   │   21 │ 
│       │   │   22 │         /// <summary>
│       │   │   23 │         /// Creates a new project service
│       │   │   24 │         /// </summary>
│       │   │   25 │         /// <param name="projectRepository">The project repository</param>
│       │   │   26 │         /// <param name="errorHandler">The error handler</param>
│       │   │   27 │         /// <param name="logger">The logger</param>
│       │   │   28 │         public ProjectService(
│       │   │   29 │             IProjectRepository projectRepository,
│       │   │   30 │             IErrorHandler errorHandler,
│       │   │   31 │             ILogger<ProjectService> logger)
│       │   │   32 │         {
│       │   │   33 │             _projectRepository = projectRepository ?? throw new ArgumentNullException(nameof(projectRepository));
│       │   │   34 │             _errorHandler = errorHandler ?? throw new ArgumentNullException(nameof(errorHandler));
│       │   │   35 │             _logger = logger ?? throw new ArgumentNullException(nameof(logger));
│       │   │   36 │         }
│       │   │   37 │ 
│       │   │   38 │         /// <summary>
│       │   │   39 │         /// Gets all projects
│       │   │   40 │         /// </summary>
│       │   │   41 │         /// <returns>A collection of project view models</returns>
│       │   │   42 │         public async Task<IEnumerable<ProjectViewModel>> GetAllProjectsAsync()
│       │   │   43 │         {
│       │   │   44 │             return await _errorHandler.WithErrorHandlingAsync(async () =>
│       │   │   45 │             {
│       │   │   46 │                 var projects = await _projectRepository.GetAllAsync();
│       │   │   47 │                 var viewModels = new List<ProjectViewModel>();
│       │   │   48 │ 
│       │   │   49 │                 foreach (var project in projects)
│       │   │   50 │                 {
│       │   │   51 │                     viewModels.Add(ProjectMapper.ToDtoViewModel(project));
│       │   │   52 │                 }
│       │   │   53 │ 
│       │   │   54 │                 return viewModels;
│       │   │   55 │             }, "GetAllProjects");
│       │   │   56 │         }
│       │   │   57 │ 
│       │   │   58 │         /// <summary>
│       │   │   59 │         /// Gets a project by ID
│       │   │   60 │         /// </summary>
│       │   │   61 │         /// <param name="id">The project ID</param>
│       │   │   62 │         /// <returns>The project view model or null if not found</returns>
│       │   │   63 │         public async Task<ProjectViewModel> GetProjectByIdAsync(string id)
│       │   │   64 │         {
│       │   │   65 │             return await _errorHandler.WithErrorHandlingAsync(async () =>
│       │   │   66 │             {
│       │   │   67 │                 var project = await _projectRepository.GetByIdAsync(id);
│       │   │   68 │                 return ProjectMapper.ToDtoViewModel(project);
│       │   │   69 │             }, "GetProjectById");
│       │   │   70 │         }
│       │   │   71 │ 
│       │   │   72 │         /// <summary>
│       │   │   73 │         /// Creates a new project
│       │   │   74 │         /// </summary>
│       │   │   75 │         /// <param name="name">The project name</param>
│       │   │   76 │         /// <param name="description">The project description</param>
│       │   │   77 │         /// <returns>The created project view model</returns>
│       │   │   78 │         public async Task<ProjectViewModel> CreateProjectAsync(string name, string description = "")
│       │   │   79 │         {
│       │   │   80 │             return await _errorHandler.WithErrorHandlingAsync(async () =>
│       │   │   81 │             {
│       │   │   82 │                 // Generate a new unique ID for the project
│       │   │   83 │                 var projectId = Ulid.NewUlid().ToString();
│       │   │   84 │                 var project = new Project(projectId, name, description);
│       │   │   85 │ 
│       │   │   86 │                 await _projectRepository.CreateAsync(project);
│       │   │   87 │                 return ProjectMapper.ToDtoViewModel(project);
│       │   │   88 │             }, "CreateProject");
│       │   │   89 │         }
│       │   │   90 │ 
│       │   │   91 │         /// <summary>
│       │   │   92 │         /// Updates a project
│       │   │   93 │         /// </summary>
│       │   │   94 │         /// <param name="id">The project ID</param>
│       │   │   95 │         /// <param name="name">The new name</param>
│       │   │   96 │         /// <param name="description">The new description</param>
│       │   │   97 │         /// <returns>The updated project view model</returns>
│       │   │   98 │         public async Task<ProjectViewModel> UpdateProjectAsync(string id, string name, string description)
│       │   │   99 │         {
│       │   │  100 │             return await _errorHandler.WithErrorHandlingAsync(async () =>
│       │   │  101 │             {
│       │   │  102 │                 // Generate a new unique ID for the project
│       │   │  103 │                 var projectId = NUlid.Ulid.NewUlid().ToString();
│       │   │  104 │                 var project = new Project(projectId, name, description);
│       │   │  105 │ 
│       │   │  106 │                 await _projectRepository.CreateAsync(project);
│       │   │  107 │                 return ProjectMapper.ToDtoViewModel(project);
│       │   │  108 │             }, "CreateProject");
│       │   │  109 │         }
│       │   │  110 │ 
│       │   │  111 │         /// <summary>
│       │   │  112 │         /// Deletes a project
│       │   │  113 │         /// </summary>
│       │   │  114 │         /// <param name="id">The project ID</param>
│       │   │  115 │         /// <returns>True if deleted, false if not found</returns>
│       │   │  116 │         public async Task<bool> DeleteProjectAsync(string id)
│       │   │  117 │         {
│       │   │  118 │             return await _errorHandler.WithErrorHandlingAsync(async () =>
│       │   │  119 │             {
│       │   │  120 │                 return await _projectRepository.DeleteAsync(id);
│       │   │  121 │             }, "DeleteProject");
│       │   │  122 │         }
│       │   │  123 │ 
│       │   │  124 │         /// <summary>
│       │   │  125 │         /// Imports a file into a project
│       │   │  126 │         /// </summary>
│       │   │  127 │         /// <param name="projectId">The project ID</param>
│       │   │  128 │         /// <param name="filePath">The file path</param>
│       │   │  129 │         /// <returns>The imported file view model</returns>
│       │   │  130 │         public async Task<ImportedFileViewModel> ImportFileAsync(string projectId, string filePath)
│       │   │  131 │         {
│       │   │  132 │             return await _errorHandler.WithErrorHandlingAsync(async () =>
│       │   │  133 │             {
│       │   │  134 │                 var importedFile = await _projectRepository.ImportFileAsync(projectId, filePath);
│       │   │  135 │                 return ProjectMapper.ToImportedFileViewModel(importedFile);
│       │   │  136 │             }, "ImportFile");
│       │   │  137 │         }
│       │   │  138 │ 
│       │   │  139 │         /// <summary>
│       │   │  140 │         /// Removes a file from a project
│       │   │  141 │         /// </summary>
│       │   │  142 │         /// <param name="projectId">The project ID</param>
│       │   │  143 │         /// <param name="filePath">The file path</param>
│       │   │  144 │         /// <returns>True if removed, false if not found</returns>
│       │   │  145 │         public async Task<bool> RemoveFileAsync(string projectId, string filePath)
│       │   │  146 │         {
│       │   │  147 │             return await _errorHandler.WithErrorHandlingAsync(async () =>
│       │   │  148 │             {
│       │   │  149 │                 return await _projectRepository.RemoveFileAsync(projectId, filePath);
│       │   │  150 │             }, "RemoveFile");
│       │   │  151 │         }
│       │   │  152 │ 
│       │   │  153 │         /// <summary>
│       │   │  154 │         /// Imports a shared type into a project
│       │   │  155 │         /// </summary>
│       │   │  156 │         /// <param name="projectId">The project ID</param>
│       │   │  157 │         /// <param name="filePath">The file path</param>
│       │   │  158 │         /// <param name="typeName">The type name (optional)</param>
│       │   │  159 │         /// <param name="category">The category (optional)</param>
│       │   │  160 │         /// <param name="description">The description (optional)</param>
│       │   │  161 │         /// <returns>The imported shared type view model</returns>
│       │   │  162 │         public async Task<SharedTypeViewModel> ImportSharedTypeAsync(
│       │   │  163 │             string projectId,
│       │   │  164 │             string filePath,
│       │   │  165 │             string typeName = null,
│       │   │  166 │             string category = null,
│       │   │  167 │             string description = null)
│       │   │  168 │         {
│       │   │  169 │             return await _errorHandler.WithErrorHandlingAsync(async () =>
│       │   │  170 │             {
│       │   │  171 │                 var sharedType = await _projectRepository.AddSharedTypeAsync(
│       │   │  172 │                     projectId, filePath, typeName, category, description);
│       │   │  173 │                 return ProjectMapper.ToSharedTypeViewModel(sharedType);
│       │   │  174 │             }, "ImportSharedType");
│       │   │  175 │         }
│       │   │  176 │ 
│       │   │  177 │         /// <summary>
│       │   │  178 │         /// Updates a shared type description
│       │   │  179 │         /// </summary>
│       │   │  180 │         /// <param name="projectId">The project ID</param>
│       │   │  181 │         /// <param name="filePath">The file path</param>
│       │   │  182 │         /// <param name="description">The new description</param>
│       │   │  183 │         /// <returns>True if updated, false if not found</returns>
│       │   │  184 │         public async Task<bool> UpdateSharedTypeDescriptionAsync(string projectId, string filePath, string description)
│       │   │  185 │         {
│       │   │  186 │             return await _errorHandler.WithErrorHandlingAsync(async () =>
│       │   │  187 │             {
│       │   │  188 │                 return await _projectRepository.UpdateSharedTypeDescriptionAsync(projectId, filePath, description);
│       │   │  189 │             }, "UpdateSharedTypeDescription");
│       │   │  190 │         }
│       │   │  191 │ 
│       │   │  192 │         /// <summary>
│       │   │  193 │         /// Removes a shared type from a project
│       │   │  194 │         /// </summary>
│       │   │  195 │         /// <param name="projectId">The project ID</param>
│       │   │  196 │         /// <param name="filePath">The file path</param>
│       │   │  197 │         /// <returns>True if removed, false if not found</returns>
│       │   │  198 │         public async Task<bool> RemoveSharedTypeAsync(string projectId, string filePath)
│       │   │  199 │         {
│       │   │  200 │             return await _errorHandler.WithErrorHandlingAsync(async () =>
│       │   │  201 │             {
│       │   │  202 │                 return await _projectRepository.RemoveSharedTypeAsync(projectId, filePath);
│       │   │  203 │             }, "RemoveSharedType");
│       │   │  204 │         }
│       │   │  205 │     }
│       │   │  206 │ }
│       │   └──────────────────────────────────────────────────────────────────────
│       └── 📄 XmlModificationService.cs (14.40 KB, 2025-03-11 15:51:04)
│           ┌──────────────────────────────────────────────────────────────────────
│           │ FILE CONTENT: XmlModificationService.cs
│           ├──────────────────────────────────────────────────────────────────────
│           │    1 │ ﻿// test/Application/Services/XmlModificationService.cs
│           │    2 │ using Microsoft.Extensions.Logging;
│           │    3 │ using System;
│           │    4 │ using System.Collections.Generic;
│           │    5 │ using System.Linq;
│           │    6 │ using System.Threading.Tasks;
│           │    7 │ using System.Xml.Linq;
│           │    8 │ using test.Core.Domain;
│           │    9 │ using test.Core.Domain.ObjectSet;
│           │   10 │ using test.Core.Interfaces;
│           │   11 │ using test.Infrastructure.Logging;
│           │   12 │ 
│           │   13 │ namespace test.Application.Services
│           │   14 │ {
│           │   15 │     /// <summary>
│           │   16 │     /// Service for modifying XML files with HVAC controller data
│           │   17 │     /// </summary>
│           │   18 │     public class XmlModificationService : IXmlModificationService
│           │   19 │     {
│           │   20 │         private readonly IObjectSetParser _parser;
│           │   21 │         private readonly IObjectSetWriter _writer;
│           │   22 │         private readonly IErrorHandler _errorHandler;
│           │   23 │         private readonly ILogger<XmlModificationService> _logger;
│           │   24 │         private readonly IFileSystem _fileSystem;
│           │   25 │ 
│           │   26 │         /// <summary>
│           │   27 │         /// Creates a new XML modification service
│           │   28 │         /// </summary>
│           │   29 │         public XmlModificationService(
│           │   30 │             IObjectSetParser parser,
│           │   31 │             IObjectSetWriter writer,
│           │   32 │             IErrorHandler errorHandler,
│           │   33 │             ILogger<XmlModificationService> logger,
│           │   34 │             IFileSystem fileSystem)
│           │   35 │         {
│           │   36 │             _parser = parser ?? throw new ArgumentNullException(nameof(parser));
│           │   37 │             _writer = writer ?? throw new ArgumentNullException(nameof(writer));
│           │   38 │             _errorHandler = errorHandler ?? throw new ArgumentNullException(nameof(errorHandler));
│           │   39 │             _logger = logger ?? throw new ArgumentNullException(nameof(logger));
│           │   40 │             _fileSystem = fileSystem ?? throw new ArgumentNullException(nameof(fileSystem));
│           │   41 │         }
│           │   42 │ 
│           │   43 │         /// <inheritdoc/>
│           │   44 │         public async Task<bool> UpdateVariableUnitValuesAsync(string filePath, string variableName, string newUnit)
│           │   45 │         {
│           │   46 │             return await _errorHandler.WithErrorHandlingAsync(async () =>
│           │   47 │             {
│           │   48 │                 // 1. Parse the XML file
│           │   49 │                 var parseConfig = new ObjectSetParsingOptions
│           │   50 │                 {
│           │   51 │                     IncludeTypeDefinitions = true,  // We need type definitions since we're modifying variables
│           │   52 │                     IncludeExportedObjects = false  // We don't need exported objects for this operation
│           │   53 │                 };
│           │   54 │ 
│           │   55 │                 var content = await _fileSystem.ReadAllTextAsync(filePath);
│           │   56 │                 var document = XDocument.Parse(content);
│           │   57 │                 var parseResult = await _parser.ParseAsync(document, parseConfig);
│           │   58 │ 
│           │   59 │                 if (!parseResult.Success)
│           │   60 │                 {
│           │   61 │                     _logger.LogError("Failed to parse XML: {Error}", parseResult.ErrorMessage);
│           │   62 │                     return false;
│           │   63 │                 }
│           │   64 │ 
│           │   65 │                 // 2. Find and modify the target variables
│           │   66 │                 var modified = false;
│           │   67 │                 foreach (var type in parseResult.Types)
│           │   68 │                 {
│           │   69 │                     foreach (var tab in type.PropertyTabs)
│           │   70 │                     {
│           │   71 │                         foreach (var group in tab.PropertyGroups)
│           │   72 │                         {
│           │   73 │                             var targetVars = group.Variables
│           │   74 │                                 .Where(v => v.Name.Equals(variableName, StringComparison.OrdinalIgnoreCase));
│           │   75 │ 
│           │   76 │                             foreach (var variable in targetVars)
│           │   77 │                             {
│           │   78 │                                 variable.Unit = newUnit;
│           │   79 │                                 modified = true;
│           │   80 │                             }
│           │   81 │                         }
│           │   82 │                     }
│           │   83 │                 }
│           │   84 │ 
│           │   85 │                 if (!modified)
│           │   86 │                 {
│           │   87 │                     _logger.LogWarning("No matching variables found to update");
│           │   88 │                     return false;
│           │   89 │                 }
│           │   90 │ 
│           │   91 │                 // 3. Convert to controllers and write back to file
│           │   92 │                 // Since we're updating type definitions, we need to include them in the write options
│           │   93 │                 var writerOptions = new ObjectSetWriteOptions
│           │   94 │                 {
│           │   95 │                     TypeDefinitions = parseResult.Types,
│           │   96 │                     PrettyPrint = true
│           │   97 │                 };
│           │   98 │ 
│           │   99 │                 // Create empty controllers list - we're only updating type definitions
│           │  100 │                 var controllers = new List<Controller>();
│           │  101 │                 var resultDoc = await _writer.WriteAsync(controllers, writerOptions);
│           │  102 │                 await _fileSystem.WriteAllTextAsync(filePath, resultDoc.ToString());
│           │  103 │ 
│           │  104 │                 return true;
│           │  105 │             }, "UpdateVariableUnitValues");
│           │  106 │         }
│           │  107 │ 
│           │  108 │         /// <inheritdoc/>
│           │  109 │         public async Task<bool> UpdateObjectValueAsync(string filePath, string objectName, string newValue)
│           │  110 │         {
│           │  111 │             return await _errorHandler.WithErrorHandlingAsync(async () =>
│           │  112 │             {
│           │  113 │                 // 1. Parse the XML file
│           │  114 │                 var parseConfig = new ObjectSetParsingOptions
│           │  115 │                 {
│           │  116 │                     IncludeTypeDefinitions = false,   // We don't need type definitions for this operation
│           │  117 │                     IncludeExportedObjects = true     // We need exported objects since we're modifying them
│           │  118 │                 };
│           │  119 │ 
│           │  120 │                 var content = await _fileSystem.ReadAllTextAsync(filePath);
│           │  121 │                 var document = XDocument.Parse(content);
│           │  122 │                 var parseResult = await _parser.ParseAsync(document, parseConfig);
│           │  123 │ 
│           │  124 │                 if (!parseResult.Success)
│           │  125 │                 {
│           │  126 │                     _logger.LogError("Failed to parse XML: {Error}", parseResult.ErrorMessage);
│           │  127 │                     return false;
│           │  128 │                 }
│           │  129 │ 
│           │  130 │                 // 2. Find and update the target object value
│           │  131 │                 var modified = false;
│           │  132 │                 foreach (var obj in parseResult.ExportedObjects)
│           │  133 │                 {
│           │  134 │                     modified |= UpdateObjectValueRecursive(obj, objectName, newValue);
│           │  135 │                 }
│           │  136 │ 
│           │  137 │                 if (!modified)
│           │  138 │                 {
│           │  139 │                     _logger.LogWarning("No matching objects found to update");
│           │  140 │                     return false;
│           │  141 │                 }
│           │  142 │ 
│           │  143 │                 // 3. Convert exported objects to controllers and write back to file
│           │  144 │                 var controllers = ConvertExportedObjectsToControllers(parseResult.ExportedObjects);
│           │  145 │                 var writerOptions = new ObjectSetWriteOptions
│           │  146 │                 {
│           │  147 │                     PrettyPrint = true
│           │  148 │                 };
│           │  149 │ 
│           │  150 │                 var resultDoc = await _writer.WriteAsync(controllers, writerOptions);
│           │  151 │                 await _fileSystem.WriteAllTextAsync(filePath, resultDoc.ToString());
│           │  152 │ 
│           │  153 │                 return true;
│           │  154 │             }, "UpdateObjectValue");
│           │  155 │         }
│           │  156 │ 
│           │  157 │         /// <inheritdoc/>
│           │  158 │         public async Task<bool> UpdateNumericValuesAsync(string filePath, Func<string, double, double> transformationFunc)
│           │  159 │         {
│           │  160 │             return await _errorHandler.WithErrorHandlingAsync(async () =>
│           │  161 │             {
│           │  162 │                 var parseConfig = new ObjectSetParsingOptions
│           │  163 │                 {
│           │  164 │                     IncludeTypeDefinitions = false,
│           │  165 │                     IncludeExportedObjects = true
│           │  166 │                 };
│           │  167 │ 
│           │  168 │                 var content = await _fileSystem.ReadAllTextAsync(filePath);
│           │  169 │                 var document = XDocument.Parse(content);
│           │  170 │                 var parseResult = await _parser.ParseAsync(document, parseConfig);
│           │  171 │ 
│           │  172 │                 if (!parseResult.Success) return false;
│           │  173 │ 
│           │  174 │                 var modified = false;
│           │  175 │                 foreach (var obj in parseResult.ExportedObjects)
│           │  176 │                 {
│           │  177 │                     modified |= TransformNumericValuesRecursive(obj, transformationFunc);
│           │  178 │                 }
│           │  179 │ 
│           │  180 │                 if (!modified) return false;
│           │  181 │ 
│           │  182 │                 // Convert exported objects to controllers and write back to file
│           │  183 │                 var controllers = ConvertExportedObjectsToControllers(parseResult.ExportedObjects);
│           │  184 │                 var writerOptions = new ObjectSetWriteOptions
│           │  185 │                 {
│           │  186 │                     PrettyPrint = true
│           │  187 │                 };
│           │  188 │ 
│           │  189 │                 var resultDoc = await _writer.WriteAsync(controllers, writerOptions);
│           │  190 │                 await _fileSystem.WriteAllTextAsync(filePath, resultDoc.ToString());
│           │  191 │ 
│           │  192 │                 return true;
│           │  193 │             }, "UpdateNumericValues");
│           │  194 │         }
│           │  195 │ 
│           │  196 │         #region Helper Methods
│           │  197 │ 
│           │  198 │         /// <summary>
│           │  199 │         /// Converts exported objects to controllers for writing back to file
│           │  200 │         /// </summary>
│           │  201 │         private List<Controller> ConvertExportedObjectsToControllers(List<ExportedObject> exportedObjects)
│           │  202 │         {
│           │  203 │             var controllers = new List<Controller>();
│           │  204 │ 
│           │  205 │             foreach (var exportedObj in exportedObjects)
│           │  206 │             {
│           │  207 │                 // Get controller name and type
│           │  208 │                 exportedObj.Properties.TryGetValue("Name", out string name);
│           │  209 │                 exportedObj.Properties.TryGetValue("TYPE", out string type);
│           │  210 │ 
│           │  211 │                 if (type == "InfinityInfinetCtlr" || type == "Controller")
│           │  212 │                 {
│           │  213 │                     // Create controller
│           │  214 │                     var controller = new Controller(name ?? "Unknown", "Unknown");
│           │  215 │ 
│           │  216 │                     // Add all properties
│           │  217 │                     foreach (var prop in exportedObj.Properties)
│           │  218 │                     {
│           │  219 │                         if (prop.Key != "Name" && prop.Key != "TYPE")
│           │  220 │                         {
│           │  221 │                             controller.SetProperty(prop.Key, prop.Value);
│           │  222 │                         }
│           │  223 │                     }
│           │  224 │ 
│           │  225 │                     // Process child objects - they would need to be converted to ControllerObject instances
│           │  226 │                     // This is a simplified conversion - in a real implementation, you would need to
│           │  227 │                     // convert all the child objects recursively
│           │  228 │                     foreach (var child in exportedObj.Children)
│           │  229 │                     {
│           │  230 │                         ConvertExportedObjectToControllerObject(child, controller);
│           │  231 │                     }
│           │  232 │ 
│           │  233 │                     controllers.Add(controller);
│           │  234 │                 }
│           │  235 │             }
│           │  236 │ 
│           │  237 │             return controllers;
│           │  238 │         }
│           │  239 │ 
│           │  240 │         /// <summary>
│           │  241 │         /// Converts an exported object to a controller object and adds it to the controller
│           │  242 │         /// </summary>
│           │  243 │         private void ConvertExportedObjectToControllerObject(ExportedObject exportedObj, Controller controller)
│           │  244 │         {
│           │  245 │             // Get object name, type, and value
│           │  246 │             exportedObj.Properties.TryGetValue("Name", out string name);
│           │  247 │             exportedObj.Properties.TryGetValue("TYPE", out string type);
│           │  248 │             exportedObj.Properties.TryGetValue("Value", out string value);
│           │  249 │ 
│           │  250 │             if (!string.IsNullOrEmpty(name))
│           │  251 │             {
│           │  252 │                 // Create controller object
│           │  253 │                 var controllerObj = new ControllerObject(type ?? "Unknown", name, value ?? "");
│           │  254 │ 
│           │  255 │                 // Add all properties
│           │  256 │                 foreach (var prop in exportedObj.Properties)
│           │  257 │                 {
│           │  258 │                     if (prop.Key != "Name" && prop.Key != "TYPE" && prop.Key != "Value")
│           │  259 │                     {
│           │  260 │                         controllerObj.SetProperty(prop.Key, prop.Value);
│           │  261 │                     }
│           │  262 │                 }
│           │  263 │ 
│           │  264 │                 // Process child objects recursively
│           │  265 │                 foreach (var child in exportedObj.Children)
│           │  266 │                 {
│           │  267 │                     ConvertExportedObjectToControllerObjectChild(child, controllerObj);
│           │  268 │                 }
│           │  269 │ 
│           │  270 │                 // Add to controller
│           │  271 │                 controller.AddObject(controllerObj);
│           │  272 │             }
│           │  273 │         }
│           │  274 │ 
│           │  275 │         /// <summary>
│           │  276 │         /// Converts an exported object to a controller object and adds it as a child
│           │  277 │         /// </summary>
│           │  278 │         private void ConvertExportedObjectToControllerObjectChild(ExportedObject exportedObj, ControllerObject parent)
│           │  279 │         {
│           │  280 │             // Get object name, type, and value
│           │  281 │             exportedObj.Properties.TryGetValue("Name", out string name);
│           │  282 │             exportedObj.Properties.TryGetValue("TYPE", out string type);
│           │  283 │             exportedObj.Properties.TryGetValue("Value", out string value);
│           │  284 │ 
│           │  285 │             if (!string.IsNullOrEmpty(name))
│           │  286 │             {
│           │  287 │                 // Create controller object
│           │  288 │                 var controllerObj = new ControllerObject(type ?? "Unknown", name, value ?? "");
│           │  289 │ 
│           │  290 │                 // Add all properties
│           │  291 │                 foreach (var prop in exportedObj.Properties)
│           │  292 │                 {
│           │  293 │                     if (prop.Key != "Name" && prop.Key != "TYPE" && prop.Key != "Value")
│           │  294 │                     {
│           │  295 │                         controllerObj.SetProperty(prop.Key, prop.Value);
│           │  296 │                     }
│           │  297 │                 }
│           │  298 │ 
│           │  299 │                 // Process child objects recursively
│           │  300 │                 foreach (var child in exportedObj.Children)
│           │  301 │                 {
│           │  302 │                     ConvertExportedObjectToControllerObjectChild(child, controllerObj);
│           │  303 │                 }
│           │  304 │ 
│           │  305 │                 // Add to parent
│           │  306 │                 parent.AddChild(controllerObj);
│           │  307 │             }
│           │  308 │         }
│           │  309 │ 
│           │  310 │         /// <summary>
│           │  311 │         /// Recursively updates object values
│           │  312 │         /// </summary>
│           │  313 │         private bool UpdateObjectValueRecursive(ExportedObject obj, string targetName, string newValue)
│           │  314 │         {
│           │  315 │             var modified = false;
│           │  316 │ 
│           │  317 │             // Check if this is our target object
│           │  318 │             if (obj.Properties.TryGetValue("Name", out var name) &&
│           │  319 │                 name.Equals(targetName, StringComparison.OrdinalIgnoreCase))
│           │  320 │             {
│           │  321 │                 obj.Properties["Value"] = newValue;
│           │  322 │                 modified = true;
│           │  323 │             }
│           │  324 │ 
│           │  325 │             // Recursively check children
│           │  326 │             foreach (var child in obj.Children)
│           │  327 │             {
│           │  328 │                 modified |= UpdateObjectValueRecursive(child, targetName, newValue);
│           │  329 │             }
│           │  330 │ 
│           │  331 │             return modified;
│           │  332 │         }
│           │  333 │ 
│           │  334 │         /// <summary>
│           │  335 │         /// Recursively transforms numeric values
│           │  336 │         /// </summary>
│           │  337 │         private bool TransformNumericValuesRecursive(
│           │  338 │             ExportedObject obj,
│           │  339 │             Func<string, double, double> transformationFunc)
│           │  340 │         {
│           │  341 │             var modified = false;
│           │  342 │ 
│           │  343 │             // Try to transform any numeric values
│           │  344 │             if (obj.Properties.TryGetValue("Value", out var valueStr) &&
│           │  345 │                 double.TryParse(valueStr, out var numericValue))
│           │  346 │             {
│           │  347 │                 var newValue = transformationFunc(obj.Name, numericValue);
│           │  348 │                 obj.Properties["Value"] = newValue.ToString("F2");
│           │  349 │                 modified = true;
│           │  350 │             }
│           │  351 │ 
│           │  352 │             // Recursively process children
│           │  353 │             foreach (var child in obj.Children)
│           │  354 │             {
│           │  355 │                 modified |= TransformNumericValuesRecursive(child, transformationFunc);
│           │  356 │             }
│           │  357 │ 
│           │  358 │             return modified;
│           │  359 │         }
│           │  360 │ 
│           │  361 │         #endregion
│           │  362 │     }
│           │  363 │ }
│           └──────────────────────────────────────────────────────────────────────
│   📁 Core
│   │   📁 Domain
│   │   │   📁 ObjectSet
│   │   │   └── 📄 ObjectSetModels.cs (3.50 KB, 2025-03-11 14:55:53)
│   │   │       ┌──────────────────────────────────────────────────────────────────────
│   │   │       │ FILE CONTENT: ObjectSetModels.cs
│   │   │       ├──────────────────────────────────────────────────────────────────────
│   │   │       │    1 │ ﻿using System;
│   │   │       │    2 │ using System.Collections.Generic;
│   │   │       │    3 │ 
│   │   │       │    4 │ namespace test.Core.Domain.ObjectSet
│   │   │       │    5 │ {
│   │   │       │    6 │     /// <summary>
│   │   │       │    7 │     /// Contains metadata information from an ObjectSet XML file
│   │   │       │    8 │     /// </summary>
│   │   │       │    9 │     public class MetaInformation
│   │   │       │   10 │     {
│   │   │       │   11 │         public string ExportMode { get; set; }
│   │   │       │   12 │         public string SemanticsFilter { get; set; }
│   │   │       │   13 │         public string RuntimeVersion { get; set; }
│   │   │       │   14 │         public string SourceVersion { get; set; }
│   │   │       │   15 │         public string ServerFullPath { get; set; }
│   │   │       │   16 │     }
│   │   │       │   17 │ 
│   │   │       │   18 │     /// <summary>
│   │   │       │   19 │     /// Definition of an object type from an ObjectSet XML file
│   │   │       │   20 │     /// </summary>
│   │   │       │   21 │     public class ObjectTypeDefinition
│   │   │       │   22 │     {
│   │   │       │   23 │         public string Name { get; set; }
│   │   │       │   24 │         public string DisplayName { get; set; }
│   │   │       │   25 │         public string Description { get; set; }
│   │   │       │   26 │         public List<PropertyTab> PropertyTabs { get; set; } = new();
│   │   │       │   27 │     }
│   │   │       │   28 │ 
│   │   │       │   29 │     /// <summary>
│   │   │       │   30 │     /// A property tab in an object type definition
│   │   │       │   31 │     /// </summary>
│   │   │       │   32 │     public class PropertyTab
│   │   │       │   33 │     {
│   │   │       │   34 │         public string Name { get; set; }
│   │   │       │   35 │         public List<PropertyGroup> PropertyGroups { get; set; } = new();
│   │   │       │   36 │     }
│   │   │       │   37 │ 
│   │   │       │   38 │     /// <summary>
│   │   │       │   39 │     /// A property group in a property tab
│   │   │       │   40 │     /// </summary>
│   │   │       │   41 │     public class PropertyGroup
│   │   │       │   42 │     {
│   │   │       │   43 │         public string Name { get; set; }
│   │   │       │   44 │         public List<Parameter> Parameters { get; set; } = new();
│   │   │       │   45 │         public List<Variable> Variables { get; set; } = new();
│   │   │       │   46 │     }
│   │   │       │   47 │ 
│   │   │       │   48 │     /// <summary>
│   │   │       │   49 │     /// A parameter definition
│   │   │       │   50 │     /// </summary>
│   │   │       │   51 │     public class Parameter
│   │   │       │   52 │     {
│   │   │       │   53 │         public string Name { get; set; }
│   │   │       │   54 │         public string DisplayName { get; set; }
│   │   │       │   55 │         public string Description { get; set; }
│   │   │       │   56 │         public ParameterType Type { get; set; }
│   │   │       │   57 │         public string Unit { get; set; }
│   │   │       │   58 │         public string InitValue { get; set; }
│   │   │       │   59 │         public string FileContents { get; set; }
│   │   │       │   60 │     }
│   │   │       │   61 │ 
│   │   │       │   62 │     /// <summary>
│   │   │       │   63 │     /// A variable definition
│   │   │       │   64 │     /// </summary>
│   │   │       │   65 │     public class Variable
│   │   │       │   66 │     {
│   │   │       │   67 │         public string Name { get; set; }
│   │   │       │   68 │         public string DisplayName { get; set; }
│   │   │       │   69 │         public string Description { get; set; }
│   │   │       │   70 │         public ParameterType Type { get; set; }
│   │   │       │   71 │         public string Unit { get; set; }
│   │   │       │   72 │         public Runtime Runtime { get; set; }
│   │   │       │   73 │     }
│   │   │       │   74 │ 
│   │   │       │   75 │     /// <summary>
│   │   │       │   76 │     /// Runtime properties for a variable
│   │   │       │   77 │     /// </summary>
│   │   │       │   78 │     public class Runtime
│   │   │       │   79 │     {
│   │   │       │   80 │         public bool ReadOnly { get; set; }
│   │   │       │   81 │         public string RetainLevel { get; set; }
│   │   │       │   82 │         public bool Forceable { get; set; }
│   │   │       │   83 │         public string InitValue { get; set; }
│   │   │       │   84 │     }
│   │   │       │   85 │ 
│   │   │       │   86 │     /// <summary>
│   │   │       │   87 │     /// Type information for a parameter or variable
│   │   │       │   88 │     /// </summary>
│   │   │       │   89 │     public class ParameterType
│   │   │       │   90 │     {
│   │   │       │   91 │         public string Value { get; set; }
│   │   │       │   92 │     }
│   │   │       │   93 │ 
│   │   │       │   94 │     /// <summary>
│   │   │       │   95 │     /// Represents an exported object from an ObjectSet XML file
│   │   │       │   96 │     /// </summary>
│   │   │       │   97 │     public class ExportedObject
│   │   │       │   98 │     {
│   │   │       │   99 │         public string Name { get; set; }
│   │   │       │  100 │         public string Value { get; set; }
│   │   │       │  101 │         public List<ExportedObject> Children { get; set; } = new();
│   │   │       │  102 │         public Dictionary<string, string> Properties { get; set; } = new();
│   │   │       │  103 │     }
│   │   │       │  104 │ 
│   │   │       │  105 │     /// <summary>
│   │   │       │  106 │     /// Result of parsing an ObjectSet XML file
│   │   │       │  107 │     /// </summary>
│   │   │       │  108 │     public class ObjectSetParseResult
│   │   │       │  109 │     {
│   │   │       │  110 │         public MetaInformation MetaInfo { get; set; }
│   │   │       │  111 │         public List<ObjectTypeDefinition> Types { get; set; } = new();
│   │   │       │  112 │         public List<ExportedObject> ExportedObjects { get; set; } = new();
│   │   │       │  113 │         public bool Success { get; set; }
│   │   │       │  114 │         public string ErrorMessage { get; set; }
│   │   │       │  115 │     }
│   │   │       │  116 │ }
│   │   │       └──────────────────────────────────────────────────────────────────────
│   │   ├── 📄 Controller.cs (7.35 KB, 2025-03-11 14:52:32)
│   │   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │   │ FILE CONTENT: Controller.cs
│   │   │   ├──────────────────────────────────────────────────────────────────────
│   │   │   │    1 │ ﻿using System;
│   │   │   │    2 │ using System.Collections.Generic;
│   │   │   │    3 │ using System.Linq;
│   │   │   │    4 │ using System.Text;
│   │   │   │    5 │ using System.Threading.Tasks;
│   │   │   │    6 │ 
│   │   │   │    7 │ namespace test.Core.Domain
│   │   │   │    8 │ {
│   │   │   │    9 │     /// <summary>
│   │   │   │   10 │     /// Represents an HVAC controller in the system.
│   │   │   │   11 │     /// Core domain entity that encapsulates controller-specific business rules.
│   │   │   │   12 │     /// </summary>
│   │   │   │   13 │     public class Controller
│   │   │   │   14 │     {
│   │   │   │   15 │         private readonly List<ControllerObject> _objects = new();
│   │   │   │   16 │         private readonly Dictionary<string, string> _properties = new(StringComparer.OrdinalIgnoreCase);
│   │   │   │   17 │ 
│   │   │   │   18 │         /// <summary>
│   │   │   │   19 │         /// The unique name of the controller
│   │   │   │   20 │         /// </summary>
│   │   │   │   21 │         /// 
│   │   │   │   22 │         public string Name { get; private set; }
│   │   │   │   23 │ 
│   │   │   │   24 │         /// <summary>
│   │   │   │   25 │         /// The model number of the controller
│   │   │   │   26 │         /// </summary>
│   │   │   │   27 │         public string Model { get; private set; }
│   │   │   │   28 │ 
│   │   │   │   29 │         /// <summary>
│   │   │   │   30 │         /// Port information for the controller
│   │   │   │   31 │         /// </summary>
│   │   │   │   32 │         public string Port { get; private set; }
│   │   │   │   33 │ 
│   │   │   │   34 │         /// <summary>
│   │   │   │   35 │         /// Serial number of the controller
│   │   │   │   36 │         /// </summary>
│   │   │   │   37 │         public string SerialNumber { get; private set; }
│   │   │   │   38 │ 
│   │   │   │   39 │         /// <summary>
│   │   │   │   40 │         /// InfinetId of the controller
│   │   │   │   41 │         /// </summary>
│   │   │   │   42 │         public string InfinetId { get; private set; }
│   │   │   │   43 │ 
│   │   │   │   44 │ 
│   │   │   │   45 │         /// <summary>
│   │   │   │   46 │         /// Gets the controller family based on the model
│   │   │   │   47 │         /// </summary>
│   │   │   │   48 │         public ControllerModelInfo.ControllerFamily Family =>
│   │   │   │   49 │             ControllerModelInfo.DetermineControllerFamily(Model);
│   │   │   │   50 │ 
│   │   │   │   51 │         /// <summary>
│   │   │   │   52 │         /// Gets the model properties if available
│   │   │   │   53 │         /// </summary>
│   │   │   │   54 │         public ControllerModelInfo.ModelProperties ModelProperties =>
│   │   │   │   55 │             ControllerModelInfo.GetModelProperties(Model);
│   │   │   │   56 │ 
│   │   │   │   57 │         /// <summary>
│   │   │   │   58 │         /// Gets the number of analog outputs for this controller model
│   │   │   │   59 │         /// </summary>
│   │   │   │   60 │         public int AnalogOutputs => ModelProperties?.AnalogOutputs ?? 0;
│   │   │   │   61 │ 
│   │   │   │   62 │         /// <summary>
│   │   │   │   63 │         /// Gets the number of digital outputs for this controller model
│   │   │   │   64 │         /// </summary>
│   │   │   │   65 │         public int DigitalOutputs => ModelProperties?.DigitalOutputs ?? 0;
│   │   │   │   66 │ 
│   │   │   │   67 │         /// <summary>
│   │   │   │   68 │         /// Gets the number of digital inputs for this controller model
│   │   │   │   69 │         /// </summary>
│   │   │   │   70 │         public int DigitalInputs => ModelProperties?.DigitalInputs ?? 0;
│   │   │   │   71 │ 
│   │   │   │   72 │ 
│   │   │   │   73 │         /// <summary>
│   │   │   │   74 │         /// Read-only collection of objects contained in this controller
│   │   │   │   75 │         /// </summary>
│   │   │   │   76 │         public IReadOnlyCollection<ControllerObject> Objects => _objects.AsReadOnly();
│   │   │   │   77 │ 
│   │   │   │   78 │         /// <summary>
│   │   │   │   79 │         /// Read-only dictionary of additional properties for this controller
│   │   │   │   80 │         /// </summary>
│   │   │   │   81 │         public IReadOnlyDictionary<string, string> Properties => _properties;
│   │   │   │   82 │ 
│   │   │   │   83 │         /// <summary>
│   │   │   │   84 │         /// Creates a new controller instance
│   │   │   │   85 │         /// </summary>
│   │   │   │   86 │         /// <param name="name">The name of the controller</param>
│   │   │   │   87 │         /// <param name="model">The model number</param>
│   │   │   │   88 │         public Controller(string name, string model)
│   │   │   │   89 │         {
│   │   │   │   90 │             if (string.IsNullOrWhiteSpace(name))
│   │   │   │   91 │                 throw new ArgumentException("Controller name cannot be empty", nameof(name));
│   │   │   │   92 │ 
│   │   │   │   93 │             Name = name;
│   │   │   │   94 │             Model = model ?? string.Empty;
│   │   │   │   95 │         }
│   │   │   │   96 │ 
│   │   │   │   97 │         /// <summary>
│   │   │   │   98 │         /// Sets the connection information for this controller
│   │   │   │   99 │         /// </summary>
│   │   │   │  100 │         public void SetConnectionInfo(string port, string serialNumber, string infinetId)
│   │   │   │  101 │         {
│   │   │   │  102 │             Port = port;
│   │   │   │  103 │             SerialNumber = serialNumber;
│   │   │   │  104 │             InfinetId = infinetId;
│   │   │   │  105 │         }
│   │   │   │  106 │ 
│   │   │   │  107 │         /// <summary>
│   │   │   │  108 │         /// Adds an object to this controller
│   │   │   │  109 │         /// </summary>
│   │   │   │  110 │         /// <param name="obj">The object to add</param>
│   │   │   │  111 │         /// <exception cref="ArgumentException">Thrown if an object with the same name already exists</exception>
│   │   │   │  112 │         public void AddObject(ControllerObject obj)
│   │   │   │  113 │         {
│   │   │   │  114 │             if (obj == null)
│   │   │   │  115 │                 throw new ArgumentNullException(nameof(obj));
│   │   │   │  116 │ 
│   │   │   │  117 │             if (_objects.Any(o => o.Name == obj.Name && o.Type == obj.Type))
│   │   │   │  118 │                 throw new ArgumentException($"An object with name '{obj.Name}' and type '{obj.Type}' already exists in this controller");
│   │   │   │  119 │ 
│   │   │   │  120 │             _objects.Add(obj);
│   │   │   │  121 │         }
│   │   │   │  122 │ 
│   │   │   │  123 │         /// <summary>
│   │   │   │  124 │         /// Sets a property value for this controller
│   │   │   │  125 │         /// </summary>
│   │   │   │  126 │         /// <param name="key">The property key</param>
│   │   │   │  127 │         /// <param name="value">The property value</param>
│   │   │   │  128 │         public void SetProperty(string key, string value)
│   │   │   │  129 │         {
│   │   │   │  130 │             if (string.IsNullOrEmpty(key))
│   │   │   │  131 │                 throw new ArgumentException("Property key cannot be empty", nameof(key));
│   │   │   │  132 │ 
│   │   │   │  133 │             _properties[key] = value ?? string.Empty;
│   │   │   │  134 │         }
│   │   │   │  135 │ 
│   │   │   │  136 │         /// <summary>
│   │   │   │  137 │         /// Gets a property value or default if not found
│   │   │   │  138 │         /// </summary>
│   │   │   │  139 │         /// <param name="key">The property key</param>
│   │   │   │  140 │         /// <param name="defaultValue">The default value to return if property is not found</param>
│   │   │   │  141 │         /// <returns>The property value or default</returns>
│   │   │   │  142 │         public string GetProperty(string key, string defaultValue = "")
│   │   │   │  143 │         {
│   │   │   │  144 │             if (string.IsNullOrEmpty(key))
│   │   │   │  145 │                 return defaultValue;
│   │   │   │  146 │ 
│   │   │   │  147 │             return _properties.TryGetValue(key, out var value) ? value : defaultValue;
│   │   │   │  148 │         }
│   │   │   │  149 │ 
│   │   │   │  150 │         /// <summary>
│   │   │   │  151 │         /// Finds objects by type
│   │   │   │  152 │         /// </summary>
│   │   │   │  153 │         /// <param name="typeName">The type name to search for</param>
│   │   │   │  154 │         /// <returns>A collection of matching objects</returns>
│   │   │   │  155 │         public IEnumerable<ControllerObject> FindObjectsByType(string typeName)
│   │   │   │  156 │         {
│   │   │   │  157 │             if (string.IsNullOrEmpty(typeName))
│   │   │   │  158 │                 return Enumerable.Empty<ControllerObject>();
│   │   │   │  159 │ 
│   │   │   │  160 │             return _objects.Where(o => o.Type.Equals(typeName, StringComparison.OrdinalIgnoreCase));
│   │   │   │  161 │         }
│   │   │   │  162 │ 
│   │   │   │  163 │         /// <summary>
│   │   │   │  164 │         /// Finds an object by name
│   │   │   │  165 │         /// </summary>
│   │   │   │  166 │         /// 
│   │   │   │  167 │         /// <param name="name">The object name</param>
│   │   │   │  168 │         /// <returns>The object or null if not found</returns>
│   │   │   │  169 │         public ControllerObject FindObjectByName(string name)
│   │   │   │  170 │         {
│   │   │   │  171 │             if (string.IsNullOrEmpty(name))
│   │   │   │  172 │                 return null;
│   │   │   │  173 │ 
│   │   │   │  174 │             return _objects.FirstOrDefault(o => o.Name.Equals(name, StringComparison.OrdinalIgnoreCase));
│   │   │   │  175 │         }
│   │   │   │  176 │ 
│   │   │   │  177 │         /// <summary>
│   │   │   │  178 │         /// Finds an object by alias
│   │   │   │  179 │         /// </summary>
│   │   │   │  180 │         /// <param name="alias">The object alias</param>
│   │   │   │  181 │         /// <returns>The object or null if not found</returns>
│   │   │   │  182 │         public ControllerObject FindObjectByAlias(string alias)
│   │   │   │  183 │         {
│   │   │   │  184 │             if (string.IsNullOrEmpty(alias))
│   │   │   │  185 │                 return null;
│   │   │   │  186 │ 
│   │   │   │  187 │             return _objects.FirstOrDefault(o =>
│   │   │   │  188 │                 !string.IsNullOrEmpty(o.Alias) &&
│   │   │   │  189 │                 o.Alias.Equals(alias, StringComparison.OrdinalIgnoreCase));
│   │   │   │  190 │         }
│   │   │   │  191 │ 
│   │   │   │  192 │         /// <summary>
│   │   │   │  193 │         /// Removes an object from this controller
│   │   │   │  194 │         /// </summary>
│   │   │   │  195 │         /// <param name="name">The name of the object to remove</param>
│   │   │   │  196 │         /// <returns>True if removed, false if not found</returns>
│   │   │   │  197 │         public bool RemoveObject(string name)
│   │   │   │  198 │         {
│   │   │   │  199 │             if (string.IsNullOrEmpty(name))
│   │   │   │  200 │                 return false;
│   │   │   │  201 │ 
│   │   │   │  202 │             var obj = FindObjectByName(name);
│   │   │   │  203 │             if (obj == null)
│   │   │   │  204 │                 return false;
│   │   │   │  205 │ 
│   │   │   │  206 │             return _objects.Remove(obj);
│   │   │   │  207 │         }
│   │   │   │  208 │     }
│   │   │   │  209 │ }
│   │   │   └──────────────────────────────────────────────────────────────────────
│   │   ├── 📄 ControllerGroup.cs (3.49 KB, 2025-03-11 13:29:15)
│   │   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │   │ FILE CONTENT: ControllerGroup.cs
│   │   │   ├──────────────────────────────────────────────────────────────────────
│   │   │   │    1 │ ﻿using System;
│   │   │   │    2 │ using System.Collections.Generic;
│   │   │   │    3 │ 
│   │   │   │    4 │ namespace test.Core.Domain
│   │   │   │    5 │ {
│   │   │   │    6 │     /// <summary>
│   │   │   │    7 │     /// Represents a controller group for comparison and analysis.
│   │   │   │    8 │     /// This is the definitive domain model implementation.
│   │   │   │    9 │     /// </summary>
│   │   │   │   10 │     public class ControllerGroup
│   │   │   │   11 │     {
│   │   │   │   12 │         /// <summary>
│   │   │   │   13 │         /// The group identifier
│   │   │   │   14 │         /// </summary>
│   │   │   │   15 │         public string GroupIdentifier { get; }
│   │   │   │   16 │ 
│   │   │   │   17 │         /// <summary>
│   │   │   │   18 │         /// The controller names in this group
│   │   │   │   19 │         /// </summary>
│   │   │   │   20 │         public List<string> ControllerNames { get; } = new();
│   │   │   │   21 │ 
│   │   │   │   22 │         /// <summary>
│   │   │   │   23 │         /// Original values from controllers (pre-replacement)
│   │   │   │   24 │         /// </summary>
│   │   │   │   25 │         public Dictionary<string, string> OriginalValues { get; } = new(StringComparer.OrdinalIgnoreCase);
│   │   │   │   26 │ 
│   │   │   │   27 │         /// <summary>
│   │   │   │   28 │         /// Processed values after name processing
│   │   │   │   29 │         /// </summary>
│   │   │   │   30 │         public Dictionary<string, string> ProcessedValues { get; } = new(StringComparer.OrdinalIgnoreCase);
│   │   │   │   31 │ 
│   │   │   │   32 │         /// <summary>
│   │   │   │   33 │         /// Shared values after name processing (alias for ProcessedValues for backward compatibility)
│   │   │   │   34 │         /// </summary>
│   │   │   │   35 │         public Dictionary<string, string> SharedValues => ProcessedValues;
│   │   │   │   36 │ 
│   │   │   │   37 │         /// <summary>
│   │   │   │   38 │         /// Mapping from original to processed names
│   │   │   │   39 │         /// </summary>
│   │   │   │   40 │         public Dictionary<string, string> NameMapping { get; } = new(StringComparer.OrdinalIgnoreCase);
│   │   │   │   41 │ 
│   │   │   │   42 │         /// <summary>
│   │   │   │   43 │         /// Creates a new controller group
│   │   │   │   44 │         /// </summary>
│   │   │   │   45 │         /// <param name="identifier">The group identifier</param>
│   │   │   │   46 │         public ControllerGroup(string identifier)
│   │   │   │   47 │         {
│   │   │   │   48 │             GroupIdentifier = identifier ?? throw new ArgumentNullException(nameof(identifier));
│   │   │   │   49 │         }
│   │   │   │   50 │ 
│   │   │   │   51 │         /// <summary>
│   │   │   │   52 │         /// Adds a controller name to the group
│   │   │   │   53 │         /// </summary>
│   │   │   │   54 │         /// <param name="controllerName">The controller name to add</param>
│   │   │   │   55 │         public void AddControllerName(string controllerName)
│   │   │   │   56 │         {
│   │   │   │   57 │             if (!string.IsNullOrWhiteSpace(controllerName))
│   │   │   │   58 │             {
│   │   │   │   59 │                 ControllerNames.Add(controllerName);
│   │   │   │   60 │             }
│   │   │   │   61 │         }
│   │   │   │   62 │ 
│   │   │   │   63 │         /// <summary>
│   │   │   │   64 │         /// Adds a value to the original values dictionary
│   │   │   │   65 │         /// </summary>
│   │   │   │   66 │         /// <param name="key">The key</param>
│   │   │   │   67 │         /// <param name="value">The value</param>
│   │   │   │   68 │         public void AddOriginalValue(string key, string value)
│   │   │   │   69 │         {
│   │   │   │   70 │             if (!string.IsNullOrWhiteSpace(key))
│   │   │   │   71 │             {
│   │   │   │   72 │                 OriginalValues[key] = value ?? string.Empty;
│   │   │   │   73 │             }
│   │   │   │   74 │         }
│   │   │   │   75 │ 
│   │   │   │   76 │         /// <summary>
│   │   │   │   77 │         /// Adds a value to the processed values dictionary
│   │   │   │   78 │         /// </summary>
│   │   │   │   79 │         /// <param name="key">The key</param>
│   │   │   │   80 │         /// <param name="value">The value</param>
│   │   │   │   81 │         public void AddProcessedValue(string key, string value)
│   │   │   │   82 │         {
│   │   │   │   83 │             if (!string.IsNullOrWhiteSpace(key))
│   │   │   │   84 │             {
│   │   │   │   85 │                 ProcessedValues[key] = value ?? string.Empty;
│   │   │   │   86 │             }
│   │   │   │   87 │         }
│   │   │   │   88 │ 
│   │   │   │   89 │         /// <summary>
│   │   │   │   90 │         /// Adds a mapping entry
│   │   │   │   91 │         /// </summary>
│   │   │   │   92 │         /// <param name="originalName">The original name</param>
│   │   │   │   93 │         /// <param name="processedName">The processed name</param>
│   │   │   │   94 │         public void AddMapping(string originalName, string processedName)
│   │   │   │   95 │         {
│   │   │   │   96 │             if (!string.IsNullOrWhiteSpace(originalName) && !string.IsNullOrWhiteSpace(processedName))
│   │   │   │   97 │             {
│   │   │   │   98 │                 NameMapping[originalName] = processedName;
│   │   │   │   99 │             }
│   │   │   │  100 │         }
│   │   │   │  101 │     }
│   │   │   │  102 │ }
│   │   │   └──────────────────────────────────────────────────────────────────────
│   │   ├── 📄 ControllerModelInfo.cs (3.49 KB, 2025-03-11 13:50:08)
│   │   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │   │ FILE CONTENT: ControllerModelInfo.cs
│   │   │   ├──────────────────────────────────────────────────────────────────────
│   │   │   │    1 │ ﻿// Place in test/Core/Domain/ControllerModelInfo.cs
│   │   │   │    2 │ using System.Collections.Generic;
│   │   │   │    3 │ 
│   │   │   │    4 │ namespace test.Core.Domain
│   │   │   │    5 │ {
│   │   │   │    6 │     /// <summary>
│   │   │   │    7 │     /// Provides information and operations related to controller models
│   │   │   │    8 │     /// </summary>
│   │   │   │    9 │     public class ControllerModelInfo
│   │   │   │   10 │     {
│   │   │   │   11 │         // Restore the enum for type safety instead of using strings
│   │   │   │   12 │         public enum ControllerFamily
│   │   │   │   13 │         {
│   │   │   │   14 │             Infinity,
│   │   │   │   15 │             I2,
│   │   │   │   16 │             Unknown
│   │   │   │   17 │         }
│   │   │   │   18 │ 
│   │   │   │   19 │         // Maintain the model lists from the original and the current implementation
│   │   │   │   20 │         private static readonly HashSet<string> InfinityModels = new HashSet<string>
│   │   │   │   21 │         {
│   │   │   │   22 │             "800", "810", "843", "846", "850", "851", "853", "890",
│   │   │   │   23 │             "700", "891", "892", "920", "780", "865", "866", "867",
│   │   │   │   24 │             "701", "781"
│   │   │   │   25 │         };
│   │   │   │   26 │ 
│   │   │   │   27 │         private static readonly HashSet<string> I2Models = new HashSet<string>
│   │   │   │   28 │         {
│   │   │   │   29 │             "i2624", "i2608", "i2800", "i2804", "i2850", "i2851",
│   │   │   │   30 │             "i2853", "i2865", "i2866", "i2885", "i2867", "i2920"
│   │   │   │   31 │         };
│   │   │   │   32 │ 
│   │   │   │   33 │         // Restore the ModelProperties class with I/O counts
│   │   │   │   34 │         public class ModelProperties
│   │   │   │   35 │         {
│   │   │   │   36 │             public int AnalogOutputs { get; set; }
│   │   │   │   37 │             public int DigitalOutputs { get; set; }
│   │   │   │   38 │             public int DigitalInputs { get; set; }
│   │   │   │   39 │             // Add more properties as needed
│   │   │   │   40 │         }
│   │   │   │   41 │ 
│   │   │   │   42 │         // Restore the model specifications dictionary
│   │   │   │   43 │         private static readonly Dictionary<string, ModelProperties> ModelSpecifications = new Dictionary<string, ModelProperties>();
│   │   │   │   44 │ 
│   │   │   │   45 │         /// <summary>
│   │   │   │   46 │         /// Determines the controller family based on the model number
│   │   │   │   47 │         /// </summary>
│   │   │   │   48 │         /// <param name="modelNumber">The controller model number</param>
│   │   │   │   49 │         /// <returns>The controller family</returns>
│   │   │   │   50 │         public static ControllerFamily DetermineControllerFamily(string modelNumber)
│   │   │   │   51 │         {
│   │   │   │   52 │             if (string.IsNullOrWhiteSpace(modelNumber))
│   │   │   │   53 │                 return ControllerFamily.Unknown;
│   │   │   │   54 │ 
│   │   │   │   55 │             // Check exact matches first
│   │   │   │   56 │             if (InfinityModels.Contains(modelNumber))
│   │   │   │   57 │                 return ControllerFamily.Infinity;
│   │   │   │   58 │ 
│   │   │   │   59 │             if (I2Models.Contains(modelNumber))
│   │   │   │   60 │                 return ControllerFamily.I2;
│   │   │   │   61 │ 
│   │   │   │   62 │             // Apply pattern matching rules
│   │   │   │   63 │             if (modelNumber.Length == 3 && int.TryParse(modelNumber, out _))
│   │   │   │   64 │                 return ControllerFamily.Infinity;
│   │   │   │   65 │ 
│   │   │   │   66 │             if (modelNumber.StartsWith("i2", System.StringComparison.OrdinalIgnoreCase))
│   │   │   │   67 │                 return ControllerFamily.I2;
│   │   │   │   68 │ 
│   │   │   │   69 │             return ControllerFamily.Unknown;
│   │   │   │   70 │         }
│   │   │   │   71 │ 
│   │   │   │   72 │         /// <summary>
│   │   │   │   73 │         /// Gets the properties for a specific model
│   │   │   │   74 │         /// </summary>
│   │   │   │   75 │         /// <param name="modelNumber">The model number</param>
│   │   │   │   76 │         /// <returns>The model properties or null if not found</returns>
│   │   │   │   77 │         public static ModelProperties GetModelProperties(string modelNumber)
│   │   │   │   78 │         {
│   │   │   │   79 │             if (ModelSpecifications.TryGetValue(modelNumber, out var properties))
│   │   │   │   80 │                 return properties;
│   │   │   │   81 │ 
│   │   │   │   82 │             return null;
│   │   │   │   83 │         }
│   │   │   │   84 │ 
│   │   │   │   85 │         /// <summary>
│   │   │   │   86 │         /// Sets the properties for a specific model
│   │   │   │   87 │         /// </summary>
│   │   │   │   88 │         /// <param name="modelNumber">The model number</param>
│   │   │   │   89 │         /// <param name="properties">The properties to set</param>
│   │   │   │   90 │         public static void SetModelProperties(string modelNumber, ModelProperties properties)
│   │   │   │   91 │         {
│   │   │   │   92 │             ModelSpecifications[modelNumber] = properties;
│   │   │   │   93 │         }
│   │   │   │   94 │     }
│   │   │   │   95 │ }
│   │   │   └──────────────────────────────────────────────────────────────────────
│   │   ├── 📄 ControllerObject.cs (5.88 KB, 2025-03-11 14:52:32)
│   │   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │   │ FILE CONTENT: ControllerObject.cs
│   │   │   ├──────────────────────────────────────────────────────────────────────
│   │   │   │    1 │ ﻿using System;
│   │   │   │    2 │ using System.Collections.Generic;
│   │   │   │    3 │ using System.Linq;
│   │   │   │    4 │ using System.Text;
│   │   │   │    5 │ using System.Threading.Tasks;
│   │   │   │    6 │ 
│   │   │   │    7 │ namespace test.Core.Domain
│   │   │   │    8 │ {
│   │   │   │    9 │     /// <summary>
│   │   │   │   10 │     /// Represents an object within an HVAC controller.
│   │   │   │   11 │     /// Core domain entity with associated business rules.
│   │   │   │   12 │     /// </summary>
│   │   │   │   13 │     public class ControllerObject
│   │   │   │   14 │     {
│   │   │   │   15 │         private readonly List<ControllerObject> _children = new();
│   │   │   │   16 │         private readonly Dictionary<string, string> _properties = new(StringComparer.OrdinalIgnoreCase);
│   │   │   │   17 │ 
│   │   │   │   18 │         /// <summary>
│   │   │   │   19 │         /// The type of this object
│   │   │   │   20 │         /// </summary>
│   │   │   │   21 │         public string Type { get; }
│   │   │   │   22 │ 
│   │   │   │   23 │         /// <summary>
│   │   │   │   24 │         /// The name of this object
│   │   │   │   25 │         /// </summary>
│   │   │   │   26 │         public string Name { get; }
│   │   │   │   27 │ 
│   │   │   │   28 │         /// <summary>
│   │   │   │   29 │         /// The alias of this object (optional)
│   │   │   │   30 │         /// </summary>
│   │   │   │   31 │         public string Alias { get; private set; }
│   │   │   │   32 │ 
│   │   │   │   33 │         /// <summary>
│   │   │   │   34 │         /// The value of this object
│   │   │   │   35 │         /// </summary>
│   │   │   │   36 │         public string Value { get; private set; }
│   │   │   │   37 │ 
│   │   │   │   38 │         /// <summary>
│   │   │   │   39 │         /// Indicates if this object has bytecode
│   │   │   │   40 │         /// </summary>
│   │   │   │   41 │         public bool HasByteCode { get; private set; }
│   │   │   │   42 │ 
│   │   │   │   43 │         /// <summary>
│   │   │   │   44 │         /// Read-only collection of child objects
│   │   │   │   45 │         /// </summary>
│   │   │   │   46 │         public IReadOnlyCollection<ControllerObject> Children => _children.AsReadOnly();
│   │   │   │   47 │ 
│   │   │   │   48 │         /// <summary>
│   │   │   │   49 │         /// Read-only dictionary of additional properties
│   │   │   │   50 │         /// </summary>
│   │   │   │   51 │         public IReadOnlyDictionary<string, string> Properties => _properties;
│   │   │   │   52 │ 
│   │   │   │   53 │         /// <summary>
│   │   │   │   54 │         /// Creates a new controller object
│   │   │   │   55 │         /// </summary>
│   │   │   │   56 │         /// <param name="type">The object type</param>
│   │   │   │   57 │         /// <param name="name">The object name</param>
│   │   │   │   58 │         /// <param name="value">The object value (optional)</param>
│   │   │   │   59 │         public ControllerObject(string type, string name, string value = "")
│   │   │   │   60 │         {
│   │   │   │   61 │             if (string.IsNullOrWhiteSpace(type))
│   │   │   │   62 │                 throw new ArgumentException("Object type cannot be empty", nameof(type));
│   │   │   │   63 │ 
│   │   │   │   64 │             if (string.IsNullOrWhiteSpace(name))
│   │   │   │   65 │                 throw new ArgumentException("Object name cannot be empty", nameof(name));
│   │   │   │   66 │ 
│   │   │   │   67 │             Type = type;
│   │   │   │   68 │             Name = name;
│   │   │   │   69 │             Value = value ?? string.Empty;
│   │   │   │   70 │ 
│   │   │   │   71 │             // Set HasByteCode based on type
│   │   │   │   72 │             HasByteCode = type.Equals("InfinityProgram", StringComparison.OrdinalIgnoreCase) ||
│   │   │   │   73 │                          type.Equals("InfinityFunction", StringComparison.OrdinalIgnoreCase);
│   │   │   │   74 │         }
│   │   │   │   75 │ 
│   │   │   │   76 │         /// <summary>
│   │   │   │   77 │         /// Sets the alias for this object
│   │   │   │   78 │         /// </summary>
│   │   │   │   79 │         /// <param name="alias">The alias to set</param>
│   │   │   │   80 │         public void SetAlias(string alias)
│   │   │   │   81 │         {
│   │   │   │   82 │             Alias = alias;
│   │   │   │   83 │         }
│   │   │   │   84 │ 
│   │   │   │   85 │         /// <summary>
│   │   │   │   86 │         /// Updates the value of this object
│   │   │   │   87 │         /// </summary>
│   │   │   │   88 │         /// <param name="newValue">The new value</param>
│   │   │   │   89 │         public void UpdateValue(string newValue)
│   │   │   │   90 │         {
│   │   │   │   91 │             Value = newValue ?? string.Empty;
│   │   │   │   92 │         }
│   │   │   │   93 │ 
│   │   │   │   94 │         /// <summary>
│   │   │   │   95 │         /// Sets a property value for this object
│   │   │   │   96 │         /// </summary>
│   │   │   │   97 │         /// <param name="key">The property key</param>
│   │   │   │   98 │         /// <param name="value">The property value</param>
│   │   │   │   99 │         public void SetProperty(string key, string value)
│   │   │   │  100 │         {
│   │   │   │  101 │             if (string.IsNullOrEmpty(key))
│   │   │   │  102 │                 throw new ArgumentException("Property key cannot be empty", nameof(key));
│   │   │   │  103 │ 
│   │   │   │  104 │             _properties[key] = value ?? string.Empty;
│   │   │   │  105 │         }
│   │   │   │  106 │ 
│   │   │   │  107 │         /// <summary>
│   │   │   │  108 │         /// Gets a property value or default if not found
│   │   │   │  109 │         /// </summary>
│   │   │   │  110 │         /// <param name="key">The property key</param>
│   │   │   │  111 │         /// <param name="defaultValue">The default value to return if property is not found</param>
│   │   │   │  112 │         /// <returns>The property value or default</returns>
│   │   │   │  113 │         public string GetProperty(string key, string defaultValue = "")
│   │   │   │  114 │         {
│   │   │   │  115 │             if (string.IsNullOrEmpty(key))
│   │   │   │  116 │                 return defaultValue;
│   │   │   │  117 │ 
│   │   │   │  118 │             return _properties.TryGetValue(key, out var value) ? value : defaultValue;
│   │   │   │  119 │         }
│   │   │   │  120 │ 
│   │   │   │  121 │         /// <summary>
│   │   │   │  122 │         /// Sets whether this object has bytecode
│   │   │   │  123 │         /// </summary>
│   │   │   │  124 │         /// <param name="hasByteCode">True if this object has bytecode, false otherwise</param>
│   │   │   │  125 │         public void SetHasByteCode(bool hasByteCode)
│   │   │   │  126 │         {
│   │   │   │  127 │             HasByteCode = hasByteCode;
│   │   │   │  128 │         }
│   │   │   │  129 │ 
│   │   │   │  130 │         /// <summary>
│   │   │   │  131 │         /// Adds a child object
│   │   │   │  132 │         /// </summary>
│   │   │   │  133 │         /// <param name="child">The child object to add</param>
│   │   │   │  134 │         public void AddChild(ControllerObject child)
│   │   │   │  135 │         {
│   │   │   │  136 │             if (child == null)
│   │   │   │  137 │                 throw new ArgumentNullException(nameof(child));
│   │   │   │  138 │ 
│   │   │   │  139 │             if (_children.Any(c => c.Name == child.Name && c.Type == child.Type))
│   │   │   │  140 │                 throw new ArgumentException($"A child object with name '{child.Name}' and type '{child.Type}' already exists");
│   │   │   │  141 │ 
│   │   │   │  142 │             _children.Add(child);
│   │   │   │  143 │         }
│   │   │   │  144 │ 
│   │   │   │  145 │         /// <summary>
│   │   │   │  146 │         /// Finds a child object by name
│   │   │   │  147 │         /// </summary>
│   │   │   │  148 │         /// <param name="name">The name to search for</param>
│   │   │   │  149 │         /// <returns>The matching object or null if not found</returns>
│   │   │   │  150 │         public ControllerObject FindChild(string name)
│   │   │   │  151 │         {
│   │   │   │  152 │             if (string.IsNullOrEmpty(name))
│   │   │   │  153 │                 return null;
│   │   │   │  154 │ 
│   │   │   │  155 │             return _children.FirstOrDefault(c => c.Name.Equals(name, StringComparison.OrdinalIgnoreCase));
│   │   │   │  156 │         }
│   │   │   │  157 │ 
│   │   │   │  158 │         /// <summary>
│   │   │   │  159 │         /// Removes a child object
│   │   │   │  160 │         /// </summary>
│   │   │   │  161 │         /// <param name="name">The name of the child to remove</param>
│   │   │   │  162 │         /// <returns>True if removed, false if not found</returns>
│   │   │   │  163 │         public bool RemoveChild(string name)
│   │   │   │  164 │         {
│   │   │   │  165 │             var child = FindChild(name);
│   │   │   │  166 │             if (child == null)
│   │   │   │  167 │                 return false;
│   │   │   │  168 │ 
│   │   │   │  169 │             return _children.Remove(child);
│   │   │   │  170 │         }
│   │   │   │  171 │     }
│   │   │   │  172 │ }
│   │   │   └──────────────────────────────────────────────────────────────────────
│   │   ├── 📄 CustomTypeFile.cs (2.30 KB, 2025-03-11 09:48:27)
│   │   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │   │ FILE CONTENT: CustomTypeFile.cs
│   │   │   ├──────────────────────────────────────────────────────────────────────
│   │   │   │    1 │ ﻿using System;
│   │   │   │    2 │ using System.Collections.Generic;
│   │   │   │    3 │ using System.Linq;
│   │   │   │    4 │ using System.Text;
│   │   │   │    5 │ using System.Threading.Tasks;
│   │   │   │    6 │ 
│   │   │   │    7 │ namespace test.Core.Domain
│   │   │   │    8 │ {
│   │   │   │    9 │     /// <summary>
│   │   │   │   10 │     /// Represents a custom type file in a project.
│   │   │   │   11 │     /// </summary>
│   │   │   │   12 │     public class CustomTypeFile
│   │   │   │   13 │     {
│   │   │   │   14 │         /// <summary>
│   │   │   │   15 │         /// The file name
│   │   │   │   16 │         /// </summary>
│   │   │   │   17 │         public string FileName { get; }
│   │   │   │   18 │ 
│   │   │   │   19 │         /// <summary>
│   │   │   │   20 │         /// The number of types in the file
│   │   │   │   21 │         /// </summary>
│   │   │   │   22 │         public int TypeCount { get; private set; }
│   │   │   │   23 │ 
│   │   │   │   24 │         /// <summary>
│   │   │   │   25 │         /// The description of the file
│   │   │   │   26 │         /// </summary>
│   │   │   │   27 │         public string Description { get; private set; }
│   │   │   │   28 │ 
│   │   │   │   29 │         /// <summary>
│   │   │   │   30 │         /// The date the file was last modified
│   │   │   │   31 │         /// </summary>
│   │   │   │   32 │         public DateTime LastModified { get; private set; }
│   │   │   │   33 │ 
│   │   │   │   34 │         /// <summary>
│   │   │   │   35 │         /// Creates a new custom type file
│   │   │   │   36 │         /// </summary>
│   │   │   │   37 │         /// <param name="fileName">The file name</param>
│   │   │   │   38 │         /// <param name="typeCount">The number of types</param>
│   │   │   │   39 │         /// <param name="description">The description</param>
│   │   │   │   40 │         public CustomTypeFile(string fileName, int typeCount, string description)
│   │   │   │   41 │         {
│   │   │   │   42 │             if (string.IsNullOrWhiteSpace(fileName))
│   │   │   │   43 │                 throw new ArgumentException("File name cannot be empty", nameof(fileName));
│   │   │   │   44 │ 
│   │   │   │   45 │             FileName = fileName;
│   │   │   │   46 │             TypeCount = typeCount;
│   │   │   │   47 │             Description = description ?? string.Empty;
│   │   │   │   48 │             LastModified = DateTime.UtcNow;
│   │   │   │   49 │         }
│   │   │   │   50 │ 
│   │   │   │   51 │         /// <summary>
│   │   │   │   52 │         /// Updates the description of the file
│   │   │   │   53 │         /// </summary>
│   │   │   │   54 │         /// <param name="description">The new description</param>
│   │   │   │   55 │         public void UpdateDescription(string description)
│   │   │   │   56 │         {
│   │   │   │   57 │             Description = description ?? string.Empty;
│   │   │   │   58 │             LastModified = DateTime.UtcNow;
│   │   │   │   59 │         }
│   │   │   │   60 │ 
│   │   │   │   61 │         /// <summary>
│   │   │   │   62 │         /// Updates the type count
│   │   │   │   63 │         /// </summary>
│   │   │   │   64 │         /// <param name="typeCount">The new type count</param>
│   │   │   │   65 │         public void UpdateTypeCount(int typeCount)
│   │   │   │   66 │         {
│   │   │   │   67 │             if (typeCount < 0)
│   │   │   │   68 │                 throw new ArgumentException("Type count cannot be negative", nameof(typeCount));
│   │   │   │   69 │ 
│   │   │   │   70 │             TypeCount = typeCount;
│   │   │   │   71 │             LastModified = DateTime.UtcNow;
│   │   │   │   72 │         }
│   │   │   │   73 │     }
│   │   │   │   74 │ }
│   │   │   └──────────────────────────────────────────────────────────────────────
│   │   ├── 📄 ImportedFile.cs (2.24 KB, 2025-03-11 09:48:27)
│   │   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │   │ FILE CONTENT: ImportedFile.cs
│   │   │   ├──────────────────────────────────────────────────────────────────────
│   │   │   │    1 │ ﻿using System;
│   │   │   │    2 │ using System.Collections.Generic;
│   │   │   │    3 │ using System.Linq;
│   │   │   │    4 │ using System.Text;
│   │   │   │    5 │ using System.Threading.Tasks;
│   │   │   │    6 │ 
│   │   │   │    7 │ namespace test.Core.Domain
│   │   │   │    8 │ {
│   │   │   │    9 │     /// <summary>
│   │   │   │   10 │     /// Represents a file imported into a project.
│   │   │   │   11 │     /// </summary>
│   │   │   │   12 │     public class ImportedFile
│   │   │   │   13 │     {
│   │   │   │   14 │         /// <summary>
│   │   │   │   15 │         /// The file path
│   │   │   │   16 │         /// </summary>
│   │   │   │   17 │         public string FilePath { get; }
│   │   │   │   18 │ 
│   │   │   │   19 │         /// <summary>
│   │   │   │   20 │         /// The file name
│   │   │   │   21 │         /// </summary>
│   │   │   │   22 │         public string FileName { get; }
│   │   │   │   23 │ 
│   │   │   │   24 │         /// <summary>
│   │   │   │   25 │         /// The file size in bytes
│   │   │   │   26 │         /// </summary>
│   │   │   │   27 │         public long FileSize { get; }
│   │   │   │   28 │ 
│   │   │   │   29 │         /// <summary>
│   │   │   │   30 │         /// The file type (e.g., dmp, xml)
│   │   │   │   31 │         /// </summary>
│   │   │   │   32 │         public string FileType { get; }
│   │   │   │   33 │ 
│   │   │   │   34 │         /// <summary>
│   │   │   │   35 │         /// The date the file was imported
│   │   │   │   36 │         /// </summary>
│   │   │   │   37 │         public DateTime ImportDate { get; }
│   │   │   │   38 │ 
│   │   │   │   39 │         /// <summary>
│   │   │   │   40 │         /// The status of the file
│   │   │   │   41 │         /// </summary>
│   │   │   │   42 │         public string Status { get; private set; }
│   │   │   │   43 │ 
│   │   │   │   44 │         /// <summary>
│   │   │   │   45 │         /// Creates a new imported file
│   │   │   │   46 │         /// </summary>
│   │   │   │   47 │         /// <param name="filePath">The file path</param>
│   │   │   │   48 │         /// <param name="fileName">The file name</param>
│   │   │   │   49 │         /// <param name="fileSize">The file size</param>
│   │   │   │   50 │         /// <param name="fileType">The file type</param>
│   │   │   │   51 │         public ImportedFile(string filePath, string fileName, long fileSize, string fileType)
│   │   │   │   52 │         {
│   │   │   │   53 │             if (string.IsNullOrWhiteSpace(filePath))
│   │   │   │   54 │                 throw new ArgumentException("File path cannot be empty", nameof(filePath));
│   │   │   │   55 │ 
│   │   │   │   56 │             if (string.IsNullOrWhiteSpace(fileName))
│   │   │   │   57 │                 throw new ArgumentException("File name cannot be empty", nameof(fileName));
│   │   │   │   58 │ 
│   │   │   │   59 │             FilePath = filePath;
│   │   │   │   60 │             FileName = fileName;
│   │   │   │   61 │             FileSize = fileSize;
│   │   │   │   62 │             FileType = fileType ?? string.Empty;
│   │   │   │   63 │             ImportDate = DateTime.UtcNow;
│   │   │   │   64 │             Status = "Imported";
│   │   │   │   65 │         }
│   │   │   │   66 │ 
│   │   │   │   67 │         /// <summary>
│   │   │   │   68 │         /// Updates the status of the file
│   │   │   │   69 │         /// </summary>
│   │   │   │   70 │         /// <param name="status">The new status</param>
│   │   │   │   71 │         public void UpdateStatus(string status)
│   │   │   │   72 │         {
│   │   │   │   73 │             Status = status ?? "Unknown";
│   │   │   │   74 │         }
│   │   │   │   75 │     }
│   │   │   │   76 │ }
│   │   │   └──────────────────────────────────────────────────────────────────────
│   │   ├── 📄 Project.cs (10.10 KB, 2025-03-11 09:48:27)
│   │   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │   │ FILE CONTENT: Project.cs
│   │   │   ├──────────────────────────────────────────────────────────────────────
│   │   │   │    1 │ ﻿using System;
│   │   │   │    2 │ using System.Collections.Generic;
│   │   │   │    3 │ using System.Linq;
│   │   │   │    4 │ using System.Text;
│   │   │   │    5 │ using System.Threading.Tasks;
│   │   │   │    6 │ 
│   │   │   │    7 │ namespace test.Core.Domain
│   │   │   │    8 │ {
│   │   │   │    9 │     /// <summary>
│   │   │   │   10 │     /// Represents a project within the application.
│   │   │   │   11 │     /// Core domain entity encapsulating project-specific business rules.
│   │   │   │   12 │     /// </summary>
│   │   │   │   13 │     public class Project
│   │   │   │   14 │     {
│   │   │   │   15 │         private readonly List<ImportedFile> _importedFiles = new();
│   │   │   │   16 │         private readonly List<SharedType> _sharedTypes = new();
│   │   │   │   17 │         private readonly List<CustomTypeFile> _customTypeFiles = new();
│   │   │   │   18 │ 
│   │   │   │   19 │         /// <summary>
│   │   │   │   20 │         /// The unique identifier for the project
│   │   │   │   21 │         /// </summary>
│   │   │   │   22 │         public string Id { get; private set; }
│   │   │   │   23 │ 
│   │   │   │   24 │         /// <summary>
│   │   │   │   25 │         /// The name of the project
│   │   │   │   26 │         /// </summary>
│   │   │   │   27 │         public string Name { get; private set; }
│   │   │   │   28 │ 
│   │   │   │   29 │         /// <summary>
│   │   │   │   30 │         /// The description of the project
│   │   │   │   31 │         /// </summary>
│   │   │   │   32 │         public string Description { get; private set; }
│   │   │   │   33 │ 
│   │   │   │   34 │         /// <summary>
│   │   │   │   35 │         /// The date the project was created
│   │   │   │   36 │         /// </summary>
│   │   │   │   37 │         public DateTime Created { get; private set; }
│   │   │   │   38 │ 
│   │   │   │   39 │         /// <summary>
│   │   │   │   40 │         /// The date the project was last modified
│   │   │   │   41 │         /// </summary>
│   │   │   │   42 │         public DateTime LastModified { get; private set; }
│   │   │   │   43 │ 
│   │   │   │   44 │         /// <summary>
│   │   │   │   45 │         /// Read-only collection of imported files
│   │   │   │   46 │         /// </summary>
│   │   │   │   47 │         public IReadOnlyCollection<ImportedFile> ImportedFiles => _importedFiles.AsReadOnly();
│   │   │   │   48 │ 
│   │   │   │   49 │         /// <summary>
│   │   │   │   50 │         /// Read-only collection of shared types
│   │   │   │   51 │         /// </summary>
│   │   │   │   52 │         public IReadOnlyCollection<SharedType> SharedTypes => _sharedTypes.AsReadOnly();
│   │   │   │   53 │ 
│   │   │   │   54 │         /// <summary>
│   │   │   │   55 │         /// Read-only collection of custom type files
│   │   │   │   56 │         /// </summary>
│   │   │   │   57 │         public IReadOnlyCollection<CustomTypeFile> CustomTypeFiles => _customTypeFiles.AsReadOnly();
│   │   │   │   58 │ 
│   │   │   │   59 │         /// <summary>
│   │   │   │   60 │         /// Creates a new project
│   │   │   │   61 │         /// </summary>
│   │   │   │   62 │         /// <param name="id">The project ID</param>
│   │   │   │   63 │         /// <param name="name">The project name</param>
│   │   │   │   64 │         /// <param name="description">The project description (optional)</param>
│   │   │   │   65 │         public Project(string id, string name, string description = "")
│   │   │   │   66 │         {
│   │   │   │   67 │             if (string.IsNullOrWhiteSpace(id))
│   │   │   │   68 │                 throw new ArgumentException("Project ID cannot be empty", nameof(id));
│   │   │   │   69 │ 
│   │   │   │   70 │             if (string.IsNullOrWhiteSpace(name))
│   │   │   │   71 │                 throw new ArgumentException("Project name cannot be empty", nameof(name));
│   │   │   │   72 │ 
│   │   │   │   73 │             Id = id;
│   │   │   │   74 │             Name = name;
│   │   │   │   75 │             Description = description ?? string.Empty;
│   │   │   │   76 │             Created = DateTime.UtcNow;
│   │   │   │   77 │             LastModified = Created;
│   │   │   │   78 │         }
│   │   │   │   79 │ 
│   │   │   │   80 │         /// <summary>
│   │   │   │   81 │         /// Constructor for loading existing projects
│   │   │   │   82 │         /// </summary>
│   │   │   │   83 │         internal Project(
│   │   │   │   84 │             string id,
│   │   │   │   85 │             string name,
│   │   │   │   86 │             string description,
│   │   │   │   87 │             DateTime created,
│   │   │   │   88 │             DateTime lastModified,
│   │   │   │   89 │             IEnumerable<ImportedFile> importedFiles = null,
│   │   │   │   90 │             IEnumerable<SharedType> sharedTypes = null,
│   │   │   │   91 │             IEnumerable<CustomTypeFile> customTypeFiles = null)
│   │   │   │   92 │         {
│   │   │   │   93 │             Id = id;
│   │   │   │   94 │             Name = name;
│   │   │   │   95 │             Description = description;
│   │   │   │   96 │             Created = created;
│   │   │   │   97 │             LastModified = lastModified;
│   │   │   │   98 │ 
│   │   │   │   99 │             if (importedFiles != null)
│   │   │   │  100 │                 _importedFiles.AddRange(importedFiles);
│   │   │   │  101 │ 
│   │   │   │  102 │             if (sharedTypes != null)
│   │   │   │  103 │                 _sharedTypes.AddRange(sharedTypes);
│   │   │   │  104 │ 
│   │   │   │  105 │             if (customTypeFiles != null)
│   │   │   │  106 │                 _customTypeFiles.AddRange(customTypeFiles);
│   │   │   │  107 │         }
│   │   │   │  108 │ 
│   │   │   │  109 │         /// <summary>
│   │   │   │  110 │         /// Updates project details
│   │   │   │  111 │         /// </summary>
│   │   │   │  112 │         /// <param name="name">The new name</param>
│   │   │   │  113 │         /// <param name="description">The new description</param>
│   │   │   │  114 │         public void UpdateDetails(string name, string description)
│   │   │   │  115 │         {
│   │   │   │  116 │             if (string.IsNullOrWhiteSpace(name))
│   │   │   │  117 │                 throw new ArgumentException("Project name cannot be empty", nameof(name));
│   │   │   │  118 │ 
│   │   │   │  119 │             Name = name;
│   │   │   │  120 │             Description = description ?? string.Empty;
│   │   │   │  121 │             UpdateModificationTime();
│   │   │   │  122 │         }
│   │   │   │  123 │ 
│   │   │   │  124 │         /// <summary>
│   │   │   │  125 │         /// Imports a file into the project
│   │   │   │  126 │         /// </summary>
│   │   │   │  127 │         /// <param name="path">The file path</param>
│   │   │   │  128 │         /// <param name="fileName">The file name</param>
│   │   │   │  129 │         /// <param name="fileSize">The file size</param>
│   │   │   │  130 │         /// <param name="fileType">The file type</param>
│   │   │   │  131 │         /// <returns>The imported file object</returns>
│   │   │   │  132 │         public ImportedFile ImportFile(string path, string fileName, long fileSize, string fileType)
│   │   │   │  133 │         {
│   │   │   │  134 │             if (string.IsNullOrWhiteSpace(path))
│   │   │   │  135 │                 throw new ArgumentException("File path cannot be empty", nameof(path));
│   │   │   │  136 │ 
│   │   │   │  137 │             if (string.IsNullOrWhiteSpace(fileName))
│   │   │   │  138 │                 throw new ArgumentException("File name cannot be empty", nameof(fileName));
│   │   │   │  139 │ 
│   │   │   │  140 │             if (_importedFiles.Any(f => f.FilePath == path))
│   │   │   │  141 │                 throw new InvalidOperationException($"File at path '{path}' is already imported");
│   │   │   │  142 │ 
│   │   │   │  143 │             var file = new ImportedFile(path, fileName, fileSize, fileType);
│   │   │   │  144 │             _importedFiles.Add(file);
│   │   │   │  145 │ 
│   │   │   │  146 │             UpdateModificationTime();
│   │   │   │  147 │             return file;
│   │   │   │  148 │         }
│   │   │   │  149 │ 
│   │   │   │  150 │         /// <summary>
│   │   │   │  151 │         /// Removes a file from the project
│   │   │   │  152 │         /// </summary>
│   │   │   │  153 │         /// <param name="path">The path of the file to remove</param>
│   │   │   │  154 │         /// <returns>True if removed, false if not found</returns>
│   │   │   │  155 │         public bool RemoveFile(string path)
│   │   │   │  156 │         {
│   │   │   │  157 │             if (string.IsNullOrEmpty(path))
│   │   │   │  158 │                 return false;
│   │   │   │  159 │ 
│   │   │   │  160 │             var file = _importedFiles.FirstOrDefault(f => f.FilePath == path);
│   │   │   │  161 │             if (file == null)
│   │   │   │  162 │                 return false;
│   │   │   │  163 │ 
│   │   │   │  164 │             var result = _importedFiles.Remove(file);
│   │   │   │  165 │             if (result)
│   │   │   │  166 │                 UpdateModificationTime();
│   │   │   │  167 │ 
│   │   │   │  168 │             return result;
│   │   │   │  169 │         }
│   │   │   │  170 │ 
│   │   │   │  171 │         /// <summary>
│   │   │   │  172 │         /// Adds a shared type to the project
│   │   │   │  173 │         /// </summary>
│   │   │   │  174 │         /// <param name="typeName">The type name</param>
│   │   │   │  175 │         /// <param name="fileName">The file name</param>
│   │   │   │  176 │         /// <param name="filePath">The file path</param>
│   │   │   │  177 │         /// <param name="category">The category</param>
│   │   │   │  178 │         /// <param name="description">The description</param>
│   │   │   │  179 │         /// <param name="fileSize">The file size</param>
│   │   │   │  180 │         /// <returns>The added shared type</returns>
│   │   │   │  181 │         public SharedType AddSharedType(
│   │   │   │  182 │             string typeName,
│   │   │   │  183 │             string fileName,
│   │   │   │  184 │             string filePath,
│   │   │   │  185 │             string category,
│   │   │   │  186 │             string description,
│   │   │   │  187 │             long fileSize)
│   │   │   │  188 │         {
│   │   │   │  189 │             if (string.IsNullOrWhiteSpace(typeName))
│   │   │   │  190 │                 throw new ArgumentException("Type name cannot be empty", nameof(typeName));
│   │   │   │  191 │ 
│   │   │   │  192 │             if (string.IsNullOrWhiteSpace(filePath))
│   │   │   │  193 │                 throw new ArgumentException("File path cannot be empty", nameof(filePath));
│   │   │   │  194 │ 
│   │   │   │  195 │             if (_sharedTypes.Any(t => t.FilePath == filePath))
│   │   │   │  196 │                 throw new InvalidOperationException($"Shared type at path '{filePath}' already exists");
│   │   │   │  197 │ 
│   │   │   │  198 │             var sharedType = new SharedType(
│   │   │   │  199 │                 typeName,
│   │   │   │  200 │                 fileName,
│   │   │   │  201 │                 filePath,
│   │   │   │  202 │                 category,
│   │   │   │  203 │                 description,
│   │   │   │  204 │                 fileSize);
│   │   │   │  205 │ 
│   │   │   │  206 │             _sharedTypes.Add(sharedType);
│   │   │   │  207 │             UpdateModificationTime();
│   │   │   │  208 │ 
│   │   │   │  209 │             return sharedType;
│   │   │   │  210 │         }
│   │   │   │  211 │ 
│   │   │   │  212 │         /// <summary>
│   │   │   │  213 │         /// Updates the description of a shared type
│   │   │   │  214 │         /// </summary>
│   │   │   │  215 │         /// <param name="filePath">The file path of the shared type</param>
│   │   │   │  216 │         /// <param name="description">The new description</param>
│   │   │   │  217 │         /// <returns>True if updated, false if not found</returns>
│   │   │   │  218 │         public bool UpdateSharedTypeDescription(string filePath, string description)
│   │   │   │  219 │         {
│   │   │   │  220 │             if (string.IsNullOrEmpty(filePath))
│   │   │   │  221 │                 return false;
│   │   │   │  222 │ 
│   │   │   │  223 │             var sharedType = _sharedTypes.FirstOrDefault(t => t.FilePath == filePath);
│   │   │   │  224 │             if (sharedType == null)
│   │   │   │  225 │                 return false;
│   │   │   │  226 │ 
│   │   │   │  227 │             sharedType.UpdateDescription(description);
│   │   │   │  228 │             UpdateModificationTime();
│   │   │   │  229 │             return true;
│   │   │   │  230 │         }
│   │   │   │  231 │ 
│   │   │   │  232 │         /// <summary>
│   │   │   │  233 │         /// Removes a shared type from the project
│   │   │   │  234 │         /// </summary>
│   │   │   │  235 │         /// <param name="filePath">The file path of the shared type to remove</param>
│   │   │   │  236 │         /// <returns>True if removed, false if not found</returns>
│   │   │   │  237 │         public bool RemoveSharedType(string filePath)
│   │   │   │  238 │         {
│   │   │   │  239 │             if (string.IsNullOrEmpty(filePath))
│   │   │   │  240 │                 return false;
│   │   │   │  241 │ 
│   │   │   │  242 │             var sharedType = _sharedTypes.FirstOrDefault(t => t.FilePath == filePath);
│   │   │   │  243 │             if (sharedType == null)
│   │   │   │  244 │                 return false;
│   │   │   │  245 │ 
│   │   │   │  246 │             var result = _sharedTypes.Remove(sharedType);
│   │   │   │  247 │             if (result)
│   │   │   │  248 │                 UpdateModificationTime();
│   │   │   │  249 │ 
│   │   │   │  250 │             return result;
│   │   │   │  251 │         }
│   │   │   │  252 │ 
│   │   │   │  253 │         /// <summary>
│   │   │   │  254 │         /// Adds a custom type file to the project
│   │   │   │  255 │         /// </summary>
│   │   │   │  256 │         /// <param name="fileName">The file name</param>
│   │   │   │  257 │         /// <param name="typeCount">The number of types</param>
│   │   │   │  258 │         /// <param name="description">The description</param>
│   │   │   │  259 │         /// <returns>The added custom type file</returns>
│   │   │   │  260 │         public CustomTypeFile AddCustomTypeFile(string fileName, int typeCount, string description)
│   │   │   │  261 │         {
│   │   │   │  262 │             if (string.IsNullOrWhiteSpace(fileName))
│   │   │   │  263 │                 throw new ArgumentException("File name cannot be empty", nameof(fileName));
│   │   │   │  264 │ 
│   │   │   │  265 │             if (_customTypeFiles.Any(f => f.FileName == fileName))
│   │   │   │  266 │                 throw new InvalidOperationException($"Custom type file '{fileName}' already exists");
│   │   │   │  267 │ 
│   │   │   │  268 │             var customTypeFile = new CustomTypeFile(fileName, typeCount, description);
│   │   │   │  269 │             _customTypeFiles.Add(customTypeFile);
│   │   │   │  270 │ 
│   │   │   │  271 │             UpdateModificationTime();
│   │   │   │  272 │             return customTypeFile;
│   │   │   │  273 │         }
│   │   │   │  274 │ 
│   │   │   │  275 │         /// <summary>
│   │   │   │  276 │         /// Updates the modification time to now
│   │   │   │  277 │         /// </summary>
│   │   │   │  278 │         private void UpdateModificationTime()
│   │   │   │  279 │         {
│   │   │   │  280 │             LastModified = DateTime.UtcNow;
│   │   │   │  281 │         }
│   │   │   │  282 │     }
│   │   │   │  283 │ }
│   │   │   └──────────────────────────────────────────────────────────────────────
│   │   ├── 📄 Session.cs (5.31 KB, 2025-03-11 09:48:27)
│   │   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │   │ FILE CONTENT: Session.cs
│   │   │   ├──────────────────────────────────────────────────────────────────────
│   │   │   │    1 │ ﻿using System;
│   │   │   │    2 │ using System.Collections.Generic;
│   │   │   │    3 │ using System.Linq;
│   │   │   │    4 │ using System.Text;
│   │   │   │    5 │ using System.Threading.Tasks;
│   │   │   │    6 │ using System.IO;    
│   │   │   │    7 │ 
│   │   │   │    8 │ namespace test.Core.Domain
│   │   │   │    9 │ {
│   │   │   │   10 │     /// <summary>
│   │   │   │   11 │     /// Represents a session in the system.
│   │   │   │   12 │     /// A session is created when controllers are parsed and stored in the database.
│   │   │   │   13 │     /// </summary>
│   │   │   │   14 │     public class Session
│   │   │   │   15 │     {
│   │   │   │   16 │         /// <summary>
│   │   │   │   17 │         /// The unique ID of the session
│   │   │   │   18 │         /// </summary>
│   │   │   │   19 │         public string Id { get; }
│   │   │   │   20 │ 
│   │   │   │   21 │         /// <summary>
│   │   │   │   22 │         /// The project ID this session belongs to, if any
│   │   │   │   23 │         /// </summary>
│   │   │   │   24 │         public string ProjectId { get; }
│   │   │   │   25 │ 
│   │   │   │   26 │         /// <summary>
│   │   │   │   27 │         /// The original file name this session was created from
│   │   │   │   28 │         /// </summary>
│   │   │   │   29 │         public string FileName { get; }
│   │   │   │   30 │ 
│   │   │   │   31 │         /// <summary>
│   │   │   │   32 │         /// The full path to the original file
│   │   │   │   33 │         /// </summary>
│   │   │   │   34 │         public string OriginalFilePath { get; }
│   │   │   │   35 │ 
│   │   │   │   36 │         /// <summary>
│   │   │   │   37 │         /// The number of controllers in this session
│   │   │   │   38 │         /// </summary>
│   │   │   │   39 │         public int ControllerCount { get; private set; }
│   │   │   │   40 │ 
│   │   │   │   41 │         /// <summary>
│   │   │   │   42 │         /// The date this session was created
│   │   │   │   43 │         /// </summary>
│   │   │   │   44 │         public DateTime Created { get; }
│   │   │   │   45 │ 
│   │   │   │   46 │         /// <summary>
│   │   │   │   47 │         /// The controller names in this session
│   │   │   │   48 │         /// </summary>
│   │   │   │   49 │         private readonly HashSet<string> _controllerNames = new();
│   │   │   │   50 │ 
│   │   │   │   51 │         /// <summary>
│   │   │   │   52 │         /// Read-only collection of controller names
│   │   │   │   53 │         /// </summary>
│   │   │   │   54 │         public IReadOnlyCollection<string> ControllerNames => _controllerNames.ToList().AsReadOnly();
│   │   │   │   55 │ 
│   │   │   │   56 │         /// <summary>
│   │   │   │   57 │         /// Creates a new session
│   │   │   │   58 │         /// </summary>
│   │   │   │   59 │         /// <param name="id">The session ID</param>
│   │   │   │   60 │         /// <param name="originalFilePath">The original file path</param>
│   │   │   │   61 │         /// <param name="projectId">The project ID (optional)</param>
│   │   │   │   62 │         public Session(string id, string originalFilePath, string projectId = null)
│   │   │   │   63 │         {
│   │   │   │   64 │             if (string.IsNullOrWhiteSpace(id))
│   │   │   │   65 │                 throw new ArgumentException("Session ID cannot be empty", nameof(id));
│   │   │   │   66 │ 
│   │   │   │   67 │             Id = id;
│   │   │   │   68 │             ProjectId = projectId;
│   │   │   │   69 │             OriginalFilePath = originalFilePath;
│   │   │   │   70 │             FileName = originalFilePath != null ? Path.GetFileName(originalFilePath) : null;
│   │   │   │   71 │             Created = DateTime.UtcNow;
│   │   │   │   72 │         }
│   │   │   │   73 │ 
│   │   │   │   74 │         /// <summary>
│   │   │   │   75 │         /// Constructor for loading existing sessions
│   │   │   │   76 │         /// </summary>
│   │   │   │   77 │         internal Session(
│   │   │   │   78 │             string id,
│   │   │   │   79 │             string originalFilePath,
│   │   │   │   80 │             string projectId,
│   │   │   │   81 │             int controllerCount,
│   │   │   │   82 │             DateTime created,
│   │   │   │   83 │             IEnumerable<string> controllerNames = null)
│   │   │   │   84 │         {
│   │   │   │   85 │             Id = id;
│   │   │   │   86 │             OriginalFilePath = originalFilePath;
│   │   │   │   87 │             FileName = originalFilePath != null ? Path.GetFileName(originalFilePath) : null;
│   │   │   │   88 │             ProjectId = projectId;
│   │   │   │   89 │             ControllerCount = controllerCount;
│   │   │   │   90 │             Created = created;
│   │   │   │   91 │ 
│   │   │   │   92 │             if (controllerNames != null)
│   │   │   │   93 │             {
│   │   │   │   94 │                 foreach (var name in controllerNames)
│   │   │   │   95 │                 {
│   │   │   │   96 │                     AddControllerName(name);
│   │   │   │   97 │                 }
│   │   │   │   98 │             }
│   │   │   │   99 │         }
│   │   │   │  100 │ 
│   │   │   │  101 │         /// <summary>
│   │   │   │  102 │         /// Adds a controller name to the session
│   │   │   │  103 │         /// </summary>
│   │   │   │  104 │         /// <param name="controllerName">The controller name</param>
│   │   │   │  105 │         public void AddControllerName(string controllerName)
│   │   │   │  106 │         {
│   │   │   │  107 │             if (string.IsNullOrWhiteSpace(controllerName))
│   │   │   │  108 │                 return;
│   │   │   │  109 │ 
│   │   │   │  110 │             _controllerNames.Add(controllerName);
│   │   │   │  111 │         }
│   │   │   │  112 │ 
│   │   │   │  113 │         /// <summary>
│   │   │   │  114 │         /// Sets the controller count
│   │   │   │  115 │         /// </summary>
│   │   │   │  116 │         /// <param name="count">The new count</param>
│   │   │   │  117 │         public void SetControllerCount(int count)
│   │   │   │  118 │         {
│   │   │   │  119 │             if (count < 0)
│   │   │   │  120 │                 throw new ArgumentException("Controller count cannot be negative", nameof(count));
│   │   │   │  121 │ 
│   │   │   │  122 │             ControllerCount = count;
│   │   │   │  123 │         }
│   │   │   │  124 │ 
│   │   │   │  125 │         /// <summary>
│   │   │   │  126 │         /// Gets the display name for this session
│   │   │   │  127 │         /// </summary>
│   │   │   │  128 │         /// <returns>The display name</returns>
│   │   │   │  129 │         public string GetDisplayName()
│   │   │   │  130 │         {
│   │   │   │  131 │             if (!string.IsNullOrEmpty(FileName))
│   │   │   │  132 │                 return FileName;
│   │   │   │  133 │ 
│   │   │   │  134 │             // Use first part of session ID as fallback
│   │   │   │  135 │             if (!string.IsNullOrEmpty(Id) && Id.Length >= 8)
│   │   │   │  136 │                 return $"Session {Id.Substring(0, 8)}";
│   │   │   │  137 │ 
│   │   │   │  138 │             return "Unknown Session";
│   │   │   │  139 │         }
│   │   │   │  140 │ 
│   │   │   │  141 │         /// <summary>
│   │   │   │  142 │         /// Gets additional display information for the session
│   │   │   │  143 │         /// </summary>
│   │   │   │  144 │         /// <returns>The display information</returns>
│   │   │   │  145 │         public string GetDisplayInfo()
│   │   │   │  146 │         {
│   │   │   │  147 │             var parts = new List<string>();
│   │   │   │  148 │ 
│   │   │   │  149 │             if (ControllerCount > 0)
│   │   │   │  150 │                 parts.Add($"{ControllerCount} controllers");
│   │   │   │  151 │ 
│   │   │   │  152 │             if (Created != DateTime.MinValue)
│   │   │   │  153 │                 parts.Add($"{Created:MMM dd, yyyy HH:mm}");
│   │   │   │  154 │ 
│   │   │   │  155 │             return parts.Count > 0 ? string.Join(" - ", parts) : "No details available";
│   │   │   │  156 │         }
│   │   │   │  157 │ 
│   │   │   │  158 │         /// <summary>
│   │   │   │  159 │         /// Checks if this is a project session
│   │   │   │  160 │         /// </summary>
│   │   │   │  161 │         /// <returns>True if this is a project session, false otherwise</returns>
│   │   │   │  162 │         public bool IsProjectSession()
│   │   │   │  163 │         {
│   │   │   │  164 │             return !string.IsNullOrEmpty(ProjectId);
│   │   │   │  165 │         }
│   │   │   │  166 │     }
│   │   │   │  167 │ }
│   │   │   └──────────────────────────────────────────────────────────────────────
│   │   └── 📄 SharedType.cs (4.14 KB, 2025-03-11 09:48:27)
│   │       ┌──────────────────────────────────────────────────────────────────────
│   │       │ FILE CONTENT: SharedType.cs
│   │       ├──────────────────────────────────────────────────────────────────────
│   │       │    1 │ ﻿using System;
│   │       │    2 │ using System.Collections.Generic;
│   │       │    3 │ using System.Linq;
│   │       │    4 │ using System.Text;
│   │       │    5 │ using System.Threading.Tasks;
│   │       │    6 │ using System.IO;
│   │       │    7 │ 
│   │       │    8 │ namespace test.Core.Domain
│   │       │    9 │ {
│   │       │   10 │     /// <summary>
│   │       │   11 │     /// Represents a shared type in a project.
│   │       │   12 │     /// </summary>
│   │       │   13 │     public class SharedType
│   │       │   14 │     {
│   │       │   15 │         /// <summary>
│   │       │   16 │         /// The name of the type
│   │       │   17 │         /// </summary>
│   │       │   18 │         public string TypeName { get; }
│   │       │   19 │ 
│   │       │   20 │         /// <summary>
│   │       │   21 │         /// The file name
│   │       │   22 │         /// </summary>
│   │       │   23 │         public string FileName { get; }
│   │       │   24 │ 
│   │       │   25 │         /// <summary>
│   │       │   26 │         /// The file path
│   │       │   27 │         /// </summary>
│   │       │   28 │         public string FilePath { get; }
│   │       │   29 │ 
│   │       │   30 │         /// <summary>
│   │       │   31 │         /// The category of the shared type
│   │       │   32 │         /// </summary>
│   │       │   33 │         public string Category { get; }
│   │       │   34 │ 
│   │       │   35 │         /// <summary>
│   │       │   36 │         /// The description of the shared type
│   │       │   37 │         /// </summary>
│   │       │   38 │         public string Description { get; private set; }
│   │       │   39 │ 
│   │       │   40 │         /// <summary>
│   │       │   41 │         /// The date the shared type was imported
│   │       │   42 │         /// </summary>
│   │       │   43 │         public DateTime ImportDate { get; }
│   │       │   44 │ 
│   │       │   45 │         /// <summary>
│   │       │   46 │         /// The file size in bytes
│   │       │   47 │         /// </summary>
│   │       │   48 │         public long FileSize { get; }
│   │       │   49 │ 
│   │       │   50 │         /// <summary>
│   │       │   51 │         /// The number of times the shared type has been used
│   │       │   52 │         /// </summary>
│   │       │   53 │         public int UsageCount { get; private set; }
│   │       │   54 │ 
│   │       │   55 │         /// <summary>
│   │       │   56 │         /// The number of variables in the shared type
│   │       │   57 │         /// </summary>
│   │       │   58 │         public int VariableCount { get; private set; }
│   │       │   59 │ 
│   │       │   60 │         /// <summary>
│   │       │   61 │         /// The default target name for the shared type
│   │       │   62 │         /// </summary>
│   │       │   63 │         public string DefaultTargetName { get; private set; }
│   │       │   64 │ 
│   │       │   65 │         /// <summary>
│   │       │   66 │         /// Creates a new shared type
│   │       │   67 │         /// </summary>
│   │       │   68 │         /// <param name="typeName">The type name</param>
│   │       │   69 │         /// <param name="fileName">The file name</param>
│   │       │   70 │         /// <param name="filePath">The file path</param>
│   │       │   71 │         /// <param name="category">The category</param>
│   │       │   72 │         /// <param name="description">The description</param>
│   │       │   73 │         /// <param name="fileSize">The file size</param>
│   │       │   74 │         public SharedType(
│   │       │   75 │             string typeName,
│   │       │   76 │             string fileName,
│   │       │   77 │             string filePath,
│   │       │   78 │             string category,
│   │       │   79 │             string description,
│   │       │   80 │             long fileSize)
│   │       │   81 │         {
│   │       │   82 │             if (string.IsNullOrWhiteSpace(typeName))
│   │       │   83 │                 throw new ArgumentException("Type name cannot be empty", nameof(typeName));
│   │       │   84 │ 
│   │       │   85 │             if (string.IsNullOrWhiteSpace(filePath))
│   │       │   86 │                 throw new ArgumentException("File path cannot be empty", nameof(filePath));
│   │       │   87 │ 
│   │       │   88 │             TypeName = typeName;
│   │       │   89 │             FileName = fileName ?? Path.GetFileName(filePath);
│   │       │   90 │             FilePath = filePath;
│   │       │   91 │             Category = category ?? "Default";
│   │       │   92 │             Description = description ?? string.Empty;
│   │       │   93 │             FileSize = fileSize;
│   │       │   94 │             ImportDate = DateTime.UtcNow;
│   │       │   95 │             UsageCount = 0;
│   │       │   96 │         }
│   │       │   97 │ 
│   │       │   98 │         /// <summary>
│   │       │   99 │         /// Updates the description of the shared type
│   │       │  100 │         /// </summary>
│   │       │  101 │         /// <param name="description">The new description</param>
│   │       │  102 │         public void UpdateDescription(string description)
│   │       │  103 │         {
│   │       │  104 │             Description = description ?? string.Empty;
│   │       │  105 │         }
│   │       │  106 │ 
│   │       │  107 │         /// <summary>
│   │       │  108 │         /// Sets the number of variables in the shared type
│   │       │  109 │         /// </summary>
│   │       │  110 │         /// <param name="count">The variable count</param>
│   │       │  111 │         public void SetVariableCount(int count)
│   │       │  112 │         {
│   │       │  113 │             if (count < 0)
│   │       │  114 │                 throw new ArgumentException("Variable count cannot be negative", nameof(count));
│   │       │  115 │ 
│   │       │  116 │             VariableCount = count;
│   │       │  117 │         }
│   │       │  118 │ 
│   │       │  119 │         /// <summary>
│   │       │  120 │         /// Sets the default target name for the shared type
│   │       │  121 │         /// </summary>
│   │       │  122 │         /// <param name="targetName">The target name</param>
│   │       │  123 │         public void SetDefaultTargetName(string targetName)
│   │       │  124 │         {
│   │       │  125 │             DefaultTargetName = targetName ?? string.Empty;
│   │       │  126 │         }
│   │       │  127 │ 
│   │       │  128 │         /// <summary>
│   │       │  129 │         /// Increments the usage count by one
│   │       │  130 │         /// </summary>
│   │       │  131 │         public void IncrementUsageCount()
│   │       │  132 │         {
│   │       │  133 │             UsageCount++;
│   │       │  134 │         }
│   │       │  135 │     }
│   │       │  136 │ }
│   │       └──────────────────────────────────────────────────────────────────────
│   │   📁 Dto
│   │   ├── 📄 ControllerGroupDto.cs (1.21 KB, 2025-03-11 13:30:26)
│   │   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │   │ FILE CONTENT: ControllerGroupDto.cs
│   │   │   ├──────────────────────────────────────────────────────────────────────
│   │   │   │    1 │ ﻿using System.Collections.Generic;
│   │   │   │    2 │ 
│   │   │   │    3 │ namespace test.Core.Dto
│   │   │   │    4 │ {
│   │   │   │    5 │     /// <summary>
│   │   │   │    6 │     /// Data Transfer Object for controller groups.
│   │   │   │    7 │     /// Used in service interfaces for looser coupling and mutable properties.
│   │   │   │    8 │     /// </summary>
│   │   │   │    9 │     public class ControllerGroupDto
│   │   │   │   10 │     {
│   │   │   │   11 │         /// <summary>
│   │   │   │   12 │         /// The group identifier
│   │   │   │   13 │         /// </summary>
│   │   │   │   14 │         public string GroupIdentifier { get; set; }
│   │   │   │   15 │ 
│   │   │   │   16 │         /// <summary>
│   │   │   │   17 │         /// The controller names in this group
│   │   │   │   18 │         /// </summary>
│   │   │   │   19 │         public List<string> ControllerNames { get; set; } = new List<string>();
│   │   │   │   20 │ 
│   │   │   │   21 │         /// <summary>
│   │   │   │   22 │         /// Original values from controllers (pre-replacement)
│   │   │   │   23 │         /// </summary>
│   │   │   │   24 │         public Dictionary<string, string> OriginalValues { get; set; } = new Dictionary<string, string>();
│   │   │   │   25 │ 
│   │   │   │   26 │         /// <summary>
│   │   │   │   27 │         /// Processed values after name processing
│   │   │   │   28 │         /// </summary>
│   │   │   │   29 │         public Dictionary<string, string> ProcessedValues { get; set; } = new Dictionary<string, string>();
│   │   │   │   30 │ 
│   │   │   │   31 │         /// <summary>
│   │   │   │   32 │         /// Mapping from original to processed names
│   │   │   │   33 │         /// </summary>
│   │   │   │   34 │         public Dictionary<string, string> NameMapping { get; set; } = new Dictionary<string, string>();
│   │   │   │   35 │     }
│   │   │   │   36 │ }
│   │   │   └──────────────────────────────────────────────────────────────────────
│   │   └── 📄 SimilarityResultDto.cs (1.29 KB, 2025-03-11 13:31:10)
│   │       ┌──────────────────────────────────────────────────────────────────────
│   │       │ FILE CONTENT: SimilarityResultDto.cs
│   │       ├──────────────────────────────────────────────────────────────────────
│   │       │    1 │ ﻿using System.Collections.Generic;
│   │       │    2 │ 
│   │       │    3 │ namespace test.Core.Dto
│   │       │    4 │ {
│   │       │    5 │     /// <summary>
│   │       │    6 │     /// Data Transfer Object for similarity search results
│   │       │    7 │     /// </summary>
│   │       │    8 │     public class SimilarityResultDto
│   │       │    9 │     {
│   │       │   10 │         /// <summary>
│   │       │   11 │         /// The group identifier
│   │       │   12 │         /// </summary>
│   │       │   13 │         public string GroupIdentifier { get; set; }
│   │       │   14 │ 
│   │       │   15 │         /// <summary>
│   │       │   16 │         /// The controller names in this group
│   │       │   17 │         /// </summary>
│   │       │   18 │         public List<string> ControllerNames { get; set; } = new List<string>();
│   │       │   19 │ 
│   │       │   20 │         /// <summary>
│   │       │   21 │         /// The similarity score (0.0-1.0)
│   │       │   22 │         /// </summary>
│   │       │   23 │         public double SimilarityScore { get; set; }
│   │       │   24 │ 
│   │       │   25 │         /// <summary>
│   │       │   26 │         /// The original values before any name processing
│   │       │   27 │         /// </summary>
│   │       │   28 │         public Dictionary<string, string> OriginalValues { get; set; } = new Dictionary<string, string>();
│   │       │   29 │ 
│   │       │   30 │         /// <summary>
│   │       │   31 │         /// The processed values used for comparison
│   │       │   32 │         /// </summary>
│   │       │   33 │         public Dictionary<string, string> ProcessedValues { get; set; } = new Dictionary<string, string>();
│   │       │   34 │ 
│   │       │   35 │         /// <summary>
│   │       │   36 │         /// The mapping between original and processed names
│   │       │   37 │         /// </summary>
│   │       │   38 │         public Dictionary<string, string> NameMapping { get; set; } = new Dictionary<string, string>();
│   │       │   39 │     }
│   │       │   40 │ }
│   │       └──────────────────────────────────────────────────────────────────────
│   │   📁 Exceptions
│   │   ├── 📄 BusinessRuleException.cs (528.00 B, 2025-03-11 09:48:27)
│   │   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │   │ FILE CONTENT: BusinessRuleException.cs
│   │   │   ├──────────────────────────────────────────────────────────────────────
│   │   │   │    1 │ ﻿using System;
│   │   │   │    2 │ using System.Collections.Generic;
│   │   │   │    3 │ using System.Linq;
│   │   │   │    4 │ using System.Text;
│   │   │   │    5 │ using System.Threading.Tasks;
│   │   │   │    6 │ 
│   │   │   │    7 │ namespace test.Core.Exceptions
│   │   │   │    8 │ {
│   │   │   │    9 │     /// <summary>
│   │   │   │   10 │     /// Exception thrown when a business rule is violated
│   │   │   │   11 │     /// </summary>
│   │   │   │   12 │     public class BusinessRuleException : DomainExceptionBase
│   │   │   │   13 │     {
│   │   │   │   14 │         public BusinessRuleException(string message) : base(message) { }
│   │   │   │   15 │         public BusinessRuleException(string message, Exception innerException) : base(message, innerException) { }
│   │   │   │   16 │     }
│   │   │   │   17 │ }
│   │   │   └──────────────────────────────────────────────────────────────────────
│   │   ├── 📄 DataAccessException.cs (1.23 KB, 2025-03-11 09:48:27)
│   │   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │   │ FILE CONTENT: DataAccessException.cs
│   │   │   ├──────────────────────────────────────────────────────────────────────
│   │   │   │    1 │ ﻿using System;
│   │   │   │    2 │ using System.Collections.Generic;
│   │   │   │    3 │ using System.Linq;
│   │   │   │    4 │ using System.Text;
│   │   │   │    5 │ using System.Threading.Tasks;
│   │   │   │    6 │ using System;
│   │   │   │    7 │ 
│   │   │   │    8 │ namespace test.Core.Exceptions
│   │   │   │    9 │ {
│   │   │   │   10 │     /// <summary>
│   │   │   │   11 │     /// Exception thrown when a data access operation fails
│   │   │   │   12 │     /// </summary>
│   │   │   │   13 │     public class DataAccessException : DomainExceptionBase
│   │   │   │   14 │     {
│   │   │   │   15 │         public string Operation { get; }
│   │   │   │   16 │         public string EntityType { get; }
│   │   │   │   17 │ 
│   │   │   │   18 │         public DataAccessException(string message, string operation, string entityType = null)
│   │   │   │   19 │             : base(message)
│   │   │   │   20 │         {
│   │   │   │   21 │             Operation = operation;
│   │   │   │   22 │             EntityType = entityType;
│   │   │   │   23 │         }
│   │   │   │   24 │ 
│   │   │   │   25 │         public DataAccessException(string message, string operation, string entityType, Exception innerException)
│   │   │   │   26 │             : base(message, innerException)
│   │   │   │   27 │         {
│   │   │   │   28 │             Operation = operation;
│   │   │   │   29 │             EntityType = entityType;
│   │   │   │   30 │         }
│   │   │   │   31 │ 
│   │   │   │   32 │         // Add a new constructor that takes just operation and exception - fixes the argument conversion error
│   │   │   │   33 │         public DataAccessException(string message, string operation, Exception innerException)
│   │   │   │   34 │             : base(message, innerException)
│   │   │   │   35 │         {
│   │   │   │   36 │             Operation = operation;
│   │   │   │   37 │             EntityType = null;
│   │   │   │   38 │         }
│   │   │   │   39 │     }
│   │   │   │   40 │ }
│   │   │   └──────────────────────────────────────────────────────────────────────
│   │   ├── 📄 DomainExceptionBase.cs (527.00 B, 2025-03-11 09:48:27)
│   │   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │   │ FILE CONTENT: DomainExceptionBase.cs
│   │   │   ├──────────────────────────────────────────────────────────────────────
│   │   │   │    1 │ ﻿using System;
│   │   │   │    2 │ using System.Collections.Generic;
│   │   │   │    3 │ using System.Linq;
│   │   │   │    4 │ using System.Text;
│   │   │   │    5 │ using System.Threading.Tasks;
│   │   │   │    6 │ 
│   │   │   │    7 │ namespace test.Core.Exceptions
│   │   │   │    8 │ {
│   │   │   │    9 │     /// <summary>
│   │   │   │   10 │     /// Base exception class for all domain-specific exceptions
│   │   │   │   11 │     /// </summary>
│   │   │   │   12 │     public abstract class DomainExceptionBase : Exception
│   │   │   │   13 │     {
│   │   │   │   14 │         public DomainExceptionBase(string message) : base(message) { }
│   │   │   │   15 │         public DomainExceptionBase(string message, Exception innerException) : base(message, innerException) { }
│   │   │   │   16 │     }
│   │   │   │   17 │ }
│   │   │   └──────────────────────────────────────────────────────────────────────
│   │   ├── 📄 NotFoundException.cs (733.00 B, 2025-03-11 09:48:27)
│   │   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │   │ FILE CONTENT: NotFoundException.cs
│   │   │   ├──────────────────────────────────────────────────────────────────────
│   │   │   │    1 │ ﻿using System;
│   │   │   │    2 │ using System.Collections.Generic;
│   │   │   │    3 │ using System.Linq;
│   │   │   │    4 │ using System.Text;
│   │   │   │    5 │ using System.Threading.Tasks;
│   │   │   │    6 │ 
│   │   │   │    7 │ namespace test.Core.Exceptions
│   │   │   │    8 │ {
│   │   │   │    9 │     /// <summary>
│   │   │   │   10 │     /// Exception thrown when a requested entity cannot be found
│   │   │   │   11 │     /// </summary>
│   │   │   │   12 │     public class NotFoundException : DomainExceptionBase
│   │   │   │   13 │     {
│   │   │   │   14 │         public string EntityType { get; }
│   │   │   │   15 │         public string EntityId { get; }
│   │   │   │   16 │ 
│   │   │   │   17 │         public NotFoundException(string message) : base(message) { }
│   │   │   │   18 │ 
│   │   │   │   19 │         public NotFoundException(string entityType, string entityId)
│   │   │   │   20 │             : base($"{entityType} with ID {entityId} was not found")
│   │   │   │   21 │         {
│   │   │   │   22 │             EntityType = entityType;
│   │   │   │   23 │             EntityId = entityId;
│   │   │   │   24 │         }
│   │   │   │   25 │     }
│   │   │   │   26 │ }
│   │   │   └──────────────────────────────────────────────────────────────────────
│   │   └── 📄 ParsingException.cs (943.00 B, 2025-03-11 09:48:27)
│   │       ┌──────────────────────────────────────────────────────────────────────
│   │       │ FILE CONTENT: ParsingException.cs
│   │       ├──────────────────────────────────────────────────────────────────────
│   │       │    1 │ ﻿using System;
│   │       │    2 │ using System.Collections.Generic;
│   │       │    3 │ using System.Linq;
│   │       │    4 │ using System.Text;
│   │       │    5 │ using System.Threading.Tasks;
│   │       │    6 │ using System.IO;
│   │       │    7 │ 
│   │       │    8 │ namespace test.Core.Exceptions
│   │       │    9 │ {
│   │       │   10 │     /// <summary>
│   │       │   11 │     /// Exception thrown when a parsing operation fails
│   │       │   12 │     /// </summary>
│   │       │   13 │     public class ParsingException : DomainExceptionBase
│   │       │   14 │     {
│   │       │   15 │         public string FilePath { get; }
│   │       │   16 │         public string FileType { get; }
│   │       │   17 │ 
│   │       │   18 │         public ParsingException(string message, string filePath)
│   │       │   19 │             : base(message)
│   │       │   20 │         {
│   │       │   21 │             FilePath = filePath;
│   │       │   22 │             FileType = Path.GetExtension(filePath)?.TrimStart('.') ?? "unknown";
│   │       │   23 │         }
│   │       │   24 │ 
│   │       │   25 │         public ParsingException(string message, string filePath, Exception innerException)
│   │       │   26 │             : base(message, innerException)
│   │       │   27 │         {
│   │       │   28 │             FilePath = filePath;
│   │       │   29 │             FileType = Path.GetExtension(filePath)?.TrimStart('.') ?? "unknown";
│   │       │   30 │         }
│   │       │   31 │     }
│   │       │   32 │ }
│   │       └──────────────────────────────────────────────────────────────────────
│       📁 Interfaces
│       ├── 📄 IComparisonService.cs (5.11 KB, 2025-03-11 13:29:32)
│       │   ┌──────────────────────────────────────────────────────────────────────
│       │   │ FILE CONTENT: IComparisonService.cs
│       │   ├──────────────────────────────────────────────────────────────────────
│       │   │    1 │ ﻿using System.Collections.Generic;
│       │   │    2 │ using System.Threading.Tasks;
│       │   │    3 │ using test.Core.Domain;
│       │   │    4 │ using test.Core.Dto;
│       │   │    5 │ 
│       │   │    6 │ namespace test.Core.Interfaces
│       │   │    7 │ {
│       │   │    8 │     /// <summary>
│       │   │    9 │     /// Service interface for comparing controller data with XML and other formats
│       │   │   10 │     /// </summary>
│       │   │   11 │     public interface IComparisonService
│       │   │   12 │     {
│       │   │   13 │         /// <summary>
│       │   │   14 │         /// Compares controllers with XML content
│       │   │   15 │         /// </summary>
│       │   │   16 │         /// <param name="xmlContent">The XML content to compare with</param>
│       │   │   17 │         /// <param name="controllers">The controllers to compare</param>
│       │   │   18 │         /// <returns>A collection of comparison results</returns>
│       │   │   19 │         Task<IEnumerable<ComparisonResult>> CompareWithXmlAsync(string xmlContent, IEnumerable<Controller> controllers);
│       │   │   20 │ 
│       │   │   21 │         /// <summary>
│       │   │   22 │         /// Generates modified XML content based on a controller
│       │   │   23 │         /// </summary>
│       │   │   24 │         /// <param name="originalXmlContent">The original XML content</param>
│       │   │   25 │         /// <param name="controller">The controller to use for modifications</param>
│       │   │   26 │         /// <param name="targetName">Optional target name for the modified XML</param>
│       │   │   27 │         /// <returns>The modified XML content</returns>
│       │   │   28 │         Task<string> GenerateModifiedXmlAsync(string originalXmlContent, Controller controller, string targetName = null);
│       │   │   29 │ 
│       │   │   30 │         /// <summary>
│       │   │   31 │         /// Groups controllers based on similarities
│       │   │   32 │         /// </summary>
│       │   │   33 │         /// <param name="controllers">The controllers to group</param>
│       │   │   34 │         /// <param name="options">Grouping options</param>
│       │   │   35 │         /// <returns>A collection of controller groups</returns>
│       │   │   36 │         Task<IEnumerable<ControllerGroup>> GroupControllersAsync(IEnumerable<Controller> controllers, GroupingOptions options = null);
│       │   │   37 │ 
│       │   │   38 │         /// <summary>
│       │   │   39 │         /// Find similar controllers in XML content
│       │   │   40 │         /// </summary>
│       │   │   41 │         /// <param name="xmlContent">The XML content to search in</param>
│       │   │   42 │         /// <param name="controllers">The controllers to find similarities for</param>
│       │   │   43 │         /// <param name="options">Grouping options</param>
│       │   │   44 │         /// <returns>A collection of similarity results</returns>
│       │   │   45 │         Task<IEnumerable<SimilarityResultDto>> FindSimilarControllersAsync(string xmlContent, IEnumerable<Controller> controllers, GroupingOptions options = null);
│       │   │   46 │     }
│       │   │   47 │ 
│       │   │   48 │     /// <summary>
│       │   │   49 │     /// Options for controller grouping
│       │   │   50 │     /// </summary>
│       │   │   51 │     public class GroupingOptions
│       │   │   52 │     {
│       │   │   53 │         /// <summary>
│       │   │   54 │         /// Minimum similarity threshold (0.0-1.0)
│       │   │   55 │         /// </summary>
│       │   │   56 │         public double MinimumSimilarityThreshold { get; set; } = 0.7;
│       │   │   57 │ 
│       │   │   58 │         /// <summary>
│       │   │   59 │         /// Whether to return best matches regardless of threshold
│       │   │   60 │         /// </summary>
│       │   │   61 │         public bool ReturnBestMatchesRegardless { get; set; } = false;
│       │   │   62 │ 
│       │   │   63 │         /// <summary>
│       │   │   64 │         /// Weight for exact value matches (1.0 means exact matches only)
│       │   │   65 │         /// </summary>
│       │   │   66 │         public double ExactMatchWeight { get; set; } = 1.0;
│       │   │   67 │ 
│       │   │   68 │         /// <summary>
│       │   │   69 │         /// Weight for numeric values within tolerance
│       │   │   70 │         /// </summary>
│       │   │   71 │         public double NumericToleranceWeight { get; set; } = 0.8;
│       │   │   72 │ 
│       │   │   73 │         /// <summary>
│       │   │   74 │         /// Acceptable percentage difference for numeric values (e.g., 0.1 = 10%)
│       │   │   75 │         /// </summary>
│       │   │   76 │         public double NumericTolerance { get; set; } = 0.1;
│       │   │   77 │ 
│       │   │   78 │         /// <summary>
│       │   │   79 │         /// Number of groups to match
│       │   │   80 │         /// </summary>
│       │   │   81 │         public int NumberOfGroupsToMatch { get; set; } = 3;
│       │   │   82 │ 
│       │   │   83 │         /// <summary>
│       │   │   84 │         /// Replacement rules for name processing
│       │   │   85 │         /// </summary>
│       │   │   86 │         public IEnumerable<ReplacementRule> ReplacementRules { get; set; } = new List<ReplacementRule>();
│       │   │   87 │     }
│       │   │   88 │ 
│       │   │   89 │     /// <summary>
│       │   │   90 │     /// Rule for replacing names during comparison
│       │   │   91 │     /// </summary>
│       │   │   92 │     public class ReplacementRule
│       │   │   93 │     {
│       │   │   94 │         /// <summary>
│       │   │   95 │         /// The pattern to replace
│       │   │   96 │         /// </summary>
│       │   │   97 │         public string Pattern { get; set; }
│       │   │   98 │ 
│       │   │   99 │         /// <summary>
│       │   │  100 │         /// The replacement value
│       │   │  101 │         /// </summary>
│       │   │  102 │         public string Replacement { get; set; }
│       │   │  103 │ 
│       │   │  104 │         /// <summary>
│       │   │  105 │         /// Whether this is a prefix (true) or suffix (false) replacement
│       │   │  106 │         /// </summary>
│       │   │  107 │         public bool IsPrefix { get; set; }
│       │   │  108 │ 
│       │   │  109 │         /// <summary>
│       │   │  110 │         /// Priority of the rule (higher values are processed first)
│       │   │  111 │         /// </summary>
│       │   │  112 │         public int Priority { get; set; }
│       │   │  113 │     }
│       │   │  114 │ 
│       │   │  115 │     /// <summary>
│       │   │  116 │     /// Result of a comparison operation
│       │   │  117 │     /// </summary>
│       │   │  118 │     public class ComparisonResult
│       │   │  119 │     {
│       │   │  120 │         /// <summary>
│       │   │  121 │         /// The controller object name
│       │   │  122 │         /// </summary>
│       │   │  123 │         public string Name { get; set; }
│       │   │  124 │ 
│       │   │  125 │         /// <summary>
│       │   │  126 │         /// The value in the controller
│       │   │  127 │         /// </summary>
│       │   │  128 │         public string ControllerValue { get; set; }
│       │   │  129 │ 
│       │   │  130 │         /// <summary>
│       │   │  131 │         /// The value in the XML
│       │   │  132 │         /// </summary>
│       │   │  133 │         public string XmlValue { get; set; }
│       │   │  134 │ 
│       │   │  135 │         /// <summary>
│       │   │  136 │         /// The XML address
│       │   │  137 │         /// </summary>
│       │   │  138 │         public string XmlAddress { get; set; }
│       │   │  139 │ 
│       │   │  140 │         /// <summary>
│       │   │  141 │         /// Whether the values match
│       │   │  142 │         /// </summary>
│       │   │  143 │         public bool IsMatch { get; set; }
│       │   │  144 │     }
│       │   │  145 │ }
│       │   └──────────────────────────────────────────────────────────────────────
│       ├── 📄 IControllerModelService.cs (1.07 KB, 2025-03-11 13:55:09)
│       │   ┌──────────────────────────────────────────────────────────────────────
│       │   │ FILE CONTENT: IControllerModelService.cs
│       │   ├──────────────────────────────────────────────────────────────────────
│       │   │    1 │ ﻿using System;
│       │   │    2 │ using System.Collections.Generic;
│       │   │    3 │ using System.Linq;
│       │   │    4 │ using System.Text;
│       │   │    5 │ using System.Threading.Tasks;
│       │   │    6 │ using test.Core.Domain;
│       │   │    7 │ 
│       │   │    8 │ namespace test.Core.Interfaces
│       │   │    9 │ {
│       │   │   10 │     /// <summary>
│       │   │   11 │     /// Service interface for controller model operations
│       │   │   12 │     /// </summary>
│       │   │   13 │     public interface IControllerModelService
│       │   │   14 │     {
│       │   │   15 │         /// <summary>
│       │   │   16 │         /// Determines the controller family based on model number
│       │   │   17 │         /// </summary>
│       │   │   18 │         ControllerModelInfo.ControllerFamily DetermineFamily(string modelNumber);
│       │   │   19 │ 
│       │   │   20 │         /// <summary>
│       │   │   21 │         /// Gets the properties for a controller model
│       │   │   22 │         /// </summary>
│       │   │   23 │         ControllerModelInfo.ModelProperties GetModelProperties(string modelNumber);
│       │   │   24 │ 
│       │   │   25 │         /// <summary>
│       │   │   26 │         /// Updates or adds properties for a controller model
│       │   │   27 │         /// </summary>
│       │   │   28 │         void SetModelProperties(string modelNumber, ControllerModelInfo.ModelProperties properties);
│       │   │   29 │ 
│       │   │   30 │         /// <summary>
│       │   │   31 │         /// Gets all known controller models
│       │   │   32 │         /// </summary>
│       │   │   33 │         IEnumerable<string> GetAllKnownModels();
│       │   │   34 │     }
│       │   │   35 │ }
│       │   └──────────────────────────────────────────────────────────────────────
│       ├── 📄 IControllerRepository.cs (3.34 KB, 2025-03-11 09:48:27)
│       │   ┌──────────────────────────────────────────────────────────────────────
│       │   │ FILE CONTENT: IControllerRepository.cs
│       │   ├──────────────────────────────────────────────────────────────────────
│       │   │    1 │ ﻿using System;
│       │   │    2 │ using System.Collections.Generic;
│       │   │    3 │ using System.Linq;
│       │   │    4 │ using System.Text;
│       │   │    5 │ using System.Threading.Tasks;
│       │   │    6 │ using test.Core.Domain;
│       │   │    7 │ using test.Data;
│       │   │    8 │ using System.Collections.Generic;
│       │   │    9 │ using System.Threading.Tasks;
│       │   │   10 │ 
│       │   │   11 │ namespace test.Core.Interfaces
│       │   │   12 │ {
│       │   │   13 │     /// <summary>
│       │   │   14 │     /// Repository interface for controller operations
│       │   │   15 │     /// </summary>
│       │   │   16 │     public interface IControllerRepository
│       │   │   17 │     {
│       │   │   18 │         /// <summary>
│       │   │   19 │         /// Saves a batch of controllers to the database
│       │   │   20 │         /// </summary>
│       │   │   21 │         /// <param name="controllers">The controllers to save</param>
│       │   │   22 │         /// <param name="fileName">The original file name</param>
│       │   │   23 │         /// <param name="sessionPrefix">Optional session ID prefix</param>
│       │   │   24 │         /// <returns>The session ID</returns>
│       │   │   25 │         Task<string> SaveControllerBatchAsync(IEnumerable<Controller> controllers, string fileName = null, string sessionPrefix = null);
│       │   │   26 │ 
│       │   │   27 │         /// <summary>
│       │   │   28 │         /// Gets controllers by session ID
│       │   │   29 │         /// </summary>
│       │   │   30 │         /// <param name="sessionId">The session ID</param>
│       │   │   31 │         /// <param name="skip">The number of controllers to skip</param>
│       │   │   32 │         /// <param name="take">The maximum number of controllers to return</param>
│       │   │   33 │         /// <returns>A collection of controllers</returns>
│       │   │   34 │         Task<IEnumerable<Controller>> GetControllersBySessionAsync(string sessionId, int skip = 0, int take = 50);
│       │   │   35 │ 
│       │   │   36 │         /// <summary>
│       │   │   37 │         /// Deletes a session and all its controllers
│       │   │   38 │         /// </summary>
│       │   │   39 │         /// <param name="sessionId">The session ID</param>
│       │   │   40 │         /// <returns>True if deleted, false if not found</returns>
│       │   │   41 │         Task<bool> DeleteSessionAsync(string sessionId);
│       │   │   42 │ 
│       │   │   43 │         /// <summary>
│       │   │   44 │         /// Gets session information
│       │   │   45 │         /// </summary>
│       │   │   46 │         /// <param name="sessionId">The session ID</param>
│       │   │   47 │         /// <returns>Session information</returns>
│       │   │   48 │         Task<SessionInfo> GetSessionInfoAsync(string sessionId);
│       │   │   49 │ 
│       │   │   50 │         /// <summary>
│       │   │   51 │         /// Gets information for all sessions
│       │   │   52 │         /// </summary>
│       │   │   53 │         /// <returns>A collection of session information</returns>
│       │   │   54 │         Task<IEnumerable<SessionInfo>> GetAllSessionsAsync();
│       │   │   55 │ 
│       │   │   56 │         /// <summary>
│       │   │   57 │         /// Gets sessions by project ID
│       │   │   58 │         /// </summary>
│       │   │   59 │         /// <param name="projectId">The project ID</param>
│       │   │   60 │         /// <returns>A collection of session information</returns>
│       │   │   61 │         Task<IEnumerable<SessionInfo>> GetSessionsByProjectAsync(string projectId);
│       │   │   62 │ 
│       │   │   63 │         /// <summary>
│       │   │   64 │         /// Gets sessions by prefix
│       │   │   65 │         /// </summary>
│       │   │   66 │         /// <param name="prefix">The session ID prefix</param>
│       │   │   67 │         /// <returns>A collection of session IDs</returns>
│       │   │   68 │         Task<IEnumerable<string>> GetSessionIdsByPrefixAsync(string prefix);
│       │   │   69 │ 
│       │   │   70 │         /// <summary>
│       │   │   71 │         /// Cleans up sessions older than the specified age
│       │   │   72 │         /// </summary>
│       │   │   73 │         /// <param name="maxAge">The maximum age of sessions to keep</param>
│       │   │   74 │         /// <returns>The number of sessions deleted</returns>
│       │   │   75 │         Task<int> CleanupOldSessionsAsync(TimeSpan maxAge);
│       │   │   76 │ 
│       │   │   77 │         /// <summary>
│       │   │   78 │         /// Optimizes the database
│       │   │   79 │         /// </summary>
│       │   │   80 │         Task OptimizeDatabaseAsync();
│       │   │   81 │ 
│       │   │   82 │         /// <summary>
│       │   │   83 │         /// Gets a database health report
│       │   │   84 │         /// </summary>
│       │   │   85 │         /// <returns>A health report string</returns>
│       │   │   86 │         Task<string> GetDatabaseHealthReportAsync();
│       │   │   87 │     }
│       │   │   88 │ }
│       │   └──────────────────────────────────────────────────────────────────────
│       ├── 📄 IDialogService.cs (873.00 B, 2025-03-11 09:48:27)
│       │   ┌──────────────────────────────────────────────────────────────────────
│       │   │ FILE CONTENT: IDialogService.cs
│       │   ├──────────────────────────────────────────────────────────────────────
│       │   │    1 │ ﻿using Avalonia.Controls;
│       │   │    2 │ using System.Collections.Generic;
│       │   │    3 │ using System.Threading.Tasks;
│       │   │    4 │ 
│       │   │    5 │ namespace test.Core.Interfaces
│       │   │    6 │ {
│       │   │    7 │     /// <summary>
│       │   │    8 │     /// Abstraction for dialog operations to enable testability and proper MVVM separation
│       │   │    9 │     /// </summary>
│       │   │   10 │     public interface IDialogService
│       │   │   11 │     {
│       │   │   12 │         Task<string[]> ShowOpenFileDialogAsync(string title, IEnumerable<FileDialogFilter> filters, bool allowMultiple = false);
│       │   │   13 │         Task<string> ShowSaveFileDialogAsync(string title, string defaultExtension, IEnumerable<FileDialogFilter> filters);
│       │   │   14 │         Task<string> ShowOpenFolderDialogAsync(string title);
│       │   │   15 │         Task<bool> ShowConfirmDialogAsync(string title, string message);
│       │   │   16 │         Task ShowErrorDialogAsync(string title, string message);
│       │   │   17 │         Task<string> ShowInputDialogAsync(string title, string message, string defaultValue = "");
│       │   │   18 │     }
│       │   │   19 │ }
│       │   └──────────────────────────────────────────────────────────────────────
│       ├── 📄 IErrorHandler.cs (1009.00 B, 2025-03-11 10:01:03)
│       │   ┌──────────────────────────────────────────────────────────────────────
│       │   │ FILE CONTENT: IErrorHandler.cs
│       │   ├──────────────────────────────────────────────────────────────────────
│       │   │    1 │ ﻿using System;
│       │   │    2 │ using System.Collections.Generic;
│       │   │    3 │ using System.Linq;
│       │   │    4 │ using System.Text;
│       │   │    5 │ using System.Threading.Tasks;
│       │   │    6 │ 
│       │   │    7 │ namespace test.Core.Interfaces
│       │   │    8 │ {
│       │   │    9 │     /// <summary>
│       │   │   10 │     /// Interface for handling errors consistently throughout the application
│       │   │   11 │     /// </summary>
│       │   │   12 │     public interface IErrorHandler
│       │   │   13 │     {
│       │   │   14 │         /// <summary>
│       │   │   15 │         /// Handles an exception without user interaction (logging only)
│       │   │   16 │         /// </summary>
│       │   │   17 │         void HandleException(Exception ex, string context);
│       │   │   18 │ 
│       │   │   19 │ 
│       │   │   20 │         /// <summary>
│       │   │   21 │         /// Handles an exception with user notification
│       │   │   22 │         /// </summary>
│       │   │   23 │         Task HandleExceptionWithUIAsync(Exception ex, string context);
│       │   │   24 │ 
│       │   │   25 │         /// <summary>
│       │   │   26 │         /// Logs a warning message
│       │   │   27 │         /// </summary>
│       │   │   28 │         void LogWarning(string message, string context);
│       │   │   29 │ 
│       │   │   30 │         /// <summary>
│       │   │   31 │         /// Records a telemetry event
│       │   │   32 │         /// </summary>
│       │   │   33 │         void TrackEvent(string name, IDictionary<string, string> properties = null);
│       │   │   34 │     }
│       │   │   35 │ }
│       │   └──────────────────────────────────────────────────────────────────────
│       ├── 📄 IExportService.cs (5.73 KB, 2025-03-11 09:48:27)
│       │   ┌──────────────────────────────────────────────────────────────────────
│       │   │ FILE CONTENT: IExportService.cs
│       │   ├──────────────────────────────────────────────────────────────────────
│       │   │    1 │ ﻿using System.Collections.Generic;
│       │   │    2 │ using System.Threading.Tasks;
│       │   │    3 │ using test.Core.Domain;
│       │   │    4 │ 
│       │   │    5 │ namespace test.Core.Interfaces
│       │   │    6 │ {
│       │   │    7 │     /// <summary>
│       │   │    8 │     /// Service interface for exporting controller data to various formats
│       │   │    9 │     /// </summary>
│       │   │   10 │     public interface IExportService
│       │   │   11 │     {
│       │   │   12 │         /// <summary>
│       │   │   13 │         /// Exports controllers to XML format
│       │   │   14 │         /// </summary>
│       │   │   15 │         /// <param name="controllers">The controllers to export</param>
│       │   │   16 │         /// <param name="filePath">The output file path</param>
│       │   │   17 │         /// <param name="options">Export options (optional)</param>
│       │   │   18 │         /// <returns>True if successful, false otherwise</returns>
│       │   │   19 │         Task<bool> ExportToXmlAsync(IEnumerable<Controller> controllers, string filePath, ExportOptions options = null);
│       │   │   20 │ 
│       │   │   21 │         /// <summary>
│       │   │   22 │         /// Exports controllers to Excel format
│       │   │   23 │         /// </summary>
│       │   │   24 │         /// <param name="controllers">The controllers to export</param>
│       │   │   25 │         /// <param name="filePath">The output file path</param>
│       │   │   26 │         /// <param name="options">Export options (optional)</param>
│       │   │   27 │         /// <returns>True if successful, false otherwise</returns>
│       │   │   28 │         Task<bool> ExportToExcelAsync(IEnumerable<Controller> controllers, string filePath, ExportOptions options = null);
│       │   │   29 │ 
│       │   │   30 │         /// <summary>
│       │   │   31 │         /// Exports controllers to CSV format
│       │   │   32 │         /// </summary>
│       │   │   33 │         /// <param name="controllers">The controllers to export</param>
│       │   │   34 │         /// <param name="filePath">The output file path</param>
│       │   │   35 │         /// <param name="options">Export options (optional)</param>
│       │   │   36 │         /// <returns>A collection of found group comparisons</returns>
│       │   │   37 │         Task<IEnumerable<GroupComparison>> ExportToGroupedCsvAsync(IEnumerable<Controller> controllers, string filePath, ExportOptions options = null);
│       │   │   38 │ 
│       │   │   39 │         /// <summary>
│       │   │   40 │         /// Gets available export formats
│       │   │   41 │         /// </summary>
│       │   │   42 │         /// <returns>A collection of export format descriptors</returns>
│       │   │   43 │         IEnumerable<ExportFormat> GetAvailableFormats();
│       │   │   44 │     }
│       │   │   45 │ 
│       │   │   46 │     /// <summary>
│       │   │   47 │     /// Options for export operations
│       │   │   48 │     /// </summary>
│       │   │   49 │     public class ExportOptions
│       │   │   50 │     {
│       │   │   51 │         /// <summary>
│       │   │   52 │         /// Whether to include byte code in the export
│       │   │   53 │         /// </summary>
│       │   │   54 │         public bool IncludeByteCode { get; set; } = false;
│       │   │   55 │ 
│       │   │   56 │         /// <summary>
│       │   │   57 │         /// Whether to include empty values in the export
│       │   │   58 │         /// </summary>
│       │   │   59 │         public bool IncludeEmptyValues { get; set; } = true;
│       │   │   60 │ 
│       │   │   61 │         /// <summary>
│       │   │   62 │         /// Types to include (empty for all types)
│       │   │   63 │         /// </summary>
│       │   │   64 │         public HashSet<string> IncludedTypes { get; set; } = new HashSet<string>();
│       │   │   65 │ 
│       │   │   66 │         /// <summary>
│       │   │   67 │         /// Names to exclude (for objects)
│       │   │   68 │         /// </summary>
│       │   │   69 │         public HashSet<string> ExcludedNames { get; set; } = new HashSet<string>();
│       │   │   70 │ 
│       │   │   71 │         /// <summary>
│       │   │   72 │         /// Whether to pretty-print/format the output (for applicable formats)
│       │   │   73 │         /// </summary>
│       │   │   74 │         public bool PrettyPrint { get; set; } = true;
│       │   │   75 │ 
│       │   │   76 │         /// <summary>
│       │   │   77 │         /// Additional format-specific options
│       │   │   78 │         /// </summary>
│       │   │   79 │         public Dictionary<string, string> AdditionalOptions { get; set; } = new Dictionary<string, string>();
│       │   │   80 │     }
│       │   │   81 │ 
│       │   │   82 │     /// <summary>
│       │   │   83 │     /// Describes an export format
│       │   │   84 │     /// </summary>
│       │   │   85 │     public class ExportFormat
│       │   │   86 │     {
│       │   │   87 │         /// <summary>
│       │   │   88 │         /// The format ID
│       │   │   89 │         /// </summary>
│       │   │   90 │         public string Id { get; set; }
│       │   │   91 │ 
│       │   │   92 │         /// <summary>
│       │   │   93 │         /// The display name
│       │   │   94 │         /// </summary>
│       │   │   95 │         public string DisplayName { get; set; }
│       │   │   96 │ 
│       │   │   97 │         /// <summary>
│       │   │   98 │         /// The file extension
│       │   │   99 │         /// </summary>
│       │   │  100 │         public string Extension { get; set; }
│       │   │  101 │ 
│       │   │  102 │         /// <summary>
│       │   │  103 │         /// The MIME type
│       │   │  104 │         /// </summary>
│       │   │  105 │         public string MimeType { get; set; }
│       │   │  106 │ 
│       │   │  107 │         /// <summary>
│       │   │  108 │         /// Whether byte code is supported
│       │   │  109 │         /// </summary>
│       │   │  110 │         public bool SupportsById { get; set; }
│       │   │  111 │ 
│       │   │  112 │         /// <summary>
│       │   │  113 │         /// Brief description of the format
│       │   │  114 │         /// </summary>
│       │   │  115 │         public string Description { get; set; }
│       │   │  116 │     }
│       │   │  117 │ 
│       │   │  118 │     /// <summary>
│       │   │  119 │     /// Result of a group comparison during CSV export
│       │   │  120 │     /// </summary>
│       │   │  121 │     public class GroupComparison
│       │   │  122 │     {
│       │   │  123 │         /// <summary>
│       │   │  124 │         /// First group identifier
│       │   │  125 │         /// </summary>
│       │   │  126 │         public string Group1Key { get; set; }
│       │   │  127 │ 
│       │   │  128 │         /// <summary>
│       │   │  129 │         /// Second group identifier
│       │   │  130 │         /// </summary>
│       │   │  131 │         public string Group2Key { get; set; }
│       │   │  132 │ 
│       │   │  133 │         /// <summary>
│       │   │  134 │         /// Number of controllers in first group
│       │   │  135 │         /// </summary>
│       │   │  136 │         public int ControllersInGroup1 { get; set; }
│       │   │  137 │ 
│       │   │  138 │         /// <summary>
│       │   │  139 │         /// Number of controllers in second group
│       │   │  140 │         /// </summary>
│       │   │  141 │         public int ControllersInGroup2 { get; set; }
│       │   │  142 │ 
│       │   │  143 │         /// <summary>
│       │   │  144 │         /// Collection of different property names
│       │   │  145 │         /// </summary>
│       │   │  146 │         public List<string> DifferentProperties { get; set; } = new List<string>();
│       │   │  147 │ 
│       │   │  148 │         /// <summary>
│       │   │  149 │         /// First controller name in group 1
│       │   │  150 │         /// </summary>
│       │   │  151 │         public string FirstControllerGroup1 { get; set; }
│       │   │  152 │ 
│       │   │  153 │         /// <summary>
│       │   │  154 │         /// First controller name in group 2
│       │   │  155 │         /// </summary>
│       │   │  156 │         public string FirstControllerGroup2 { get; set; }
│       │   │  157 │ 
│       │   │  158 │         /// <summary>
│       │   │  159 │         /// Returns a string representation of the comparison
│       │   │  160 │         /// </summary>
│       │   │  161 │         public override string ToString()
│       │   │  162 │         {
│       │   │  163 │             return $"Group 1 ({ControllersInGroup1} controllers, first: {FirstControllerGroup1}) vs " +
│       │   │  164 │                    $"Group 2 ({ControllersInGroup2} controllers, first: {FirstControllerGroup2})\n" +
│       │   │  165 │                    $"Different Properties ({DifferentProperties.Count}): {string.Join(", ", DifferentProperties)}\n";
│       │   │  166 │         }
│       │   │  167 │     }
│       │   │  168 │ }
│       │   └──────────────────────────────────────────────────────────────────────
│       ├── 📄 IFileSystem.cs (675.00 B, 2025-03-11 09:48:27)
│       │   ┌──────────────────────────────────────────────────────────────────────
│       │   │ FILE CONTENT: IFileSystem.cs
│       │   ├──────────────────────────────────────────────────────────────────────
│       │   │    1 │ ﻿using System;
│       │   │    2 │ using System.Collections.Generic;
│       │   │    3 │ using System.IO;
│       │   │    4 │ using System.Linq;
│       │   │    5 │ using System.Text;
│       │   │    6 │ using System.Threading.Tasks;
│       │   │    7 │ 
│       │   │    8 │ namespace test.Core.Interfaces
│       │   │    9 │ {
│       │   │   10 │     /// <summary>
│       │   │   11 │     /// Abstraction for file system operations to enable testability and decoupling
│       │   │   12 │     /// </summary>
│       │   │   13 │     public interface IFileSystem
│       │   │   14 │     {
│       │   │   15 │         Task<string> ReadAllTextAsync(string path);
│       │   │   16 │         Task WriteAllTextAsync(string path, string content);
│       │   │   17 │         bool FileExists(string path);
│       │   │   18 │         Stream OpenRead(string path);
│       │   │   19 │         Stream OpenWrite(string path);
│       │   │   20 │         void CreateDirectory(string path);
│       │   │   21 │         bool DirectoryExists(string path);
│       │   │   22 │     }
│       │   │   23 │ }
│       │   └──────────────────────────────────────────────────────────────────────
│       ├── 📄 ILoggingService.cs (858.00 B, 2025-03-12 12:24:10)
│       │   ┌──────────────────────────────────────────────────────────────────────
│       │   │ FILE CONTENT: ILoggingService.cs
│       │   ├──────────────────────────────────────────────────────────────────────
│       │   │    1 │ ﻿using Serilog.Events;
│       │   │    2 │ 
│       │   │    3 │ namespace test.Core.Interfaces
│       │   │    4 │ {
│       │   │    5 │     /// <summary>
│       │   │    6 │     /// Interface for application logging service
│       │   │    7 │     /// </summary>
│       │   │    8 │     public interface ILoggingService
│       │   │    9 │     {
│       │   │   10 │         /// <summary>
│       │   │   11 │         /// Enables or disables logging
│       │   │   12 │         /// </summary>
│       │   │   13 │         /// <param name="enable">Whether to enable logging</param>
│       │   │   14 │         void EnableLogging(bool enable);
│       │   │   15 │ 
│       │   │   16 │         /// <summary>
│       │   │   17 │         /// Gets whether logging is enabled
│       │   │   18 │         /// </summary>
│       │   │   19 │         bool IsLoggingEnabled { get; }
│       │   │   20 │ 
│       │   │   21 │         /// <summary>
│       │   │   22 │         /// Gets the path to the log file
│       │   │   23 │         /// </summary>
│       │   │   24 │         string LogFilePath { get; }
│       │   │   25 │ 
│       │   │   26 │         /// <summary>
│       │   │   27 │         /// Sets the log level
│       │   │   28 │         /// </summary>
│       │   │   29 │         /// <param name="level">The log level to set</param>
│       │   │   30 │         void SetLogLevel(LogEventLevel level);
│       │   │   31 │     }
│       │   │   32 │ }
│       │   └──────────────────────────────────────────────────────────────────────
│       ├── 📄 INavigationService.cs (2.05 KB, 2025-03-11 16:15:02)
│       │   ┌──────────────────────────────────────────────────────────────────────
│       │   │ FILE CONTENT: INavigationService.cs
│       │   ├──────────────────────────────────────────────────────────────────────
│       │   │    1 │ ﻿using System;
│       │   │    2 │ 
│       │   │    3 │ namespace test.Core.Interfaces
│       │   │    4 │ {
│       │   │    5 │     /// <summary>
│       │   │    6 │     /// Interface for navigation between different views in the application
│       │   │    7 │     /// </summary>
│       │   │    8 │     public interface INavigationService
│       │   │    9 │     {
│       │   │   10 │         /// <summary>
│       │   │   11 │         /// Navigates to the specified view
│       │   │   12 │         /// </summary>
│       │   │   13 │         /// <param name="viewName">The name of the view to navigate to</param>
│       │   │   14 │         /// <param name="parameter">Optional parameter to pass to the view</param>
│       │   │   15 │         /// <returns>True if navigation was successful, false otherwise</returns>
│       │   │   16 │         bool NavigateTo(string viewName, object parameter = null);
│       │   │   17 │ 
│       │   │   18 │         /// <summary>
│       │   │   19 │         /// Checks if navigation to the specified view is possible
│       │   │   20 │         /// </summary>
│       │   │   21 │         /// <param name="viewName">The name of the view to check</param>
│       │   │   22 │         /// <returns>True if navigation is possible, false otherwise</returns>
│       │   │   23 │         bool CanNavigate(string viewName);
│       │   │   24 │ 
│       │   │   25 │         /// <summary>
│       │   │   26 │         /// Gets the name of the currently active view
│       │   │   27 │         /// </summary>
│       │   │   28 │         string CurrentView { get; }
│       │   │   29 │ 
│       │   │   30 │         /// <summary>
│       │   │   31 │         /// Event raised when navigation occurs
│       │   │   32 │         /// </summary>
│       │   │   33 │         event EventHandler<NavigationEventArgs> Navigated;
│       │   │   34 │     }
│       │   │   35 │ 
│       │   │   36 │     /// <summary>
│       │   │   37 │     /// Event arguments for navigation events
│       │   │   38 │     /// </summary>
│       │   │   39 │     public class NavigationEventArgs : EventArgs
│       │   │   40 │     {
│       │   │   41 │         /// <summary>
│       │   │   42 │         /// The name of the view being navigated to
│       │   │   43 │         /// </summary>
│       │   │   44 │         public string ViewName { get; }
│       │   │   45 │ 
│       │   │   46 │         /// <summary>
│       │   │   47 │         /// Any additional parameters for the navigation
│       │   │   48 │         /// </summary>
│       │   │   49 │         public object Parameter { get; }
│       │   │   50 │ 
│       │   │   51 │         /// <summary>
│       │   │   52 │         /// Creates new navigation event arguments
│       │   │   53 │         /// </summary>
│       │   │   54 │         /// <param name="viewName">The view name</param>
│       │   │   55 │         /// <param name="parameter">Optional navigation parameter</param>
│       │   │   56 │         public NavigationEventArgs(string viewName, object parameter = null)
│       │   │   57 │         {
│       │   │   58 │             ViewName = viewName;
│       │   │   59 │             Parameter = parameter;
│       │   │   60 │         }
│       │   │   61 │     }
│       │   │   62 │ }
│       │   └──────────────────────────────────────────────────────────────────────
│       ├── 📄 IObjectSetParser.cs (2.43 KB, 2025-03-11 14:56:16)
│       │   ┌──────────────────────────────────────────────────────────────────────
│       │   │ FILE CONTENT: IObjectSetParser.cs
│       │   ├──────────────────────────────────────────────────────────────────────
│       │   │    1 │ ﻿using System.Collections.Generic;
│       │   │    2 │ using System.Threading.Tasks;
│       │   │    3 │ using System.Xml.Linq;
│       │   │    4 │ using test.Core.Domain.ObjectSet;
│       │   │    5 │ 
│       │   │    6 │ namespace test.Core.Interfaces
│       │   │    7 │ {
│       │   │    8 │     /// <summary>
│       │   │    9 │     /// Interface for parsing ObjectSet XML documents
│       │   │   10 │     /// </summary>
│       │   │   11 │     public interface IObjectSetParser
│       │   │   12 │     {
│       │   │   13 │         /// <summary>
│       │   │   14 │         /// Parses an ObjectSet XML document
│       │   │   15 │         /// </summary>
│       │   │   16 │         /// <param name="document">The XML document to parse</param>
│       │   │   17 │         /// <param name="options">Parsing options</param>
│       │   │   18 │         /// <returns>The parsing result</returns>
│       │   │   19 │         Task<ObjectSetParseResult> ParseAsync(XDocument document, ObjectSetParsingOptions options);
│       │   │   20 │ 
│       │   │   21 │         /// <summary>
│       │   │   22 │         /// Parses meta information from an ObjectSet XML document
│       │   │   23 │         /// </summary>
│       │   │   24 │         /// <param name="document">The XML document</param>
│       │   │   25 │         /// <returns>The meta information</returns>
│       │   │   26 │         MetaInformation ParseMetaInformation(XDocument document);
│       │   │   27 │ 
│       │   │   28 │         /// <summary>
│       │   │   29 │         /// Parses type definitions from an ObjectSet XML document
│       │   │   30 │         /// </summary>
│       │   │   31 │         /// <param name="document">The XML document</param>
│       │   │   32 │         /// <param name="typeWhitelist">Optional type whitelist</param>
│       │   │   33 │         /// <returns>The type definitions</returns>
│       │   │   34 │         List<ObjectTypeDefinition> ParseTypeDefinitions(XDocument document, HashSet<string> typeWhitelist = null);
│       │   │   35 │ 
│       │   │   36 │         /// <summary>
│       │   │   37 │         /// Parses exported objects from an ObjectSet XML document
│       │   │   38 │         /// </summary>
│       │   │   39 │         /// <param name="document">The XML document</param>
│       │   │   40 │         /// <returns>The exported objects</returns>
│       │   │   41 │         List<ExportedObject> ParseExportedObjects(XDocument document);
│       │   │   42 │     }
│       │   │   43 │ 
│       │   │   44 │     /// <summary>
│       │   │   45 │     /// Options for parsing ObjectSet XML
│       │   │   46 │     /// </summary>
│       │   │   47 │     public class ObjectSetParsingOptions
│       │   │   48 │     {
│       │   │   49 │         /// <summary>
│       │   │   50 │         /// Whether to include meta information
│       │   │   51 │         /// </summary>
│       │   │   52 │         public bool IncludeMetaInformation { get; set; } = true;
│       │   │   53 │ 
│       │   │   54 │         /// <summary>
│       │   │   55 │         /// Whether to include type definitions
│       │   │   56 │         /// </summary>
│       │   │   57 │         public bool IncludeTypeDefinitions { get; set; } = true;
│       │   │   58 │ 
│       │   │   59 │         /// <summary>
│       │   │   60 │         /// Whether to include exported objects
│       │   │   61 │         /// </summary>
│       │   │   62 │         public bool IncludeExportedObjects { get; set; } = true;
│       │   │   63 │ 
│       │   │   64 │         /// <summary>
│       │   │   65 │         /// Optional type whitelist
│       │   │   66 │         /// </summary>
│       │   │   67 │         public HashSet<string> TypeWhitelist { get; set; } = new();
│       │   │   68 │     }
│       │   │   69 │ }
│       │   └──────────────────────────────────────────────────────────────────────
│       ├── 📄 IObjectSetWriter.cs (1.48 KB, 2025-03-11 14:56:30)
│       │   ┌──────────────────────────────────────────────────────────────────────
│       │   │ FILE CONTENT: IObjectSetWriter.cs
│       │   ├──────────────────────────────────────────────────────────────────────
│       │   │    1 │ ﻿using System.Collections.Generic;
│       │   │    2 │ using System.Threading.Tasks;
│       │   │    3 │ using System.Xml.Linq;
│       │   │    4 │ using test.Core.Domain;
│       │   │    5 │ using test.Core.Domain.ObjectSet;
│       │   │    6 │ 
│       │   │    7 │ namespace test.Core.Interfaces
│       │   │    8 │ {
│       │   │    9 │     /// <summary>
│       │   │   10 │     /// Interface for writing controllers to ObjectSet XML format
│       │   │   11 │     /// </summary>
│       │   │   12 │     public interface IObjectSetWriter
│       │   │   13 │     {
│       │   │   14 │         /// <summary>
│       │   │   15 │         /// Converts controllers to ObjectSet XML
│       │   │   16 │         /// </summary>
│       │   │   17 │         /// <param name="controllers">The controllers to convert</param>
│       │   │   18 │         /// <param name="options">Writing options</param>
│       │   │   19 │         /// <returns>The generated XML document</returns>
│       │   │   20 │         Task<XDocument> WriteAsync(IEnumerable<Controller> controllers, ObjectSetWriteOptions options = null);
│       │   │   21 │     }
│       │   │   22 │ 
│       │   │   23 │     /// <summary>
│       │   │   24 │     /// Options for writing to ObjectSet XML format
│       │   │   25 │     /// </summary>
│       │   │   26 │     public class ObjectSetWriteOptions
│       │   │   27 │     {
│       │   │   28 │         /// <summary>
│       │   │   29 │         /// Meta information to include
│       │   │   30 │         /// </summary>
│       │   │   31 │         public MetaInformation MetaInformation { get; set; }
│       │   │   32 │ 
│       │   │   33 │         /// <summary>
│       │   │   34 │         /// Type definitions to include
│       │   │   35 │         /// </summary>
│       │   │   36 │         public IEnumerable<ObjectTypeDefinition> TypeDefinitions { get; set; }
│       │   │   37 │ 
│       │   │   38 │         /// <summary>
│       │   │   39 │         /// Whether to include byte code
│       │   │   40 │         /// </summary>
│       │   │   41 │         public bool IncludeByteCode { get; set; } = false;
│       │   │   42 │ 
│       │   │   43 │         /// <summary>
│       │   │   44 │         /// Whether to pretty-print the XML
│       │   │   45 │         /// </summary>
│       │   │   46 │         public bool PrettyPrint { get; set; } = true;
│       │   │   47 │     }
│       │   │   48 │ }
│       │   └──────────────────────────────────────────────────────────────────────
│       ├── 📄 IProjectRepository.cs (3.61 KB, 2025-03-11 09:48:27)
│       │   ┌──────────────────────────────────────────────────────────────────────
│       │   │ FILE CONTENT: IProjectRepository.cs
│       │   ├──────────────────────────────────────────────────────────────────────
│       │   │    1 │ ﻿using System;
│       │   │    2 │ using System.Collections.Generic;
│       │   │    3 │ using System.Linq;
│       │   │    4 │ using System.Text;
│       │   │    5 │ using System.Threading.Tasks;
│       │   │    6 │ using test.Core.Domain;
│       │   │    7 │ using System.Collections.Generic;
│       │   │    8 │ using System.Threading.Tasks;
│       │   │    9 │ 
│       │   │   10 │ namespace test.Core.Interfaces
│       │   │   11 │ {
│       │   │   12 │     /// <summary>
│       │   │   13 │     /// Repository interface for project operations
│       │   │   14 │     /// </summary>
│       │   │   15 │     public interface IProjectRepository
│       │   │   16 │     {
│       │   │   17 │         /// <summary>
│       │   │   18 │         /// Gets a project by ID
│       │   │   19 │         /// </summary>
│       │   │   20 │         /// <param name="id">The project ID</param>
│       │   │   21 │         /// <returns>The project or null if not found</returns>
│       │   │   22 │         Task<Project> GetByIdAsync(string id);
│       │   │   23 │ 
│       │   │   24 │         /// <summary>
│       │   │   25 │         /// Gets all projects
│       │   │   26 │         /// </summary>
│       │   │   27 │         /// <returns>A collection of all projects</returns>
│       │   │   28 │         Task<IEnumerable<Project>> GetAllAsync();
│       │   │   29 │ 
│       │   │   30 │         /// <summary>
│       │   │   31 │         /// Creates a new project
│       │   │   32 │         /// </summary>
│       │   │   33 │         /// <param name="project">The project to create</param>
│       │   │   34 │         Task CreateAsync(Project project);
│       │   │   35 │ 
│       │   │   36 │         /// <summary>
│       │   │   37 │         /// Updates a project
│       │   │   38 │         /// </summary>
│       │   │   39 │         /// <param name="project">The project to update</param>
│       │   │   40 │         Task UpdateAsync(Project project);
│       │   │   41 │ 
│       │   │   42 │         /// <summary>
│       │   │   43 │         /// Deletes a project
│       │   │   44 │         /// </summary>
│       │   │   45 │         /// <param name="id">The ID of the project to delete</param>
│       │   │   46 │         /// <returns>True if deleted, false if not found</returns>
│       │   │   47 │         Task<bool> DeleteAsync(string id);
│       │   │   48 │ 
│       │   │   49 │         /// <summary>
│       │   │   50 │         /// Imports a file into a project
│       │   │   51 │         /// </summary>
│       │   │   52 │         /// <param name="projectId">The project ID</param>
│       │   │   53 │         /// <param name="sourceFilePath">The source file path</param>
│       │   │   54 │         /// <returns>The imported file</returns>
│       │   │   55 │         Task<ImportedFile> ImportFileAsync(string projectId, string sourceFilePath);
│       │   │   56 │ 
│       │   │   57 │         /// <summary>
│       │   │   58 │         /// Removes a file from a project
│       │   │   59 │         /// </summary>
│       │   │   60 │         /// <param name="projectId">The project ID</param>
│       │   │   61 │         /// <param name="filePath">The file path</param>
│       │   │   62 │         /// <returns>True if removed, false if not found</returns>
│       │   │   63 │         Task<bool> RemoveFileAsync(string projectId, string filePath);
│       │   │   64 │ 
│       │   │   65 │         /// <summary>
│       │   │   66 │         /// Adds a shared type to a project
│       │   │   67 │         /// </summary>
│       │   │   68 │         /// <param name="projectId">The project ID</param>
│       │   │   69 │         /// <param name="sourceFilePath">The source file path</param>
│       │   │   70 │         /// <param name="typeName">The type name</param>
│       │   │   71 │         /// <param name="category">The category</param>
│       │   │   72 │         /// <param name="description">The description</param>
│       │   │   73 │         /// <returns>The added shared type</returns>
│       │   │   74 │         Task<SharedType> AddSharedTypeAsync(
│       │   │   75 │             string projectId,
│       │   │   76 │             string sourceFilePath,
│       │   │   77 │             string typeName = null,
│       │   │   78 │             string category = null,
│       │   │   79 │             string description = null);
│       │   │   80 │ 
│       │   │   81 │         /// <summary>
│       │   │   82 │         /// Updates a shared type description
│       │   │   83 │         /// </summary>
│       │   │   84 │         /// <param name="projectId">The project ID</param>
│       │   │   85 │         /// <param name="filePath">The file path</param>
│       │   │   86 │         /// <param name="description">The new description</param>
│       │   │   87 │         /// <returns>True if updated, false if not found</returns>
│       │   │   88 │         Task<bool> UpdateSharedTypeDescriptionAsync(string projectId, string filePath, string description);
│       │   │   89 │ 
│       │   │   90 │         /// <summary>
│       │   │   91 │         /// Removes a shared type from a project
│       │   │   92 │         /// </summary>
│       │   │   93 │         /// <param name="projectId">The project ID</param>
│       │   │   94 │         /// <param name="filePath">The file path</param>
│       │   │   95 │         /// <returns>True if removed, false if not found</returns>
│       │   │   96 │         Task<bool> RemoveSharedTypeAsync(string projectId, string filePath);
│       │   │   97 │     }
│       │   │   98 │ }
│       │   └──────────────────────────────────────────────────────────────────────
│       ├── 📄 IRepository.cs (1.58 KB, 2025-03-11 09:48:27)
│       │   ┌──────────────────────────────────────────────────────────────────────
│       │   │ FILE CONTENT: IRepository.cs
│       │   ├──────────────────────────────────────────────────────────────────────
│       │   │    1 │ ﻿using System;
│       │   │    2 │ using System.Collections.Generic;
│       │   │    3 │ using System.Linq;
│       │   │    4 │ using System.Text;
│       │   │    5 │ using System.Threading.Tasks;
│       │   │    6 │ using System.Collections.Generic;
│       │   │    7 │ using System.Threading.Tasks;
│       │   │    8 │ 
│       │   │    9 │ namespace test.Core.Interfaces
│       │   │   10 │ {
│       │   │   11 │     /// <summary>
│       │   │   12 │     /// Generic repository interface for basic CRUD operations
│       │   │   13 │     /// </summary>
│       │   │   14 │     /// <typeparam name="T">The entity type</typeparam>
│       │   │   15 │     /// <typeparam name="TId">The type of the entity ID</typeparam>
│       │   │   16 │     public interface IRepository<T, TId>
│       │   │   17 │     {
│       │   │   18 │         /// <summary>
│       │   │   19 │         /// Creates a new entity
│       │   │   20 │         /// </summary>
│       │   │   21 │         /// <param name="entity">The entity to create</param>
│       │   │   22 │         /// <returns>The ID of the created entity</returns>
│       │   │   23 │         Task<TId> CreateAsync(T entity);
│       │   │   24 │ 
│       │   │   25 │         /// <summary>
│       │   │   26 │         /// Gets an entity by ID
│       │   │   27 │         /// </summary>
│       │   │   28 │         /// <param name="id">The entity ID</param>
│       │   │   29 │         /// <returns>The entity or null if not found</returns>
│       │   │   30 │         Task<T> GetByIdAsync(TId id);
│       │   │   31 │ 
│       │   │   32 │         /// <summary>
│       │   │   33 │         /// Gets all entities
│       │   │   34 │         /// </summary>
│       │   │   35 │         /// <returns>A collection of all entities</returns>
│       │   │   36 │         Task<IEnumerable<T>> GetAllAsync();
│       │   │   37 │ 
│       │   │   38 │         /// <summary>
│       │   │   39 │         /// Updates an entity
│       │   │   40 │         /// </summary>
│       │   │   41 │         /// <param name="entity">The entity to update</param>
│       │   │   42 │         Task UpdateAsync(T entity);
│       │   │   43 │ 
│       │   │   44 │         /// <summary>
│       │   │   45 │         /// Deletes an entity
│       │   │   46 │         /// </summary>
│       │   │   47 │         /// <param name="id">The ID of the entity to delete</param>
│       │   │   48 │         /// <returns>True if deleted, false if not found</returns>
│       │   │   49 │         Task<bool> DeleteAsync(TId id);
│       │   │   50 │     }
│       │   │   51 │ }
│       │   └──────────────────────────────────────────────────────────────────────
│       └── 📄 IXmlModificationService.cs (1.65 KB, 2025-03-11 15:48:01)
│           ┌──────────────────────────────────────────────────────────────────────
│           │ FILE CONTENT: IXmlModificationService.cs
│           ├──────────────────────────────────────────────────────────────────────
│           │    1 │ ﻿// test/Core/Interfaces/IXmlModificationService.cs
│           │    2 │ using System;
│           │    3 │ using System.Threading.Tasks;
│           │    4 │ 
│           │    5 │ namespace test.Core.Interfaces
│           │    6 │ {
│           │    7 │     /// <summary>
│           │    8 │     /// Interface for XML modification operations
│           │    9 │     /// </summary>
│           │   10 │     public interface IXmlModificationService
│           │   11 │     {
│           │   12 │         /// <summary>
│           │   13 │         /// Updates variable unit values in an XML file
│           │   14 │         /// </summary>
│           │   15 │         /// <param name="filePath">The XML file path</param>
│           │   16 │         /// <param name="variableName">The variable name to update</param>
│           │   17 │         /// <param name="newUnit">The new unit value</param>
│           │   18 │         /// <returns>True if successful, false otherwise</returns>
│           │   19 │         Task<bool> UpdateVariableUnitValuesAsync(string filePath, string variableName, string newUnit);
│           │   20 │ 
│           │   21 │         /// <summary>
│           │   22 │         /// Updates an object value in an XML file
│           │   23 │         /// </summary>
│           │   24 │         /// <param name="filePath">The XML file path</param>
│           │   25 │         /// <param name="objectName">The object name to update</param>
│           │   26 │         /// <param name="newValue">The new value</param>
│           │   27 │         /// <returns>True if successful, false otherwise</returns>
│           │   28 │         Task<bool> UpdateObjectValueAsync(string filePath, string objectName, string newValue);
│           │   29 │ 
│           │   30 │         /// <summary>
│           │   31 │         /// Applies a transformation function to numeric values in an XML file
│           │   32 │         /// </summary>
│           │   33 │         /// <param name="filePath">The XML file path</param>
│           │   34 │         /// <param name="transformationFunc">The transformation function to apply</param>
│           │   35 │         /// <returns>True if successful, false otherwise</returns>
│           │   36 │         Task<bool> UpdateNumericValuesAsync(string filePath, Func<string, double, double> transformationFunc);
│           │   37 │     }
│           │   38 │ }
│           └──────────────────────────────────────────────────────────────────────
│   📁 Data
│   │   📁 Mapping
│   │   ├── 📄 ControllerGroupMapper.cs (4.27 KB, 2025-03-11 13:30:52)
│   │   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │   │ FILE CONTENT: ControllerGroupMapper.cs
│   │   │   ├──────────────────────────────────────────────────────────────────────
│   │   │   │    1 │ ﻿using System;
│   │   │   │    2 │ using System.Collections.Generic;
│   │   │   │    3 │ using test.Core.Domain;
│   │   │   │    4 │ using test.Core.Dto;
│   │   │   │    5 │ 
│   │   │   │    6 │ namespace test.Data.Mapping
│   │   │   │    7 │ {
│   │   │   │    8 │     /// <summary>
│   │   │   │    9 │     /// Mapping utilities for converting between domain ControllerGroup and DTO versions
│   │   │   │   10 │     /// </summary>
│   │   │   │   11 │     public static class ControllerGroupMapper
│   │   │   │   12 │     {
│   │   │   │   13 │         /// <summary>
│   │   │   │   14 │         /// Maps a domain ControllerGroup to a DTO
│   │   │   │   15 │         /// </summary>
│   │   │   │   16 │         /// <param name="domain">The domain entity</param>
│   │   │   │   17 │         /// <returns>The mapped DTO</returns>
│   │   │   │   18 │         public static ControllerGroupDto ToDto(ControllerGroup domain)
│   │   │   │   19 │         {
│   │   │   │   20 │             if (domain == null) return null;
│   │   │   │   21 │ 
│   │   │   │   22 │             var dto = new ControllerGroupDto
│   │   │   │   23 │             {
│   │   │   │   24 │                 GroupIdentifier = domain.GroupIdentifier,
│   │   │   │   25 │                 ControllerNames = new List<string>(domain.ControllerNames),
│   │   │   │   26 │                 OriginalValues = new Dictionary<string, string>(domain.OriginalValues, StringComparer.OrdinalIgnoreCase),
│   │   │   │   27 │                 ProcessedValues = new Dictionary<string, string>(domain.ProcessedValues, StringComparer.OrdinalIgnoreCase),
│   │   │   │   28 │                 NameMapping = new Dictionary<string, string>(domain.NameMapping, StringComparer.OrdinalIgnoreCase)
│   │   │   │   29 │             };
│   │   │   │   30 │ 
│   │   │   │   31 │             return dto;
│   │   │   │   32 │         }
│   │   │   │   33 │ 
│   │   │   │   34 │         /// <summary>
│   │   │   │   35 │         /// Maps a DTO to a domain ControllerGroup
│   │   │   │   36 │         /// </summary>
│   │   │   │   37 │         /// <param name="dto">The DTO</param>
│   │   │   │   38 │         /// <returns>The mapped domain entity</returns>
│   │   │   │   39 │         public static ControllerGroup ToDomain(ControllerGroupDto dto)
│   │   │   │   40 │         {
│   │   │   │   41 │             if (dto == null) return null;
│   │   │   │   42 │ 
│   │   │   │   43 │             var domain = new ControllerGroup(dto.GroupIdentifier ?? "unknown");
│   │   │   │   44 │ 
│   │   │   │   45 │             // Add controller names
│   │   │   │   46 │             if (dto.ControllerNames != null)
│   │   │   │   47 │             {
│   │   │   │   48 │                 foreach (var name in dto.ControllerNames)
│   │   │   │   49 │                 {
│   │   │   │   50 │                     domain.AddControllerName(name);
│   │   │   │   51 │                 }
│   │   │   │   52 │             }
│   │   │   │   53 │ 
│   │   │   │   54 │             // Add original values
│   │   │   │   55 │             if (dto.OriginalValues != null)
│   │   │   │   56 │             {
│   │   │   │   57 │                 foreach (var kvp in dto.OriginalValues)
│   │   │   │   58 │                 {
│   │   │   │   59 │                     domain.AddOriginalValue(kvp.Key, kvp.Value);
│   │   │   │   60 │                 }
│   │   │   │   61 │             }
│   │   │   │   62 │ 
│   │   │   │   63 │             // Add processed values
│   │   │   │   64 │             if (dto.ProcessedValues != null)
│   │   │   │   65 │             {
│   │   │   │   66 │                 foreach (var kvp in dto.ProcessedValues)
│   │   │   │   67 │                 {
│   │   │   │   68 │                     domain.AddProcessedValue(kvp.Key, kvp.Value);
│   │   │   │   69 │                 }
│   │   │   │   70 │             }
│   │   │   │   71 │ 
│   │   │   │   72 │             // Add name mappings
│   │   │   │   73 │             if (dto.NameMapping != null)
│   │   │   │   74 │             {
│   │   │   │   75 │                 foreach (var kvp in dto.NameMapping)
│   │   │   │   76 │                 {
│   │   │   │   77 │                     domain.AddMapping(kvp.Key, kvp.Value);
│   │   │   │   78 │                 }
│   │   │   │   79 │             }
│   │   │   │   80 │ 
│   │   │   │   81 │             return domain;
│   │   │   │   82 │         }
│   │   │   │   83 │ 
│   │   │   │   84 │         /// <summary>
│   │   │   │   85 │         /// Maps a collection of domain ControllerGroups to DTOs
│   │   │   │   86 │         /// </summary>
│   │   │   │   87 │         /// <param name="domainCollection">The domain collection</param>
│   │   │   │   88 │         /// <returns>The DTO collection</returns>
│   │   │   │   89 │         public static IEnumerable<ControllerGroupDto> ToDtoCollection(IEnumerable<ControllerGroup> domainCollection)
│   │   │   │   90 │         {
│   │   │   │   91 │             if (domainCollection == null) return new List<ControllerGroupDto>();
│   │   │   │   92 │ 
│   │   │   │   93 │             var dtos = new List<ControllerGroupDto>();
│   │   │   │   94 │             foreach (var domain in domainCollection)
│   │   │   │   95 │             {
│   │   │   │   96 │                 var dto = ToDto(domain);
│   │   │   │   97 │                 if (dto != null)
│   │   │   │   98 │                 {
│   │   │   │   99 │                     dtos.Add(dto);
│   │   │   │  100 │                 }
│   │   │   │  101 │             }
│   │   │   │  102 │ 
│   │   │   │  103 │             return dtos;
│   │   │   │  104 │         }
│   │   │   │  105 │ 
│   │   │   │  106 │         /// <summary>
│   │   │   │  107 │         /// Maps a collection of DTOs to domain ControllerGroups
│   │   │   │  108 │         /// </summary>
│   │   │   │  109 │         /// <param name="dtoCollection">The DTO collection</param>
│   │   │   │  110 │         /// <returns>The domain collection</returns>
│   │   │   │  111 │         public static IEnumerable<ControllerGroup> ToDomainCollection(IEnumerable<ControllerGroupDto> dtoCollection)
│   │   │   │  112 │         {
│   │   │   │  113 │             if (dtoCollection == null) return new List<ControllerGroup>();
│   │   │   │  114 │ 
│   │   │   │  115 │             var domains = new List<ControllerGroup>();
│   │   │   │  116 │             foreach (var dto in dtoCollection)
│   │   │   │  117 │             {
│   │   │   │  118 │                 var domain = ToDomain(dto);
│   │   │   │  119 │                 if (domain != null)
│   │   │   │  120 │                 {
│   │   │   │  121 │                     domains.Add(domain);
│   │   │   │  122 │                 }
│   │   │   │  123 │             }
│   │   │   │  124 │ 
│   │   │   │  125 │             return domains;
│   │   │   │  126 │         }
│   │   │   │  127 │     }
│   │   │   │  128 │ }
│   │   │   └──────────────────────────────────────────────────────────────────────
│   │   ├── 📄 ControllerMapper.cs (5.37 KB, 2025-03-11 09:48:27)
│   │   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │   │ FILE CONTENT: ControllerMapper.cs
│   │   │   ├──────────────────────────────────────────────────────────────────────
│   │   │   │    1 │ ﻿using System;
│   │   │   │    2 │ using System.Collections.Generic;
│   │   │   │    3 │ using System.Linq;
│   │   │   │    4 │ using System.Text;
│   │   │   │    5 │ using System.Threading.Tasks;
│   │   │   │    6 │ using test.Core.Domain;
│   │   │   │    7 │ using test.Data.Entities;
│   │   │   │    8 │ using System;
│   │   │   │    9 │ using System.Collections.Generic;
│   │   │   │   10 │ using System.Linq;
│   │   │   │   11 │ 
│   │   │   │   12 │ namespace test.Data.Mapping
│   │   │   │   13 │ {
│   │   │   │   14 │     /// <summary>
│   │   │   │   15 │     /// Maps between Controller domain entities and database entities
│   │   │   │   16 │     /// </summary>
│   │   │   │   17 │     public static class ControllerMapper
│   │   │   │   18 │     {
│   │   │   │   19 │         /// <summary>
│   │   │   │   20 │         /// Maps a database controller entity to a domain controller
│   │   │   │   21 │         /// </summary>
│   │   │   │   22 │         /// <param name="entity">The database entity</param>
│   │   │   │   23 │         /// <returns>A domain controller</returns>
│   │   │   │   24 │         public static Controller ToDomain(ParsedController entity)
│   │   │   │   25 │         {
│   │   │   │   26 │             if (entity == null)
│   │   │   │   27 │                 return null;
│   │   │   │   28 │ 
│   │   │   │   29 │             var controller = new Controller(entity.Name, GetModelFromProperties(entity.Properties));
│   │   │   │   30 │ 
│   │   │   │   31 │             // Set connection info if available
│   │   │   │   32 │             controller.SetConnectionInfo(
│   │   │   │   33 │                 GetPropertyValue(entity.Properties, "Port"),
│   │   │   │   34 │                 GetPropertyValue(entity.Properties, "SerialNumber"),
│   │   │   │   35 │                 GetPropertyValue(entity.Properties, "InfinetId")
│   │   │   │   36 │             );
│   │   │   │   37 │ 
│   │   │   │   38 │             // Add all properties
│   │   │   │   39 │             foreach (var prop in entity.Properties)
│   │   │   │   40 │             {
│   │   │   │   41 │                 controller.SetProperty(prop.Key, prop.Value);
│   │   │   │   42 │             }
│   │   │   │   43 │ 
│   │   │   │   44 │             // Map all objects
│   │   │   │   45 │             if (entity.Objects != null)
│   │   │   │   46 │             {
│   │   │   │   47 │                 foreach (var obj in entity.Objects.Where(o => o.ParentObjectId == null))
│   │   │   │   48 │                 {
│   │   │   │   49 │                     var domainObj = ObjectMapper.ToDomain(obj);
│   │   │   │   50 │                     if (domainObj != null)
│   │   │   │   51 │                     {
│   │   │   │   52 │                         controller.AddObject(domainObj);
│   │   │   │   53 │                     }
│   │   │   │   54 │                 }
│   │   │   │   55 │             }
│   │   │   │   56 │ 
│   │   │   │   57 │             return controller;
│   │   │   │   58 │         }
│   │   │   │   59 │ 
│   │   │   │   60 │         /// <summary>
│   │   │   │   61 │         /// Maps a domain controller to a database entity
│   │   │   │   62 │         /// </summary>
│   │   │   │   63 │         /// <param name="domain">The domain controller</param>
│   │   │   │   64 │         /// <param name="sessionId">The session ID</param>
│   │   │   │   65 │         /// <returns>A database controller entity</returns>
│   │   │   │   66 │         public static ParsedController ToEntity(Controller domain, string sessionId)
│   │   │   │   67 │         {
│   │   │   │   68 │             if (domain == null)
│   │   │   │   69 │                 return null;
│   │   │   │   70 │ 
│   │   │   │   71 │             var entity = new ParsedController
│   │   │   │   72 │             {
│   │   │   │   73 │                 Name = domain.Name,
│   │   │   │   74 │                 SessionId = sessionId,
│   │   │   │   75 │                 Created = DateTime.UtcNow,
│   │   │   │   76 │                 Properties = new List<ControllerProperty>(),
│   │   │   │   77 │                 Objects = new List<ParsedObject>()
│   │   │   │   78 │             };
│   │   │   │   79 │ 
│   │   │   │   80 │             // Add all properties
│   │   │   │   81 │             foreach (var prop in domain.Properties)
│   │   │   │   82 │             {
│   │   │   │   83 │                 entity.Properties.Add(new ControllerProperty
│   │   │   │   84 │                 {
│   │   │   │   85 │                     Key = prop.Key,
│   │   │   │   86 │                     Value = prop.Value
│   │   │   │   87 │                 });
│   │   │   │   88 │             }
│   │   │   │   89 │ 
│   │   │   │   90 │             // Make sure model is included in properties
│   │   │   │   91 │             if (!string.IsNullOrEmpty(domain.Model) && !entity.Properties.Any(p => p.Key == "Model"))
│   │   │   │   92 │             {
│   │   │   │   93 │                 entity.Properties.Add(new ControllerProperty
│   │   │   │   94 │                 {
│   │   │   │   95 │                     Key = "Model",
│   │   │   │   96 │                     Value = domain.Model
│   │   │   │   97 │                 });
│   │   │   │   98 │             }
│   │   │   │   99 │ 
│   │   │   │  100 │             // Add connection properties if available
│   │   │   │  101 │             if (!string.IsNullOrEmpty(domain.Port) && !entity.Properties.Any(p => p.Key == "Port"))
│   │   │   │  102 │             {
│   │   │   │  103 │                 entity.Properties.Add(new ControllerProperty
│   │   │   │  104 │                 {
│   │   │   │  105 │                     Key = "Port",
│   │   │   │  106 │                     Value = domain.Port
│   │   │   │  107 │                 });
│   │   │   │  108 │             }
│   │   │   │  109 │ 
│   │   │   │  110 │             if (!string.IsNullOrEmpty(domain.SerialNumber) && !entity.Properties.Any(p => p.Key == "SerialNumber"))
│   │   │   │  111 │             {
│   │   │   │  112 │                 entity.Properties.Add(new ControllerProperty
│   │   │   │  113 │                 {
│   │   │   │  114 │                     Key = "SerialNumber",
│   │   │   │  115 │                     Value = domain.SerialNumber
│   │   │   │  116 │                 });
│   │   │   │  117 │             }
│   │   │   │  118 │ 
│   │   │   │  119 │             if (!string.IsNullOrEmpty(domain.InfinetId) && !entity.Properties.Any(p => p.Key == "InfinetId"))
│   │   │   │  120 │             {
│   │   │   │  121 │                 entity.Properties.Add(new ControllerProperty
│   │   │   │  122 │                 {
│   │   │   │  123 │                     Key = "InfinetId",
│   │   │   │  124 │                     Value = domain.InfinetId
│   │   │   │  125 │                 });
│   │   │   │  126 │             }
│   │   │   │  127 │ 
│   │   │   │  128 │             // Map all objects
│   │   │   │  129 │             foreach (var obj in domain.Objects)
│   │   │   │  130 │             {
│   │   │   │  131 │                 var objEntity = ObjectMapper.ToEntity(obj, sessionId);
│   │   │   │  132 │                 if (objEntity != null)
│   │   │   │  133 │                 {
│   │   │   │  134 │                     entity.Objects.Add(objEntity);
│   │   │   │  135 │                 }
│   │   │   │  136 │             }
│   │   │   │  137 │ 
│   │   │   │  138 │             return entity;
│   │   │   │  139 │         }
│   │   │   │  140 │ 
│   │   │   │  141 │         /// <summary>
│   │   │   │  142 │         /// Extracts the model from controller properties
│   │   │   │  143 │         /// </summary>
│   │   │   │  144 │         private static string GetModelFromProperties(IEnumerable<ControllerProperty> properties)
│   │   │   │  145 │         {
│   │   │   │  146 │             return GetPropertyValue(properties, "Model");
│   │   │   │  147 │         }
│   │   │   │  148 │ 
│   │   │   │  149 │         /// <summary>
│   │   │   │  150 │         /// Gets a property value from a list of properties
│   │   │   │  151 │         /// </summary>
│   │   │   │  152 │         private static string GetPropertyValue(IEnumerable<ControllerProperty> properties, string key)
│   │   │   │  153 │         {
│   │   │   │  154 │             if (properties == null)
│   │   │   │  155 │                 return string.Empty;
│   │   │   │  156 │ 
│   │   │   │  157 │             var prop = properties.FirstOrDefault(p => p.Key.Equals(key, StringComparison.OrdinalIgnoreCase));
│   │   │   │  158 │             return prop?.Value ?? string.Empty;
│   │   │   │  159 │         }
│   │   │   │  160 │     }
│   │   │   │  161 │ }
│   │   │   └──────────────────────────────────────────────────────────────────────
│   │   ├── 📄 ObjectMapper.cs (3.41 KB, 2025-03-11 09:48:27)
│   │   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │   │ FILE CONTENT: ObjectMapper.cs
│   │   │   ├──────────────────────────────────────────────────────────────────────
│   │   │   │    1 │ ﻿using System;
│   │   │   │    2 │ using System.Collections.Generic;
│   │   │   │    3 │ using System.Linq;
│   │   │   │    4 │ using System.Text;
│   │   │   │    5 │ using System.Threading.Tasks;
│   │   │   │    6 │ 
│   │   │   │    7 │ using test.Core.Domain;
│   │   │   │    8 │ using test.Data.Entities;
│   │   │   │    9 │ using System;
│   │   │   │   10 │ using System.Collections.Generic;
│   │   │   │   11 │ using System.Linq;
│   │   │   │   12 │ 
│   │   │   │   13 │ namespace test.Data.Mapping
│   │   │   │   14 │ {
│   │   │   │   15 │     /// <summary>
│   │   │   │   16 │     /// Maps between ControllerObject domain entities and database entities
│   │   │   │   17 │     /// </summary>
│   │   │   │   18 │     public static class ObjectMapper
│   │   │   │   19 │     {
│   │   │   │   20 │         /// <summary>
│   │   │   │   21 │         /// Maps a database object entity to a domain object
│   │   │   │   22 │         /// </summary>
│   │   │   │   23 │         /// <param name="entity">The database entity</param>
│   │   │   │   24 │         /// <returns>A domain controller object</returns>
│   │   │   │   25 │         public static ControllerObject ToDomain(ParsedObject entity)
│   │   │   │   26 │         {
│   │   │   │   27 │             if (entity == null)
│   │   │   │   28 │                 return null;
│   │   │   │   29 │ 
│   │   │   │   30 │             var obj = new ControllerObject(
│   │   │   │   31 │                 entity.Type ?? "Unknown",
│   │   │   │   32 │                 entity.Name,
│   │   │   │   33 │                 entity.Value
│   │   │   │   34 │             );
│   │   │   │   35 │ 
│   │   │   │   36 │             // Set alias if available
│   │   │   │   37 │             if (!string.IsNullOrEmpty(entity.Alias))
│   │   │   │   38 │             {
│   │   │   │   39 │                 obj.SetAlias(entity.Alias);
│   │   │   │   40 │             }
│   │   │   │   41 │ 
│   │   │   │   42 │             // Set has byte code flag
│   │   │   │   43 │             obj.SetHasByteCode(entity.HasByteCode);
│   │   │   │   44 │ 
│   │   │   │   45 │             // Add properties
│   │   │   │   46 │             if (entity.Properties != null)
│   │   │   │   47 │             {
│   │   │   │   48 │                 foreach (var prop in entity.Properties)
│   │   │   │   49 │                 {
│   │   │   │   50 │                     obj.SetProperty(prop.Key, prop.Value);
│   │   │   │   51 │                 }
│   │   │   │   52 │             }
│   │   │   │   53 │ 
│   │   │   │   54 │             // Add child objects
│   │   │   │   55 │             if (entity.Children != null)
│   │   │   │   56 │             {
│   │   │   │   57 │                 foreach (var child in entity.Children)
│   │   │   │   58 │                 {
│   │   │   │   59 │                     var childObj = ToDomain(child);
│   │   │   │   60 │                     if (childObj != null)
│   │   │   │   61 │                     {
│   │   │   │   62 │                         obj.AddChild(childObj);
│   │   │   │   63 │                     }
│   │   │   │   64 │                 }
│   │   │   │   65 │             }
│   │   │   │   66 │ 
│   │   │   │   67 │             return obj;
│   │   │   │   68 │         }
│   │   │   │   69 │ 
│   │   │   │   70 │         /// <summary>
│   │   │   │   71 │         /// Maps a domain controller object to a database entity
│   │   │   │   72 │         /// </summary>
│   │   │   │   73 │         /// <param name="domain">The domain controller object</param>
│   │   │   │   74 │         /// <param name="sessionId">The session ID</param>
│   │   │   │   75 │         /// <returns>A database object entity</returns>
│   │   │   │   76 │         public static ParsedObject ToEntity(ControllerObject domain, string sessionId)
│   │   │   │   77 │         {
│   │   │   │   78 │             if (domain == null)
│   │   │   │   79 │                 return null;
│   │   │   │   80 │ 
│   │   │   │   81 │             var entity = new ParsedObject
│   │   │   │   82 │             {
│   │   │   │   83 │                 Type = domain.Type,
│   │   │   │   84 │                 Name = domain.Name,
│   │   │   │   85 │                 Alias = domain.Alias,
│   │   │   │   86 │                 Value = domain.Value,
│   │   │   │   87 │                 HasByteCode = domain.HasByteCode,
│   │   │   │   88 │                 SessionId = sessionId,
│   │   │   │   89 │                 Properties = new List<ObjectProperty>(),
│   │   │   │   90 │                 Children = new List<ParsedObject>()
│   │   │   │   91 │             };
│   │   │   │   92 │ 
│   │   │   │   93 │             // Add properties
│   │   │   │   94 │             foreach (var prop in domain.Properties)
│   │   │   │   95 │             {
│   │   │   │   96 │                 entity.Properties.Add(new ObjectProperty
│   │   │   │   97 │                 {
│   │   │   │   98 │                     Key = prop.Key,
│   │   │   │   99 │                     Value = prop.Value
│   │   │   │  100 │                 });
│   │   │   │  101 │             }
│   │   │   │  102 │ 
│   │   │   │  103 │             // Add children
│   │   │   │  104 │             foreach (var child in domain.Children)
│   │   │   │  105 │             {
│   │   │   │  106 │                 var childEntity = ToEntity(child, sessionId);
│   │   │   │  107 │                 if (childEntity != null)
│   │   │   │  108 │                 {
│   │   │   │  109 │                     entity.Children.Add(childEntity);
│   │   │   │  110 │                 }
│   │   │   │  111 │             }
│   │   │   │  112 │ 
│   │   │   │  113 │             return entity;
│   │   │   │  114 │         }
│   │   │   │  115 │     }
│   │   │   │  116 │ }
│   │   │   └──────────────────────────────────────────────────────────────────────
│   │   ├── 📄 ParsedController.cs (1.15 KB, 2025-03-11 09:48:27)
│   │   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │   │ FILE CONTENT: ParsedController.cs
│   │   │   ├──────────────────────────────────────────────────────────────────────
│   │   │   │    1 │ ﻿using System;
│   │   │   │    2 │ using System.Collections.Generic;
│   │   │   │    3 │ using System.Linq;
│   │   │   │    4 │ using System.Text;
│   │   │   │    5 │ using System.Threading.Tasks;
│   │   │   │    6 │ using System;
│   │   │   │    7 │ using System.Collections.Generic;
│   │   │   │    8 │ using System.ComponentModel.DataAnnotations;
│   │   │   │    9 │ 
│   │   │   │   10 │ namespace test.Data.Entities
│   │   │   │   11 │ {
│   │   │   │   12 │     /// <summary>
│   │   │   │   13 │     /// Database entity for a parsed controller
│   │   │   │   14 │     /// </summary>
│   │   │   │   15 │     public class ParsedController
│   │   │   │   16 │     {
│   │   │   │   17 │         [Key]
│   │   │   │   18 │         public int Id { get; set; }
│   │   │   │   19 │ 
│   │   │   │   20 │         public string Name { get; set; }
│   │   │   │   21 │         public string SessionId { get; set; } // To group controllers from the same parse
│   │   │   │   22 │         public DateTime Created { get; set; }
│   │   │   │   23 │         public virtual List<ControllerProperty> Properties { get; set; } = new();
│   │   │   │   24 │         public virtual List<ParsedObject> Objects { get; set; } = new();
│   │   │   │   25 │     }
│   │   │   │   26 │ 
│   │   │   │   27 │     /// <summary>
│   │   │   │   28 │     /// Database entity for a controller property
│   │   │   │   29 │     /// </summary>
│   │   │   │   30 │     public class ControllerProperty
│   │   │   │   31 │     {
│   │   │   │   32 │         [Key]
│   │   │   │   33 │         public int Id { get; set; }
│   │   │   │   34 │ 
│   │   │   │   35 │         public int ControllerId { get; set; }
│   │   │   │   36 │         public string Key { get; set; }
│   │   │   │   37 │         public string Value { get; set; }
│   │   │   │   38 │         public virtual ParsedController Controller { get; set; }
│   │   │   │   39 │     }
│   │   │   │   40 │ }
│   │   │   └──────────────────────────────────────────────────────────────────────
│   │   ├── 📄 ParsedObject.cs (1.45 KB, 2025-03-11 09:48:27)
│   │   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │   │ FILE CONTENT: ParsedObject.cs
│   │   │   ├──────────────────────────────────────────────────────────────────────
│   │   │   │    1 │ ﻿using System;
│   │   │   │    2 │ using System.Collections.Generic;
│   │   │   │    3 │ using System.Linq;
│   │   │   │    4 │ using System.Text;
│   │   │   │    5 │ using System.Threading.Tasks;
│   │   │   │    6 │ using System;
│   │   │   │    7 │ using System.Collections.Generic;
│   │   │   │    8 │ using System.ComponentModel.DataAnnotations;
│   │   │   │    9 │ 
│   │   │   │   10 │ namespace test.Data.Entities
│   │   │   │   11 │ {
│   │   │   │   12 │     /// <summary>
│   │   │   │   13 │     /// Database entity for a parsed controller object
│   │   │   │   14 │     /// </summary>
│   │   │   │   15 │     public class ParsedObject
│   │   │   │   16 │     {
│   │   │   │   17 │         [Key]
│   │   │   │   18 │         public int Id { get; set; }
│   │   │   │   19 │ 
│   │   │   │   20 │         public int? ControllerId { get; set; }
│   │   │   │   21 │         public int? ParentObjectId { get; set; }
│   │   │   │   22 │         public string Type { get; set; }
│   │   │   │   23 │         public string Name { get; set; }
│   │   │   │   24 │         public string Alias { get; set; }
│   │   │   │   25 │         public string Value { get; set; } = string.Empty;
│   │   │   │   26 │         public bool HasByteCode { get; set; }
│   │   │   │   27 │         public string SessionId { get; set; }
│   │   │   │   28 │ 
│   │   │   │   29 │         public virtual ParsedController Controller { get; set; }
│   │   │   │   30 │         public virtual ParsedObject ParentObject { get; set; }
│   │   │   │   31 │         public virtual List<ParsedObject> Children { get; set; } = new();
│   │   │   │   32 │         public virtual List<ObjectProperty> Properties { get; set; } = new();
│   │   │   │   33 │     }
│   │   │   │   34 │ 
│   │   │   │   35 │     /// <summary>
│   │   │   │   36 │     /// Database entity for an object property
│   │   │   │   37 │     /// </summary>
│   │   │   │   38 │     public class ObjectProperty
│   │   │   │   39 │     {
│   │   │   │   40 │         [Key]
│   │   │   │   41 │         public int Id { get; set; }
│   │   │   │   42 │ 
│   │   │   │   43 │         public int ObjectId { get; set; }
│   │   │   │   44 │         public string Key { get; set; }
│   │   │   │   45 │         public string Value { get; set; }
│   │   │   │   46 │         public virtual ParsedObject Object { get; set; }
│   │   │   │   47 │     }
│   │   │   │   48 │ }
│   │   │   └──────────────────────────────────────────────────────────────────────
│   │   ├── 📄 ProjectMapper.cs (3.84 KB, 2025-03-11 09:48:27)
│   │   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │   │ FILE CONTENT: ProjectMapper.cs
│   │   │   ├──────────────────────────────────────────────────────────────────────
│   │   │   │    1 │ ﻿using System;
│   │   │   │    2 │ using System.Collections.Generic;
│   │   │   │    3 │ using System.Collections.ObjectModel;
│   │   │   │    4 │ using System.Linq;
│   │   │   │    5 │ using test.Core.Domain;
│   │   │   │    6 │ using test.ViewModels;
│   │   │   │    7 │ 
│   │   │   │    8 │ namespace test.Data.Mapping
│   │   │   │    9 │ {
│   │   │   │   10 │     /// <summary>
│   │   │   │   11 │     /// Maps between Project domain entities and view models
│   │   │   │   12 │     /// </summary>
│   │   │   │   13 │     public static class ProjectMapper
│   │   │   │   14 │     {
│   │   │   │   15 │         /// <summary>
│   │   │   │   16 │         /// Maps a domain Project to a ProjectViewModel
│   │   │   │   17 │         /// </summary>
│   │   │   │   18 │         /// <param name="domain">The domain project</param>
│   │   │   │   19 │         /// <returns>A ProjectViewModel</returns>
│   │   │   │   20 │         public static ProjectViewModel ToDtoViewModel(Project domain)
│   │   │   │   21 │         {
│   │   │   │   22 │             if (domain == null)
│   │   │   │   23 │                 return null;
│   │   │   │   24 │ 
│   │   │   │   25 │             var viewModel = new ProjectViewModel
│   │   │   │   26 │             {
│   │   │   │   27 │                 ProjectId = domain.Id,
│   │   │   │   28 │                 Name = domain.Name,
│   │   │   │   29 │                 Description = domain.Description,
│   │   │   │   30 │                 Created = domain.Created,
│   │   │   │   31 │                 LastModified = domain.LastModified,
│   │   │   │   32 │                 ImportedFiles = new ObservableCollection<ImportedFileViewModel>(domain.ImportedFiles.Select(ToImportedFileViewModel).ToList()),
│   │   │   │   33 │                 SharedTypes = new ObservableCollection<SharedTypeViewModel>(domain.SharedTypes.Select(ToSharedTypeViewModel).ToList()),
│   │   │   │   34 │                 CustomTypeFiles = new ObservableCollection<CustomTypeFileViewModel>(domain.CustomTypeFiles.Select(ToCustomTypeFileViewModel).ToList())
│   │   │   │   35 │             };
│   │   │   │   36 │ 
│   │   │   │   37 │             return viewModel;
│   │   │   │   38 │         }
│   │   │   │   39 │ 
│   │   │   │   40 │         /// <summary>
│   │   │   │   41 │         /// Maps a domain ImportedFile to an ImportedFileViewModel
│   │   │   │   42 │         /// </summary>
│   │   │   │   43 │         /// <param name="domain">The domain imported file</param>
│   │   │   │   44 │         /// <returns>An ImportedFileViewModel</returns>
│   │   │   │   45 │         public static ImportedFileViewModel ToImportedFileViewModel(ImportedFile domain)
│   │   │   │   46 │         {
│   │   │   │   47 │             if (domain == null)
│   │   │   │   48 │                 return null;
│   │   │   │   49 │ 
│   │   │   │   50 │             return new ImportedFileViewModel
│   │   │   │   51 │             {
│   │   │   │   52 │                 FileName = domain.FileName,
│   │   │   │   53 │                 FilePath = domain.FilePath,
│   │   │   │   54 │                 Status = domain.Status,
│   │   │   │   55 │                 ImportDate = domain.ImportDate,
│   │   │   │   56 │                 FileSize = domain.FileSize,
│   │   │   │   57 │                 FileType = domain.FileType
│   │   │   │   58 │             };
│   │   │   │   59 │         }
│   │   │   │   60 │ 
│   │   │   │   61 │         /// <summary>
│   │   │   │   62 │         /// Maps a domain SharedType to a SharedTypeViewModel
│   │   │   │   63 │         /// </summary>
│   │   │   │   64 │         /// <param name="domain">The domain shared type</param>
│   │   │   │   65 │         /// <returns>A SharedTypeViewModel</returns>
│   │   │   │   66 │         public static SharedTypeViewModel ToSharedTypeViewModel(SharedType domain)
│   │   │   │   67 │         {
│   │   │   │   68 │             if (domain == null)
│   │   │   │   69 │                 return null;
│   │   │   │   70 │ 
│   │   │   │   71 │             return new SharedTypeViewModel
│   │   │   │   72 │             {
│   │   │   │   73 │                 TypeName = domain.TypeName,
│   │   │   │   74 │                 FileName = domain.FileName,
│   │   │   │   75 │                 FilePath = domain.FilePath,
│   │   │   │   76 │                 Category = domain.Category,
│   │   │   │   77 │                 Description = domain.Description,
│   │   │   │   78 │                 ImportDate = domain.ImportDate,
│   │   │   │   79 │                 FileSize = domain.FileSize,
│   │   │   │   80 │                 UsageCount = domain.UsageCount,
│   │   │   │   81 │                 VariableCount = domain.VariableCount,
│   │   │   │   82 │                 DefaultTargetName = domain.DefaultTargetName
│   │   │   │   83 │             };
│   │   │   │   84 │         }
│   │   │   │   85 │ 
│   │   │   │   86 │         /// <summary>
│   │   │   │   87 │         /// Maps a domain CustomTypeFile to a CustomTypeFileViewModel
│   │   │   │   88 │         /// </summary>
│   │   │   │   89 │         /// <param name="domain">The domain custom type file</param>
│   │   │   │   90 │         /// <returns>A CustomTypeFileViewModel</returns>
│   │   │   │   91 │         public static CustomTypeFileViewModel ToCustomTypeFileViewModel(CustomTypeFile domain)
│   │   │   │   92 │         {
│   │   │   │   93 │             if (domain == null)
│   │   │   │   94 │                 return null;
│   │   │   │   95 │ 
│   │   │   │   96 │             return new CustomTypeFileViewModel
│   │   │   │   97 │             {
│   │   │   │   98 │                 FileName = domain.FileName,
│   │   │   │   99 │                 TypeCount = domain.TypeCount,
│   │   │   │  100 │                 LastModified = domain.LastModified,
│   │   │   │  101 │                 Description = domain.Description
│   │   │   │  102 │             };
│   │   │   │  103 │         }
│   │   │   │  104 │     }
│   │   │   │  105 │ }
│   │   │   └──────────────────────────────────────────────────────────────────────
│   │   ├── 📄 SessionMapper.cs (2.24 KB, 2025-03-11 09:48:27)
│   │   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │   │ FILE CONTENT: SessionMapper.cs
│   │   │   ├──────────────────────────────────────────────────────────────────────
│   │   │   │    1 │ ﻿using System;
│   │   │   │    2 │ using System.Collections.Generic;
│   │   │   │    3 │ using System.Linq;
│   │   │   │    4 │ using System.Text;
│   │   │   │    5 │ using System.Threading.Tasks;
│   │   │   │    6 │ using test.Core.Domain;
│   │   │   │    7 │ using System;
│   │   │   │    8 │ using System.Collections.Generic;
│   │   │   │    9 │ using System.Linq;
│   │   │   │   10 │ 
│   │   │   │   11 │ namespace test.Data.Mapping
│   │   │   │   12 │ {
│   │   │   │   13 │     /// <summary>
│   │   │   │   14 │     /// Maps between Session domain entities and SessionInfo DTOs
│   │   │   │   15 │     /// </summary>
│   │   │   │   16 │     public static class SessionMapper
│   │   │   │   17 │     {
│   │   │   │   18 │         /// <summary>
│   │   │   │   19 │         /// Maps SessionInfo DTO to a domain Session
│   │   │   │   20 │         /// </summary>
│   │   │   │   21 │         /// <param name="info">The session info</param>
│   │   │   │   22 │         /// <returns>A domain Session</returns>
│   │   │   │   23 │         public static Session ToDomain(SessionInfo info)
│   │   │   │   24 │         {
│   │   │   │   25 │             if (info == null)
│   │   │   │   26 │                 return null;
│   │   │   │   27 │ 
│   │   │   │   28 │             // Extract project ID from session ID if applicable
│   │   │   │   29 │             string projectId = null;
│   │   │   │   30 │             if (info.SessionId.StartsWith("project_"))
│   │   │   │   31 │             {
│   │   │   │   32 │                 var parts = info.SessionId.Split('_', 3);
│   │   │   │   33 │                 if (parts.Length >= 3)
│   │   │   │   34 │                 {
│   │   │   │   35 │                     projectId = parts[1];
│   │   │   │   36 │                 }
│   │   │   │   37 │             }
│   │   │   │   38 │             else
│   │   │   │   39 │             {
│   │   │   │   40 │                 projectId = info.ProjectId;
│   │   │   │   41 │             }
│   │   │   │   42 │ 
│   │   │   │   43 │             var session = new Session(
│   │   │   │   44 │                 info.SessionId,
│   │   │   │   45 │                 info.OriginalFilePath,
│   │   │   │   46 │                 projectId,
│   │   │   │   47 │                 info.ControllerCount,
│   │   │   │   48 │                 info.Created,
│   │   │   │   49 │                 new List<string>() // No controller names available in SessionInfo
│   │   │   │   50 │             );
│   │   │   │   51 │ 
│   │   │   │   52 │             return session;
│   │   │   │   53 │         }
│   │   │   │   54 │ 
│   │   │   │   55 │         /// <summary>
│   │   │   │   56 │         /// Maps a domain Session to SessionInfo DTO
│   │   │   │   57 │         /// </summary>
│   │   │   │   58 │         /// <param name="domain">The domain Session</param>
│   │   │   │   59 │         /// <returns>A SessionInfo DTO</returns>
│   │   │   │   60 │         public static SessionInfo ToInfo(Session domain)
│   │   │   │   61 │         {
│   │   │   │   62 │             if (domain == null)
│   │   │   │   63 │                 return null;
│   │   │   │   64 │ 
│   │   │   │   65 │             return new SessionInfo
│   │   │   │   66 │             {
│   │   │   │   67 │                 SessionId = domain.Id,
│   │   │   │   68 │                 FileName = domain.FileName,
│   │   │   │   69 │                 OriginalFilePath = domain.OriginalFilePath,
│   │   │   │   70 │                 ProjectId = domain.ProjectId,
│   │   │   │   71 │                 ControllerCount = domain.ControllerCount,
│   │   │   │   72 │                 Created = domain.Created
│   │   │   │   73 │             };
│   │   │   │   74 │         }
│   │   │   │   75 │     }
│   │   │   │   76 │ }
│   │   │   └──────────────────────────────────────────────────────────────────────
│   │   └── 📄 SimilarityResultMapper.cs (2.61 KB, 2025-03-11 13:31:27)
│   │       ┌──────────────────────────────────────────────────────────────────────
│   │       │ FILE CONTENT: SimilarityResultMapper.cs
│   │       ├──────────────────────────────────────────────────────────────────────
│   │       │    1 │ ﻿using System;
│   │       │    2 │ using System.Collections.Generic;
│   │       │    3 │ using test.Core.Domain;
│   │       │    4 │ using test.Core.Dto;
│   │       │    5 │ 
│   │       │    6 │ namespace test.Data.Mapping
│   │       │    7 │ {
│   │       │    8 │     /// <summary>
│   │       │    9 │     /// Mapping utilities for similarity results
│   │       │   10 │     /// </summary>
│   │       │   11 │     public static class SimilarityResultMapper
│   │       │   12 │     {
│   │       │   13 │         /// <summary>
│   │       │   14 │         /// Creates a SimilarityResultDto from a ControllerGroup and a similarity score
│   │       │   15 │         /// </summary>
│   │       │   16 │         /// <param name="group">The controller group</param>
│   │       │   17 │         /// <param name="similarityScore">The similarity score</param>
│   │       │   18 │         /// <returns>A similarity result DTO</returns>
│   │       │   19 │         public static SimilarityResultDto FromControllerGroup(ControllerGroup group, double similarityScore)
│   │       │   20 │         {
│   │       │   21 │             if (group == null) return null;
│   │       │   22 │ 
│   │       │   23 │             return new SimilarityResultDto
│   │       │   24 │             {
│   │       │   25 │                 GroupIdentifier = group.GroupIdentifier,
│   │       │   26 │                 SimilarityScore = similarityScore,
│   │       │   27 │                 ControllerNames = new List<string>(group.ControllerNames),
│   │       │   28 │                 OriginalValues = new Dictionary<string, string>(group.OriginalValues, StringComparer.OrdinalIgnoreCase),
│   │       │   29 │                 ProcessedValues = new Dictionary<string, string>(group.ProcessedValues, StringComparer.OrdinalIgnoreCase),
│   │       │   30 │                 NameMapping = new Dictionary<string, string>(group.NameMapping, StringComparer.OrdinalIgnoreCase)
│   │       │   31 │             };
│   │       │   32 │         }
│   │       │   33 │ 
│   │       │   34 │         /// <summary>
│   │       │   35 │         /// Maps a collection of ControllerGroups to SimilarityResultDtos
│   │       │   36 │         /// </summary>
│   │       │   37 │         /// <param name="groups">The controller groups</param>
│   │       │   38 │         /// <param name="similarityScores">Dictionary mapping group IDs to similarity scores</param>
│   │       │   39 │         /// <returns>Collection of similarity result DTOs</returns>
│   │       │   40 │         public static IEnumerable<SimilarityResultDto> FromControllerGroups(
│   │       │   41 │             IEnumerable<ControllerGroup> groups,
│   │       │   42 │             Dictionary<string, double> similarityScores)
│   │       │   43 │         {
│   │       │   44 │             if (groups == null) return new List<SimilarityResultDto>();
│   │       │   45 │ 
│   │       │   46 │             var results = new List<SimilarityResultDto>();
│   │       │   47 │             foreach (var group in groups)
│   │       │   48 │             {
│   │       │   49 │                 double score = 0;
│   │       │   50 │                 if (similarityScores != null && group != null &&
│   │       │   51 │                     similarityScores.TryGetValue(group.GroupIdentifier, out double groupScore))
│   │       │   52 │                 {
│   │       │   53 │                     score = groupScore;
│   │       │   54 │                 }
│   │       │   55 │ 
│   │       │   56 │                 var dto = FromControllerGroup(group, score);
│   │       │   57 │                 if (dto != null)
│   │       │   58 │                 {
│   │       │   59 │                     results.Add(dto);
│   │       │   60 │                 }
│   │       │   61 │             }
│   │       │   62 │ 
│   │       │   63 │             return results;
│   │       │   64 │         }
│   │       │   65 │     }
│   │       │   66 │ }
│   │       └──────────────────────────────────────────────────────────────────────
│   ├── 📄 ParserDbContext.cs (5.06 KB, 2025-03-11 09:48:27)
│   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │ FILE CONTENT: ParserDbContext.cs
│   │   ├──────────────────────────────────────────────────────────────────────
│   │   │    1 │ ﻿using Microsoft.EntityFrameworkCore;
│   │   │    2 │ using System;
│   │   │    3 │ using System.Collections.Generic;
│   │   │    4 │ using System.ComponentModel.DataAnnotations;
│   │   │    5 │ using System.IO;
│   │   │    6 │ 
│   │   │    7 │ namespace test.Data
│   │   │    8 │ {
│   │   │    9 │     public class ParsedController
│   │   │   10 │     {
│   │   │   11 │         [Key]
│   │   │   12 │         public int Id { get; set; }
│   │   │   13 │ 
│   │   │   14 │         public string Name { get; set; }
│   │   │   15 │         public string SessionId { get; set; } // To group controllers from the same parse
│   │   │   16 │         public DateTime Created { get; set; }
│   │   │   17 │         public virtual List<ControllerProperty> Properties { get; set; }
│   │   │   18 │         public virtual List<ParsedObject> Objects { get; set; }
│   │   │   19 │     }
│   │   │   20 │ 
│   │   │   21 │     public class ControllerProperty
│   │   │   22 │     {
│   │   │   23 │         [Key]
│   │   │   24 │         public int Id { get; set; }
│   │   │   25 │ 
│   │   │   26 │         public int ControllerId { get; set; }
│   │   │   27 │         public string Key { get; set; }
│   │   │   28 │         public string Value { get; set; }
│   │   │   29 │         public virtual ParsedController Controller { get; set; }
│   │   │   30 │     }
│   │   │   31 │ 
│   │   │   32 │     public class ParsedObject
│   │   │   33 │     {
│   │   │   34 │         [Key]
│   │   │   35 │         public int Id { get; set; }
│   │   │   36 │ 
│   │   │   37 │         public int? ControllerId { get; set; }
│   │   │   38 │         public int? ParentObjectId { get; set; }
│   │   │   39 │         public string Type { get; set; }
│   │   │   40 │         public string Name { get; set; }
│   │   │   41 │         public string Alias { get; set; }
│   │   │   42 │         public string Value { get; set; } = string.Empty; // Set default empty string
│   │   │   43 │         public bool HasByteCode { get; set; }
│   │   │   44 │         public string SessionId { get; set; }
│   │   │   45 │ 
│   │   │   46 │         public virtual ParsedController Controller { get; set; }
│   │   │   47 │         public virtual ParsedObject ParentObject { get; set; }
│   │   │   48 │         public virtual List<ParsedObject> Children { get; set; }
│   │   │   49 │         public virtual List<ObjectProperty> Properties { get; set; }
│   │   │   50 │     }
│   │   │   51 │ 
│   │   │   52 │     public class ObjectProperty
│   │   │   53 │     {
│   │   │   54 │         [Key]
│   │   │   55 │         public int Id { get; set; }
│   │   │   56 │ 
│   │   │   57 │         public int ObjectId { get; set; }
│   │   │   58 │         public string Key { get; set; }
│   │   │   59 │         public string Value { get; set; }
│   │   │   60 │         public virtual ParsedObject Object { get; set; }
│   │   │   61 │     }
│   │   │   62 │ 
│   │   │   63 │     public class ParserDbContext : DbContext
│   │   │   64 │     {
│   │   │   65 │         public DbSet<ParsedController> Controllers { get; set; }
│   │   │   66 │         public DbSet<ControllerProperty> ControllerProperties { get; set; }
│   │   │   67 │         public DbSet<ParsedObject> Objects { get; set; }
│   │   │   68 │         public DbSet<ObjectProperty> ObjectProperties { get; set; }
│   │   │   69 │ 
│   │   │   70 │         private string DbPath { get; }
│   │   │   71 │ 
│   │   │   72 │         public ParserDbContext()
│   │   │   73 │         {
│   │   │   74 │             var folder = Environment.SpecialFolder.LocalApplicationData;
│   │   │   75 │             var path = Environment.GetFolderPath(folder);
│   │   │   76 │             DbPath = Path.Join(path, "PaapeConversionKit", "parser.db");
│   │   │   77 │ 
│   │   │   78 │             Directory.CreateDirectory(Path.GetDirectoryName(DbPath));
│   │   │   79 │         }
│   │   │   80 │ 
│   │   │   81 │         protected override void OnConfiguring(DbContextOptionsBuilder options)
│   │   │   82 │         {
│   │   │   83 │             options.UseSqlite($"Data Source={DbPath}", sqliteOptions =>
│   │   │   84 │             {
│   │   │   85 │                 sqliteOptions.CommandTimeout(60); // Increase timeout to 60 seconds
│   │   │   86 │             });
│   │   │   87 │ 
│   │   │   88 │             // Enable detailed errors and sensitive data logging for development
│   │   │   89 │             options.EnableDetailedErrors()
│   │   │   90 │                    .EnableSensitiveDataLogging();
│   │   │   91 │         }
│   │   │   92 │ 
│   │   │   93 │         protected override void OnModelCreating(ModelBuilder modelBuilder)
│   │   │   94 │         {
│   │   │   95 │             // Configure Value column for ParsedObject
│   │   │   96 │             modelBuilder.Entity<ParsedObject>(entity =>
│   │   │   97 │             {
│   │   │   98 │                 entity.Property(e => e.Value)
│   │   │   99 │                       .HasColumnType("TEXT")
│   │   │  100 │                       .IsRequired(false);
│   │   │  101 │ 
│   │   │  102 │                 entity.Property(e => e.Name)
│   │   │  103 │                       .HasMaxLength(255)
│   │   │  104 │                       .IsRequired();
│   │   │  105 │ 
│   │   │  106 │                 entity.Property(e => e.Type)
│   │   │  107 │                       .HasMaxLength(100)
│   │   │  108 │                       .IsRequired();
│   │   │  109 │ 
│   │   │  110 │                 entity.Property(e => e.Alias)
│   │   │  111 │                       .HasMaxLength(255)
│   │   │  112 │                       .IsRequired(false);
│   │   │  113 │             });
│   │   │  114 │ 
│   │   │  115 │             // Add other configurations
│   │   │  116 │             modelBuilder.Entity<ParsedController>()
│   │   │  117 │                 .HasMany(c => c.Properties)
│   │   │  118 │                 .WithOne(p => p.Controller)
│   │   │  119 │                 .HasForeignKey(p => p.ControllerId)
│   │   │  120 │                 .OnDelete(DeleteBehavior.Cascade);
│   │   │  121 │ 
│   │   │  122 │             modelBuilder.Entity<ParsedController>()
│   │   │  123 │                 .HasMany(c => c.Objects)
│   │   │  124 │                 .WithOne(o => o.Controller)
│   │   │  125 │                 .HasForeignKey(o => o.ControllerId)
│   │   │  126 │                 .OnDelete(DeleteBehavior.Cascade);
│   │   │  127 │ 
│   │   │  128 │             modelBuilder.Entity<ParsedObject>()
│   │   │  129 │                 .HasMany(o => o.Children)
│   │   │  130 │                 .WithOne(o => o.ParentObject)
│   │   │  131 │                 .HasForeignKey(o => o.ParentObjectId)
│   │   │  132 │                 .OnDelete(DeleteBehavior.Cascade);
│   │   │  133 │ 
│   │   │  134 │             modelBuilder.Entity<ParsedObject>()
│   │   │  135 │                 .HasMany(o => o.Properties)
│   │   │  136 │                 .WithOne(p => p.Object)
│   │   │  137 │                 .HasForeignKey(p => p.ObjectId)
│   │   │  138 │                 .OnDelete(DeleteBehavior.Cascade);
│   │   │  139 │ 
│   │   │  140 │             // Add indexes
│   │   │  141 │             modelBuilder.Entity<ParsedController>()
│   │   │  142 │                 .HasIndex(c => c.SessionId);
│   │   │  143 │ 
│   │   │  144 │             modelBuilder.Entity<ParsedObject>()
│   │   │  145 │                 .HasIndex(o => o.SessionId);
│   │   │  146 │         }
│   │   │  147 │     }
│   │   │  148 │ }
│   │   └──────────────────────────────────────────────────────────────────────
│   └── 📄 SessionInfo.cs (1.89 KB, 2025-03-11 09:48:27)
│       ┌──────────────────────────────────────────────────────────────────────
│       │ FILE CONTENT: SessionInfo.cs
│       ├──────────────────────────────────────────────────────────────────────
│       │    1 │ ﻿using System;
│       │    2 │ using System.Collections.Generic;
│       │    3 │ using System.Linq;
│       │    4 │ using System.Text;
│       │    5 │ using System.Threading.Tasks;
│       │    6 │ using System;
│       │    7 │ using System.Collections.Generic;
│       │    8 │ 
│       │    9 │ namespace test.Data
│       │   10 │ {
│       │   11 │     /// <summary>
│       │   12 │     /// Data transfer object with session information
│       │   13 │     /// </summary>
│       │   14 │     public class SessionInfo
│       │   15 │     {
│       │   16 │         public string SessionId { get; set; } = string.Empty;
│       │   17 │         public string FileName { get; set; } // Original file name
│       │   18 │         public string OriginalFilePath { get; set; } = string.Empty; // Path to the original source file
│       │   19 │         public string ProjectId { get; set; } = string.Empty; // ID of the project this session belongs to, if any
│       │   20 │         public int ControllerCount { get; set; }
│       │   21 │         public DateTime Created { get; set; }
│       │   22 │ 
│       │   23 │         // Display properties for UI with fallbacks
│       │   24 │         public string DisplayName
│       │   25 │         {
│       │   26 │             get
│       │   27 │             {
│       │   28 │                 if (!string.IsNullOrEmpty(FileName))
│       │   29 │                     return FileName;
│       │   30 │ 
│       │   31 │                 // Use first part of session ID if no filename
│       │   32 │                 if (!string.IsNullOrEmpty(SessionId) && SessionId.Length >= 8)
│       │   33 │                     return $"Session {SessionId.Substring(0, 8)}";
│       │   34 │ 
│       │   35 │                 // Ultimate fallback
│       │   36 │                 return "Unknown Session";
│       │   37 │             }
│       │   38 │         }
│       │   39 │ 
│       │   40 │         public string DisplayInfo
│       │   41 │         {
│       │   42 │             get
│       │   43 │             {
│       │   44 │                 var parts = new List<string>();
│       │   45 │ 
│       │   46 │                 if (ControllerCount > 0)
│       │   47 │                     parts.Add($"{ControllerCount} controllers");
│       │   48 │ 
│       │   49 │                 if (Created != DateTime.MinValue)
│       │   50 │                     parts.Add($"{Created:MMM dd, yyyy HH:mm}");
│       │   51 │ 
│       │   52 │                 return parts.Count > 0 ? string.Join(" - ", parts) : "No details available";
│       │   53 │             }
│       │   54 │         }
│       │   55 │ 
│       │   56 │         public override string ToString()
│       │   57 │         {
│       │   58 │             return $"{DisplayName} - {DisplayInfo}";
│       │   59 │         }
│       │   60 │     }
│       │   61 │ }
│       └──────────────────────────────────────────────────────────────────────
│   📁 Infrastructure
│   │   📁 Data
│   │   ├── 📄 EfControllerRepository.cs (38.53 KB, 2025-03-11 15:38:22)
│   │   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │   │ FILE CONTENT: EfControllerRepository.cs
│   │   │   ├──────────────────────────────────────────────────────────────────────
│   │   │   │    1 │ ﻿using System;
│   │   │   │    2 │ using System.Collections.Generic;
│   │   │   │    3 │ using System.Linq;
│   │   │   │    4 │ using System.Threading.Tasks;
│   │   │   │    5 │ using Microsoft.Data.Sqlite;
│   │   │   │    6 │ using Microsoft.EntityFrameworkCore;
│   │   │   │    7 │ using Microsoft.Extensions.Logging;
│   │   │   │    8 │ using test.Core.Domain;
│   │   │   │    9 │ using test.Core.Exceptions;
│   │   │   │   10 │ using test.Core.Interfaces;
│   │   │   │   11 │ using test.Data;
│   │   │   │   12 │ using test.Data.Entities;
│   │   │   │   13 │ using test.Data.Mapping;
│   │   │   │   14 │ using test.Infrastructure.Processing;
│   │   │   │   15 │ using System.Diagnostics;
│   │   │   │   16 │ using System.IO;
│   │   │   │   17 │ using NUlid;
│   │   │   │   18 │ using System.Text;
│   │   │   │   19 │ using ObjectProperty = test.Data.ObjectProperty;
│   │   │   │   20 │ using ParsedObject = test.Data.ParsedObject;
│   │   │   │   21 │ 
│   │   │   │   22 │ namespace test.Infrastructure.Data
│   │   │   │   23 │ {
│   │   │   │   24 │     /// <summary>
│   │   │   │   25 │     /// Entity Framework Core implementation of IControllerRepository with enhanced ByteCode handling
│   │   │   │   26 │     /// </summary>
│   │   │   │   27 │     public class EfControllerRepository : IControllerRepository, IDisposable
│   │   │   │   28 │     {
│   │   │   │   29 │         private readonly ParserDbContext _context;
│   │   │   │   30 │         private readonly ILogger<EfControllerRepository> _logger;
│   │   │   │   31 │         private readonly ByteCodeProcessor _byteCodeProcessor;
│   │   │   │   32 │         private bool _disposed;
│   │   │   │   33 │ 
│   │   │   │   34 │         // Constants for batch operations
│   │   │   │   35 │         private const int BATCH_SIZE = 500;
│   │   │   │   36 │         private int _pendingObjects = 0;
│   │   │   │   37 │ 
│   │   │   │   38 │         // For debugging
│   │   │   │   39 │         private Stopwatch _timer = new Stopwatch();
│   │   │   │   40 │         private int _totalObjectsSaved = 0;
│   │   │   │   41 │         private int _batchCount = 0;
│   │   │   │   42 │         private int _controllerCount = 0;
│   │   │   │   43 │ 
│   │   │   │   44 │         /// <summary>
│   │   │   │   45 │         /// Creates a new instance of EfControllerRepository
│   │   │   │   46 │         /// </summary>
│   │   │   │   47 │         /// <param name="context">The database context</param>
│   │   │   │   48 │         /// <param name="logger">The logger</param>
│   │   │   │   49 │         /// <param name="byteCodeProcessor">The ByteCode processor</param>
│   │   │   │   50 │         public EfControllerRepository(
│   │   │   │   51 │             ParserDbContext context,
│   │   │   │   52 │             ILogger<EfControllerRepository> logger,
│   │   │   │   53 │             ByteCodeProcessor byteCodeProcessor)
│   │   │   │   54 │         {
│   │   │   │   55 │             _context = context ?? throw new ArgumentNullException(nameof(context));
│   │   │   │   56 │             _logger = logger ?? throw new ArgumentNullException(nameof(logger));
│   │   │   │   57 │             _byteCodeProcessor = byteCodeProcessor ?? throw new ArgumentNullException(nameof(byteCodeProcessor));
│   │   │   │   58 │         }
│   │   │   │   59 │ 
│   │   │   │   60 │         /// <inheritdoc/>
│   │   │   │   61 │         public async Task<IEnumerable<string>> GetAllSessionIdsAsync()
│   │   │   │   62 │         {
│   │   │   │   63 │             try
│   │   │   │   64 │             {
│   │   │   │   65 │                 return await _context.Controllers
│   │   │   │   66 │                     .AsNoTracking()
│   │   │   │   67 │                     .GroupBy(c => c.SessionId)
│   │   │   │   68 │                     .Select(g => new {
│   │   │   │   69 │                         SessionId = g.Key,
│   │   │   │   70 │                         Created = g.Min(c => c.Created) // Earliest created date
│   │   │   │   71 │                     })
│   │   │   │   72 │                     .OrderByDescending(s => s.Created) // Sort by creation date, newest first
│   │   │   │   73 │                     .Select(s => s.SessionId)
│   │   │   │   74 │                     .ToListAsync();
│   │   │   │   75 │             }
│   │   │   │   76 │             catch (Exception ex)
│   │   │   │   77 │             {
│   │   │   │   78 │                 _logger.LogError(ex, "Error getting session IDs");
│   │   │   │   79 │                 throw new DataAccessException("Failed to retrieve session IDs", "GetAllSessionIds", "Session", ex);
│   │   │   │   80 │             }
│   │   │   │   81 │         }
│   │   │   │   82 │ 
│   │   │   │   83 │         /// <inheritdoc/>
│   │   │   │   84 │         public async Task<IEnumerable<SessionInfo>> GetAllSessionsAsync()
│   │   │   │   85 │         {
│   │   │   │   86 │             try
│   │   │   │   87 │             {
│   │   │   │   88 │                 // First, we need to get all sessions with their creation dates
│   │   │   │   89 │                 var sessionData = await _context.Controllers
│   │   │   │   90 │                     .AsNoTracking()
│   │   │   │   91 │                     .GroupBy(c => c.SessionId)
│   │   │   │   92 │                     .Select(g => new {
│   │   │   │   93 │                         SessionId = g.Key,
│   │   │   │   94 │                         Created = g.Min(c => c.Created) // Use the earliest created date for the session
│   │   │   │   95 │                     })
│   │   │   │   96 │                     .OrderByDescending(s => s.Created) // Sort by creation date, newest first
│   │   │   │   97 │                     .ToListAsync();
│   │   │   │   98 │ 
│   │   │   │   99 │                 var result = new List<SessionInfo>();
│   │   │   │  100 │ 
│   │   │   │  101 │                 foreach (var session in sessionData)
│   │   │   │  102 │                 {
│   │   │   │  103 │                     // Get detailed session info
│   │   │   │  104 │                     var sessionInfo = await GetSessionInfoAsync(session.SessionId);
│   │   │   │  105 │                     result.Add(sessionInfo);
│   │   │   │  106 │                 }
│   │   │   │  107 │ 
│   │   │   │  108 │                 return result;
│   │   │   │  109 │             }
│   │   │   │  110 │             catch (Exception ex)
│   │   │   │  111 │             {
│   │   │   │  112 │                 _logger.LogError(ex, "Error getting sessions info");
│   │   │   │  113 │                 throw new DataAccessException("Failed to retrieve sessions info", "GetAllSessions", "Session", ex);
│   │   │   │  114 │             }
│   │   │   │  115 │         }
│   │   │   │  116 │ 
│   │   │   │  117 │         /// <inheritdoc/>
│   │   │   │  118 │         public async Task<bool> DeleteSessionAsync(string sessionId)
│   │   │   │  119 │         {
│   │   │   │  120 │             if (string.IsNullOrEmpty(sessionId))
│   │   │   │  121 │                 return false;
│   │   │   │  122 │ 
│   │   │   │  123 │             try
│   │   │   │  124 │             {
│   │   │   │  125 │                 _logger.LogInformation("Starting deletion of session {SessionId}", sessionId);
│   │   │   │  126 │ 
│   │   │   │  127 │                 // Start a transaction to ensure all related data is deleted properly
│   │   │   │  128 │                 using var transaction = await _context.Database.BeginTransactionAsync();
│   │   │   │  129 │ 
│   │   │   │  130 │                 try
│   │   │   │  131 │                 {
│   │   │   │  132 │                     // Get all controllers for this session
│   │   │   │  133 │                     var controllers = await _context.Controllers
│   │   │   │  134 │                         .Where(c => c.SessionId == sessionId)
│   │   │   │  135 │                         .ToListAsync();
│   │   │   │  136 │ 
│   │   │   │  137 │                     if (!controllers.Any())
│   │   │   │  138 │                     {
│   │   │   │  139 │                         _logger.LogWarning("No controllers found for session {SessionId}", sessionId);
│   │   │   │  140 │                         return false;
│   │   │   │  141 │                     }
│   │   │   │  142 │ 
│   │   │   │  143 │                     int controllerCount = controllers.Count;
│   │   │   │  144 │                     _logger.LogInformation("Found {ControllerCount} controllers to delete", controllerCount);
│   │   │   │  145 │ 
│   │   │   │  146 │                     // Remove all controllers - SQL cascade delete will handle related objects and properties
│   │   │   │  147 │                     _context.Controllers.RemoveRange(controllers);
│   │   │   │  148 │ 
│   │   │   │  149 │                     // Save changes to apply the deletions
│   │   │   │  150 │                     int rowsAffected = await _context.SaveChangesAsync();
│   │   │   │  151 │ 
│   │   │   │  152 │                     // Commit the transaction
│   │   │   │  153 │                     await transaction.CommitAsync();
│   │   │   │  154 │ 
│   │   │   │  155 │                     _logger.LogInformation("Successfully deleted session {SessionId} with {ControllerCount} controllers. Rows affected: {RowsAffected}",
│   │   │   │  156 │                         sessionId, controllerCount, rowsAffected);
│   │   │   │  157 │ 
│   │   │   │  158 │                     return true;
│   │   │   │  159 │                 }
│   │   │   │  160 │                 catch (Exception ex)
│   │   │   │  161 │                 {
│   │   │   │  162 │                     // If an error occurs, roll back the transaction
│   │   │   │  163 │                     await transaction.RollbackAsync();
│   │   │   │  164 │                     _logger.LogError(ex, "Error deleting session {SessionId}", sessionId);
│   │   │   │  165 │                     throw new DataAccessException($"Failed to delete session {sessionId}", "DeleteSession", "Session", ex);
│   │   │   │  166 │                 }
│   │   │   │  167 │             }
│   │   │   │  168 │             catch (Exception ex)
│   │   │   │  169 │             {
│   │   │   │  170 │                 _logger.LogError(ex, "Fatal error in DeleteSessionAsync for session {SessionId}", sessionId);
│   │   │   │  171 │                 throw new DataAccessException("Failed to delete session", "DeleteSession", "Session", ex);
│   │   │   │  172 │             }
│   │   │   │  173 │         }
│   │   │   │  174 │ 
│   │   │   │  175 │         /// <inheritdoc/>
│   │   │   │  176 │         public async Task<SessionInfo> GetSessionInfoAsync(string sessionId)
│   │   │   │  177 │         {
│   │   │   │  178 │             if (string.IsNullOrEmpty(sessionId))
│   │   │   │  179 │             {
│   │   │   │  180 │                 return new SessionInfo
│   │   │   │  181 │                 {
│   │   │   │  182 │                     SessionId = string.Empty,
│   │   │   │  183 │                     ControllerCount = 0,
│   │   │   │  184 │                     Created = DateTime.MinValue
│   │   │   │  185 │                 };
│   │   │   │  186 │             }
│   │   │   │  187 │ 
│   │   │   │  188 │             try
│   │   │   │  189 │             {
│   │   │   │  190 │                 // Try to get controller count
│   │   │   │  191 │                 int controllerCount = 0;
│   │   │   │  192 │                 try
│   │   │   │  193 │                 {
│   │   │   │  194 │                     controllerCount = await _context.Controllers
│   │   │   │  195 │                         .AsNoTracking()
│   │   │   │  196 │                         .Where(c => c.SessionId == sessionId)
│   │   │   │  197 │                         .CountAsync();
│   │   │   │  198 │                 }
│   │   │   │  199 │                 catch (Exception ex)
│   │   │   │  200 │                 {
│   │   │   │  201 │                     _logger.LogError(ex, "Error getting controller count for session {SessionId}", sessionId);
│   │   │   │  202 │                     // Continue with count = 0
│   │   │   │  203 │                 }
│   │   │   │  204 │ 
│   │   │   │  205 │                 // Try to get first controller for metadata
│   │   │   │  206 │                 test.Data.ParsedController firstController = null;
│   │   │   │  207 │                 DateTime createdDate = DateTime.MinValue;
│   │   │   │  208 │                 try
│   │   │   │  209 │                 {
│   │   │   │  210 │                     firstController = await _context.Controllers
│   │   │   │  211 │                         .AsNoTracking()
│   │   │   │  212 │                         .Include(c => c.Properties)
│   │   │   │  213 │                         .Where(c => c.SessionId == sessionId)
│   │   │   │  214 │                         .OrderBy(c => c.Id)
│   │   │   │  215 │                         .FirstOrDefaultAsync();
│   │   │   │  216 │ 
│   │   │   │  217 │                     createdDate = firstController?.Created ?? DateTime.MinValue;
│   │   │   │  218 │                 }
│   │   │   │  219 │                 catch (Exception ex)
│   │   │   │  220 │                 {
│   │   │   │  221 │                     _logger.LogError(ex, "Error getting controller for session {SessionId}", sessionId);
│   │   │   │  222 │                     // Continue with null controller
│   │   │   │  223 │                 }
│   │   │   │  224 │ 
│   │   │   │  225 │                 // Try to get file properties
│   │   │   │  226 │                 string fileName = null;
│   │   │   │  227 │                 string originalFilePath = null;
│   │   │   │  228 │                 string projectId = null;
│   │   │   │  229 │ 
│   │   │   │  230 │                 if (firstController != null)
│   │   │   │  231 │                 {
│   │   │   │  232 │                     try
│   │   │   │  233 │                     {
│   │   │   │  234 │                         var fileNameProperty = firstController.Properties
│   │   │   │  235 │                             .FirstOrDefault(p => p.Key == "OriginalFileName");
│   │   │   │  236 │ 
│   │   │   │  237 │                         fileName = fileNameProperty?.Value;
│   │   │   │  238 │ 
│   │   │   │  239 │                         var filePathProperty = firstController.Properties
│   │   │   │  240 │                             .FirstOrDefault(p => p.Key == "OriginalFilePath");
│   │   │   │  241 │ 
│   │   │   │  242 │                         originalFilePath = filePathProperty?.Value;
│   │   │   │  243 │ 
│   │   │   │  244 │                         // Extract project ID from sessionId if it has the format "project_PROJECTID_XXXX"
│   │   │   │  245 │                         if (sessionId.StartsWith("project_"))
│   │   │   │  246 │                         {
│   │   │   │  247 │                             var parts = sessionId.Split('_', 3);
│   │   │   │  248 │                             if (parts.Length >= 3)
│   │   │   │  249 │                             {
│   │   │   │  250 │                                 projectId = parts[1];
│   │   │   │  251 │                             }
│   │   │   │  252 │                         }
│   │   │   │  253 │                     }
│   │   │   │  254 │                     catch (Exception ex)
│   │   │   │  255 │                     {
│   │   │   │  256 │                         _logger.LogError(ex, "Error getting file properties for session {SessionId}", sessionId);
│   │   │   │  257 │                         // Continue with null properties
│   │   │   │  258 │                     }
│   │   │   │  259 │                 }
│   │   │   │  260 │ 
│   │   │   │  261 │                 return new SessionInfo
│   │   │   │  262 │                 {
│   │   │   │  263 │                     SessionId = sessionId,
│   │   │   │  264 │                     FileName = fileName,
│   │   │   │  265 │                     OriginalFilePath = originalFilePath,
│   │   │   │  266 │                     ProjectId = projectId,
│   │   │   │  267 │                     ControllerCount = controllerCount,
│   │   │   │  268 │                     Created = createdDate
│   │   │   │  269 │                 };
│   │   │   │  270 │             }
│   │   │   │  271 │             catch (Exception ex)
│   │   │   │  272 │             {
│   │   │   │  273 │                 _logger.LogError(ex, "Error getting session info for session {SessionId}", sessionId);
│   │   │   │  274 │                 throw new DataAccessException("Failed to get session info", "GetSessionInfo", "Session", ex);
│   │   │   │  275 │             }
│   │   │   │  276 │         }
│   │   │   │  277 │ 
│   │   │   │  278 │         /// <inheritdoc/>
│   │   │   │  279 │         public async Task<string> SaveControllerBatchAsync(IEnumerable<Controller> controllers, string fileName = null, string sessionPrefix = null)
│   │   │   │  280 │         {
│   │   │   │  281 │             if (controllers == null)
│   │   │   │  282 │                 throw new ArgumentNullException(nameof(controllers));
│   │   │   │  283 │ 
│   │   │   │  284 │             // Reset counters and start timer for debugging
│   │   │   │  285 │             _timer.Restart();
│   │   │   │  286 │             _pendingObjects = 0;
│   │   │   │  287 │             _totalObjectsSaved = 0;
│   │   │   │  288 │             _batchCount = 0;
│   │   │   │  289 │             _controllerCount = 0;
│   │   │   │  290 │ 
│   │   │   │  291 │             _logger.LogInformation("Starting SaveControllerBatch with {ControllerCount} controllers", controllers.Count());
│   │   │   │  292 │ 
│   │   │   │  293 │             // Generate session ID with optional prefix
│   │   │   │  294 │             var sessionId = sessionPrefix ?? string.Empty;
│   │   │   │  295 │             sessionId += NUlid.Ulid.NewUlid().ToString();
│   │   │   │  296 │ 
│   │   │   │  297 │             var timestamp = DateTime.UtcNow;
│   │   │   │  298 │ 
│   │   │   │  299 │             _logger.LogInformation("Using session ID: {SessionId}", sessionId);
│   │   │   │  300 │ 
│   │   │   │  301 │             try
│   │   │   │  302 │             {
│   │   │   │  303 │                 // Configure SQLite for better performance during bulk insert
│   │   │   │  304 │                 _logger.LogDebug("Configuring SQLite performance settings");
│   │   │   │  305 │                 try
│   │   │   │  306 │                 {
│   │   │   │  307 │                     await _context.Database.ExecuteSqlRawAsync("PRAGMA synchronous = OFF");
│   │   │   │  308 │                     await _context.Database.ExecuteSqlRawAsync("PRAGMA journal_mode = MEMORY");
│   │   │   │  309 │                     await _context.Database.ExecuteSqlRawAsync("PRAGMA temp_store = MEMORY");
│   │   │   │  310 │                     await _context.Database.ExecuteSqlRawAsync("PRAGMA cache_size = 10000");
│   │   │   │  311 │                     _logger.LogDebug("SQLite performance settings applied successfully");
│   │   │   │  312 │                 }
│   │   │   │  313 │                 catch (Exception ex)
│   │   │   │  314 │                 {
│   │   │   │  315 │                     _logger.LogWarning(ex, "Error applying SQLite settings");
│   │   │   │  316 │                     // Continue even if settings fail - they're optimizations, not requirements
│   │   │   │  317 │                 }
│   │   │   │  318 │ 
│   │   │   │  319 │                 _logger.LogDebug("Beginning database transaction");
│   │   │   │  320 │                 using var transaction = await _context.Database.BeginTransactionAsync();
│   │   │   │  321 │                 try
│   │   │   │  322 │                 {
│   │   │   │  323 │                     foreach (var controller in controllers)
│   │   │   │  324 │                     {
│   │   │   │  325 │                         _controllerCount++;
│   │   │   │  326 │                         _logger.LogDebug("Processing controller {ControllerNumber}/{TotalControllers}: {ControllerName} with {ObjectCount} objects",
│   │   │   │  327 │                             _controllerCount, controllers.Count(), controller.Name, controller.Objects.Count);
│   │   │   │  328 │ 
│   │   │   │  329 │                         try
│   │   │   │  330 │                         {
│   │   │   │  331 │                             // Map domain model to database entity
│   │   │   │  332 │                             var dbController = ControllerMapper.ToEntity(controller, sessionId);
│   │   │   │  333 │ 
│   │   │   │  334 │                             // Add original file path property if provided
│   │   │   │  335 │                             if (!string.IsNullOrEmpty(fileName))
│   │   │   │  336 │                             {
│   │   │   │  337 │                                 dbController.Properties.Add(new test.Data.ControllerProperty
│   │   │   │  338 │                                 {
│   │   │   │  339 │                                     Key = "OriginalFilePath",
│   │   │   │  340 │                                     Value = fileName
│   │   │   │  341 │                                 });
│   │   │   │  342 │ 
│   │   │   │  343 │                                 // Also extract and store just the filename
│   │   │   │  344 │                                 string justFileName = Path.GetFileName(fileName);
│   │   │   │  345 │                                 dbController.Properties.Add(new test.Data.ControllerProperty
│   │   │   │  346 │                                 {
│   │   │   │  347 │                                     Key = "OriginalFileName",
│   │   │   │  348 │                                     Value = justFileName
│   │   │   │  349 │                                 });
│   │   │   │  350 │                             }
│   │   │   │  351 │ 
│   │   │   │  352 │                             _logger.LogDebug("Adding controller '{ControllerName}' with {PropertyCount} properties",
│   │   │   │  353 │                                 controller.Name, dbController.Properties.Count);
│   │   │   │  354 │                             _context.Controllers.Add(dbController);
│   │   │   │  355 │                             _pendingObjects++;
│   │   │   │  356 │ 
│   │   │   │  357 │                             // Save changes in batches
│   │   │   │  358 │                             if (_pendingObjects >= BATCH_SIZE)
│   │   │   │  359 │                             {
│   │   │   │  360 │                                 await SaveBatchAsync("controller batch");
│   │   │   │  361 │                             }
│   │   │   │  362 │ 
│   │   │   │  363 │                             // Save the controller to get its ID before saving children
│   │   │   │  364 │                             if (_pendingObjects > 0)
│   │   │   │  365 │                             {
│   │   │   │  366 │                                 _logger.LogDebug("Saving controller to get its ID");
│   │   │   │  367 │                                 await _context.SaveChangesAsync();
│   │   │   │  368 │                                 _totalObjectsSaved += _pendingObjects;
│   │   │   │  369 │                                 _pendingObjects = 0;
│   │   │   │  370 │                             }
│   │   │   │  371 │ 
│   │   │   │  372 │                             // Process all objects for this controller
│   │   │   │  373 │                             await SaveControllerObjectsAsync(controller.Objects, dbController.Id, null, sessionId);
│   │   │   │  374 │                         }
│   │   │   │  375 │                         catch (Exception ex)
│   │   │   │  376 │                         {
│   │   │   │  377 │                             _logger.LogError(ex, "Error processing controller {ControllerName}", controller.Name);
│   │   │   │  378 │                             throw;
│   │   │   │  379 │                         }
│   │   │   │  380 │                     }
│   │   │   │  381 │ 
│   │   │   │  382 │                     // Save any remaining changes
│   │   │   │  383 │                     if (_pendingObjects > 0)
│   │   │   │  384 │                     {
│   │   │   │  385 │                         _logger.LogDebug("Saving final batch of {PendingObjectCount} objects", _pendingObjects);
│   │   │   │  386 │                         await _context.SaveChangesAsync();
│   │   │   │  387 │                         _totalObjectsSaved += _pendingObjects;
│   │   │   │  388 │                         _pendingObjects = 0;
│   │   │   │  389 │                         _logger.LogDebug("Final batch saved. Total objects saved: {TotalObjectsSaved}", _totalObjectsSaved);
│   │   │   │  390 │                     }
│   │   │   │  391 │ 
│   │   │   │  392 │                     _logger.LogDebug("Committing transaction");
│   │   │   │  393 │                     await transaction.CommitAsync();
│   │   │   │  394 │                     _logger.LogInformation("Transaction committed successfully");
│   │   │   │  395 │ 
│   │   │   │  396 │                     // Reset SQLite configurations to normal
│   │   │   │  397 │                     try
│   │   │   │  398 │                     {
│   │   │   │  399 │                         _logger.LogDebug("Resetting SQLite configurations");
│   │   │   │  400 │                         await _context.Database.ExecuteSqlRawAsync("PRAGMA synchronous = NORMAL");
│   │   │   │  401 │                         await _context.Database.ExecuteSqlRawAsync("PRAGMA journal_mode = DELETE");
│   │   │   │  402 │                         await _context.Database.ExecuteSqlRawAsync("PRAGMA temp_store = DEFAULT");
│   │   │   │  403 │                         _logger.LogDebug("SQLite configurations reset successfully");
│   │   │   │  404 │                     }
│   │   │   │  405 │                     catch (Exception ex)
│   │   │   │  406 │                     {
│   │   │   │  407 │                         _logger.LogWarning(ex, "Error resetting SQLite configurations");
│   │   │   │  408 │                         // Continue even if reset fails
│   │   │   │  409 │                     }
│   │   │   │  410 │ 
│   │   │   │  411 │                     _timer.Stop();
│   │   │   │  412 │                     _logger.LogInformation("SaveControllerBatch completed in {ElapsedMilliseconds}ms. Total objects saved: {TotalObjectsSaved}",
│   │   │   │  413 │                         _timer.ElapsedMilliseconds, _totalObjectsSaved);
│   │   │   │  414 │ 
│   │   │   │  415 │                     return sessionId;
│   │   │   │  416 │                 }
│   │   │   │  417 │                 catch (Exception ex)
│   │   │   │  418 │                 {
│   │   │   │  419 │                     _logger.LogError(ex, "Error during save operation");
│   │   │   │  420 │ 
│   │   │   │  421 │                     try
│   │   │   │  422 │                     {
│   │   │   │  423 │                         _logger.LogDebug("Rolling back transaction");
│   │   │   │  424 │                         await transaction.RollbackAsync();
│   │   │   │  425 │                         _logger.LogDebug("Transaction rolled back");
│   │   │   │  426 │                     }
│   │   │   │  427 │                     catch (Exception rollbackEx)
│   │   │   │  428 │                     {
│   │   │   │  429 │                         _logger.LogError(rollbackEx, "Error rolling back transaction");
│   │   │   │  430 │                     }
│   │   │   │  431 │ 
│   │   │   │  432 │                     throw new DataAccessException("Failed to save controllers", "SaveControllerBatch", "Controller", ex);
│   │   │   │  433 │                 }
│   │   │   │  434 │             }
│   │   │   │  435 │             catch (Exception ex)
│   │   │   │  436 │             {
│   │   │   │  437 │                 _logger.LogError(ex, "Fatal error in SaveControllerBatch");
│   │   │   │  438 │                 throw new DataAccessException("Failed to save controllers", "SaveControllerBatch", "Controller", ex);
│   │   │   │  439 │             }
│   │   │   │  440 │             finally
│   │   │   │  441 │             {
│   │   │   │  442 │                 _logger.LogDebug("Cleaning up resources");
│   │   │   │  443 │                 GC.Collect();
│   │   │   │  444 │                 GC.WaitForPendingFinalizers();
│   │   │   │  445 │                 _logger.LogDebug("Resources cleaned up");
│   │   │   │  446 │             }
│   │   │   │  447 │         }
│   │   │   │  448 │         /// <summary>
│   │   │   │  449 │         /// Saves controller objects recursively
│   │   │   │  450 │         /// </summary>
│   │   │   │  451 │         private async Task SaveControllerObjectsAsync(IEnumerable<ControllerObject> objects, int controllerId, int? parentId, string sessionId)
│   │   │   │  452 │         {
│   │   │   │  453 │             if (objects == null || !objects.Any())
│   │   │   │  454 │                 return;
│   │   │   │  455 │ 
│   │   │   │  456 │             foreach (var obj in objects)
│   │   │   │  457 │             {
│   │   │   │  458 │                 await SaveObjectAsync(obj, controllerId, parentId, sessionId);
│   │   │   │  459 │             }
│   │   │   │  460 │         }
│   │   │   │  461 │ 
│   │   │   │  462 │         /// <summary>
│   │   │   │  463 │         /// Saves a single controller object
│   │   │   │  464 │         /// </summary>
│   │   │   │  465 │         private async Task SaveObjectAsync(ControllerObject obj, int controllerId, int? parentId, string sessionId)
│   │   │   │  466 │         {
│   │   │   │  467 │             try
│   │   │   │  468 │             {
│   │   │   │  469 │                 if (string.IsNullOrEmpty(obj.Name))
│   │   │   │  470 │                 {
│   │   │   │  471 │                     _logger.LogWarning("Object name cannot be null or empty, Type: {ObjectType}, ParentId: {ParentId}",
│   │   │   │  472 │                         obj.Type, parentId);
│   │   │   │  473 │                     throw new ArgumentException("Object name cannot be empty", nameof(obj));
│   │   │   │  474 │                 }
│   │   │   │  475 │ 
│   │   │   │  476 │                 // Check if value is too large and log details
│   │   │   │  477 │                 if (obj.Value != null && obj.Value.Length > 10000)
│   │   │   │  478 │                 {
│   │   │   │  479 │                     _logger.LogDebug("Large value detected: Object {ObjectName}, Type: {ObjectType}, Size: {ValueSize} chars",
│   │   │   │  480 │                         obj.Name, obj.Type, obj.Value.Length);
│   │   │   │  481 │                 }
│   │   │   │  482 │ 
│   │   │   │  483 │                 // Process ByteCode specially
│   │   │   │  484 │                 string processedValue;
│   │   │   │  485 │                 if (obj.HasByteCode)
│   │   │   │  486 │                 {
│   │   │   │  487 │                     // Process ByteCode using the specialized processor
│   │   │   │  488 │                     processedValue = _byteCodeProcessor.ProcessByteCode(obj.Value ?? string.Empty);
│   │   │   │  489 │                 }
│   │   │   │  490 │                 else
│   │   │   │  491 │                 {
│   │   │   │  492 │                     processedValue = obj.Value ?? string.Empty;
│   │   │   │  493 │                 }
│   │   │   │  494 │ 
│   │   │   │  495 │                 var dbObject = new ParsedObject
│   │   │   │  496 │                 {
│   │   │   │  497 │                     ControllerId = controllerId,
│   │   │   │  498 │                     ParentObjectId = parentId,
│   │   │   │  499 │                     Type = obj.Type,
│   │   │   │  500 │                     Name = obj.Name,
│   │   │   │  501 │                     Alias = obj.Alias,
│   │   │   │  502 │                     Value = processedValue,
│   │   │   │  503 │                     HasByteCode = obj.HasByteCode,
│   │   │   │  504 │                     SessionId = sessionId,
│   │   │   │  505 │                     Properties = obj.Properties
│   │   │   │  506 │     .Select(p => new test.Data.ObjectProperty
│   │   │   │  507 │     {
│   │   │   │  508 │         Key = p.Key ?? string.Empty,
│   │   │   │  509 │         Value = p.Value ?? string.Empty
│   │   │   │  510 │     })
│   │   │   │  511 │     .ToList()
│   │   │   │  512 │                 };
│   │   │   │  513 │ 
│   │   │   │  514 │                 _context.Objects.Add(dbObject);
│   │   │   │  515 │                 _pendingObjects++;
│   │   │   │  516 │ 
│   │   │   │  517 │                 // Save changes in batches
│   │   │   │  518 │                 if (_pendingObjects >= BATCH_SIZE)
│   │   │   │  519 │                 {
│   │   │   │  520 │                     await SaveBatchAsync("object batch");
│   │   │   │  521 │                 }
│   │   │   │  522 │ 
│   │   │   │  523 │                 // We need to save the object to get its ID before adding children
│   │   │   │  524 │                 if (obj.Children != null && obj.Children.Count > 0)
│   │   │   │  525 │                 {
│   │   │   │  526 │                     // Save this object to get its ID
│   │   │   │  527 │                     await _context.SaveChangesAsync();
│   │   │   │  528 │                     _totalObjectsSaved += _pendingObjects;
│   │   │   │  529 │                     _pendingObjects = 0;
│   │   │   │  530 │ 
│   │   │   │  531 │                     int objectId = dbObject.Id;
│   │   │   │  532 │                     int childCount = obj.Children.Count;
│   │   │   │  533 │ 
│   │   │   │  534 │                     if (childCount > 10)
│   │   │   │  535 │                     {
│   │   │   │  536 │                         _logger.LogDebug("Processing {ChildCount} children for object {ObjectName}, Type: {ObjectType}",
│   │   │   │  537 │                             childCount, obj.Name, obj.Type);
│   │   │   │  538 │                     }
│   │   │   │  539 │ 
│   │   │   │  540 │                     // Save all children
│   │   │   │  541 │                     await SaveControllerObjectsAsync(obj.Children, controllerId, objectId, sessionId);
│   │   │   │  542 │                 }
│   │   │   │  543 │             }
│   │   │   │  544 │             catch (Exception ex)
│   │   │   │  545 │             {
│   │   │   │  546 │                 _logger.LogError(ex, "Error saving object {ObjectName}, Type: {ObjectType}", obj.Name, obj.Type);
│   │   │   │  547 │                 throw;
│   │   │   │  548 │             }
│   │   │   │  549 │         }
│   │   │   │  550 │         /// <summary>
│   │   │   │  551 │         /// Saves a batch of changes with error handling
│   │   │   │  552 │         /// </summary>
│   │   │   │  553 │         private async Task SaveBatchAsync(string batchType)
│   │   │   │  554 │         {
│   │   │   │  555 │             _batchCount++;
│   │   │   │  556 │             _logger.LogDebug("Saving {BatchType} {BatchNumber} with {PendingObjectCount} objects",
│   │   │   │  557 │                 batchType, _batchCount, _pendingObjects);
│   │   │   │  558 │             try
│   │   │   │  559 │             {
│   │   │   │  560 │                 await _context.SaveChangesAsync();
│   │   │   │  561 │                 _totalObjectsSaved += _pendingObjects;
│   │   │   │  562 │                 _logger.LogDebug("Batch {BatchNumber} saved successfully. Total objects saved: {TotalObjectsSaved}",
│   │   │   │  563 │                     _batchCount, _totalObjectsSaved);
│   │   │   │  564 │                 _pendingObjects = 0;
│   │   │   │  565 │             }
│   │   │   │  566 │             catch (DbUpdateException dbEx)
│   │   │   │  567 │             {
│   │   │   │  568 │                 var innerEx = dbEx.InnerException;
│   │   │   │  569 │                 _logger.LogError(dbEx, "Database update error saving batch {BatchNumber}", _batchCount);
│   │   │   │  570 │ 
│   │   │   │  571 │                 if (innerEx is SqliteException sqlEx)
│   │   │   │  572 │                 {
│   │   │   │  573 │                     // Log detailed information for specific SQLite errors
│   │   │   │  574 │                     _logger.LogError("SQLite error code: {SqliteErrorCode}, SQLState: {SqlState}",
│   │   │   │  575 │                         sqlEx.SqliteErrorCode, sqlEx.SqlState);
│   │   │   │  576 │ 
│   │   │   │  577 │                     switch (sqlEx.SqliteErrorCode)
│   │   │   │  578 │                     {
│   │   │   │  579 │                         case 5: // SQLITE_BUSY
│   │   │   │  580 │                             _logger.LogError("Database is locked. Another process might be using it.");
│   │   │   │  581 │                             break;
│   │   │   │  582 │                         case 8: // SQLITE_READONLY
│   │   │   │  583 │                             _logger.LogError("Database is read-only.");
│   │   │   │  584 │                             break;
│   │   │   │  585 │                         case 13: // SQLITE_FULL
│   │   │   │  586 │                             _logger.LogError("Database or disk is full.");
│   │   │   │  587 │                             break;
│   │   │   │  588 │                         case 19: // SQLITE_CONSTRAINT
│   │   │   │  589 │                             _logger.LogError("Constraint violation.");
│   │   │   │  590 │                             break;
│   │   │   │  591 │                         case 1299: // SQLITE_IOERR_SHORT_READ (might vary)
│   │   │   │  592 │                             _logger.LogError("Disk I/O error, short read.");
│   │   │   │  593 │                             break;
│   │   │   │  594 │                     }
│   │   │   │  595 │                 }
│   │   │   │  596 │ 
│   │   │   │  597 │                 throw new DataAccessException("Database update error", "SaveBatch", "ParsedObject", dbEx);
│   │   │   │  598 │             }
│   │   │   │  599 │         }
│   │   │   │  600 │         /// <inheritdoc/>
│   │   │   │  601 │         public async Task<IEnumerable<string>> GetSessionIdsByPrefixAsync(string prefix)
│   │   │   │  602 │         {
│   │   │   │  603 │             try
│   │   │   │  604 │             {
│   │   │   │  605 │                 return await _context.Controllers
│   │   │   │  606 │                     .AsNoTracking()
│   │   │   │  607 │                     .Select(c => c.SessionId)
│   │   │   │  608 │                     .Where(s => s.StartsWith(prefix))
│   │   │   │  609 │                     .Distinct()
│   │   │   │  610 │                     .OrderByDescending(s => s)
│   │   │   │  611 │                     .ToListAsync();
│   │   │   │  612 │             }
│   │   │   │  613 │             catch (Exception ex)
│   │   │   │  614 │             {
│   │   │   │  615 │                 _logger.LogError(ex, "Error getting session IDs by prefix {Prefix}", prefix);
│   │   │   │  616 │                 throw new DataAccessException("Failed to get session IDs by prefix", "GetSessionIdsByPrefix", "Session", ex);
│   │   │   │  617 │             }
│   │   │   │  618 │         }
│   │   │   │  619 │ 
│   │   │   │  620 │         /// <inheritdoc/>
│   │   │   │  621 │         public async Task<IEnumerable<Controller>> GetControllersBySessionAsync(string sessionId, int skip = 0, int take = 50)
│   │   │   │  622 │         {
│   │   │   │  623 │             if (string.IsNullOrEmpty(sessionId))
│   │   │   │  624 │                 return Enumerable.Empty<Controller>();
│   │   │   │  625 │ 
│   │   │   │  626 │             try
│   │   │   │  627 │             {
│   │   │   │  628 │                 using var transaction = await _context.Database.BeginTransactionAsync(System.Data.IsolationLevel.ReadUncommitted);
│   │   │   │  629 │                 try
│   │   │   │  630 │                 {
│   │   │   │  631 │                     var dbControllers = await _context.Controllers
│   │   │   │  632 │                         .AsNoTracking()
│   │   │   │  633 │                         .Include(c => c.Properties)
│   │   │   │  634 │                         .Where(c => c.SessionId == sessionId)
│   │   │   │  635 │                         .Skip(skip)
│   │   │   │  636 │                         .Take(take)
│   │   │   │  637 │                         .ToListAsync();
│   │   │   │  638 │ 
│   │   │   │  639 │                     var controllers = new List<Controller>();
│   │   │   │  640 │ 
│   │   │   │  641 │                     foreach (var dbController in dbControllers)
│   │   │   │  642 │                     {
│   │   │   │  643 │                         // Load all objects for this controller (including children)
│   │   │   │  644 │                         await LoadControllerObjects(dbController);
│   │   │   │  645 │ 
│   │   │   │  646 │                         // Map to domain model
│   │   │   │  647 │                         var controller = ControllerMapper.ToDomain(dbController);
│   │   │   │  648 │                         if (controller != null)
│   │   │   │  649 │                         {
│   │   │   │  650 │                             controllers.Add(controller);
│   │   │   │  651 │                         }
│   │   │   │  652 │                     }
│   │   │   │  653 │ 
│   │   │   │  654 │                     await transaction.CommitAsync();
│   │   │   │  655 │                     return controllers;
│   │   │   │  656 │                 }
│   │   │   │  657 │                 catch (Exception ex)
│   │   │   │  658 │                 {
│   │   │   │  659 │                     await transaction.RollbackAsync();
│   │   │   │  660 │                     _logger.LogError(ex, "Error loading controllers for session {SessionId}", sessionId);
│   │   │   │  661 │                     throw new DataAccessException("Failed to load controllers", "GetControllersBySession", "Controller", ex);
│   │   │   │  662 │                 }
│   │   │   │  663 │             }
│   │   │   │  664 │             catch (Exception ex)
│   │   │   │  665 │             {
│   │   │   │  666 │                 _logger.LogError(ex, "Fatal error in GetControllersBySession for session {SessionId}", sessionId);
│   │   │   │  667 │                 throw new DataAccessException("Failed to load controllers", "GetControllersBySession", "Controller", ex);
│   │   │   │  668 │             }
│   │   │   │  669 │         }
│   │   │   │  670 │ 
│   │   │   │  671 │         /// <summary>
│   │   │   │  672 │         /// Loads all objects for a controller (including children)
│   │   │   │  673 │         /// </summary>
│   │   │   │  674 │         private async Task LoadControllerObjects(test.Data.ParsedController controller)
│   │   │   │  675 │         {
│   │   │   │  676 │             try
│   │   │   │  677 │             {
│   │   │   │  678 │                 // Load all top-level objects for this controller (parent ID is null)
│   │   │   │  679 │                 var topLevelObjects = await _context.Objects
│   │   │   │  680 │                     .AsNoTracking()
│   │   │   │  681 │                     .Include(o => o.Properties)
│   │   │   │  682 │                     .Where(o => o.ControllerId == controller.Id && o.ParentObjectId == null)
│   │   │   │  683 │                     .ToListAsync();
│   │   │   │  684 │ 
│   │   │   │  685 │                 controller.Objects = topLevelObjects;
│   │   │   │  686 │ 
│   │   │   │  687 │                 // Load all children recursively
│   │   │   │  688 │                 foreach (var obj in topLevelObjects)
│   │   │   │  689 │                 {
│   │   │   │  690 │                     await LoadObjectChildren(obj);
│   │   │   │  691 │                 }
│   │   │   │  692 │             }
│   │   │   │  693 │             catch (Exception ex)
│   │   │   │  694 │             {
│   │   │   │  695 │                 _logger.LogError(ex, "Error loading objects for controller {ControllerId}", controller.Id);
│   │   │   │  696 │                 throw;
│   │   │   │  697 │             }
│   │   │   │  698 │         }
│   │   │   │  699 │ 
│   │   │   │  700 │         /// <summary>
│   │   │   │  701 │         /// Loads all children of an object recursively
│   │   │   │  702 │         /// </summary>
│   │   │   │  703 │         private async Task LoadObjectChildren(test.Data.ParsedObject obj)
│   │   │   │  704 │         {
│   │   │   │  705 │             try
│   │   │   │  706 │             {
│   │   │   │  707 │                 var children = await _context.Objects
│   │   │   │  708 │                     .AsNoTracking()
│   │   │   │  709 │                     .Include(o => o.Properties)
│   │   │   │  710 │                     .Where(o => o.ParentObjectId == obj.Id)
│   │   │   │  711 │                     .ToListAsync();
│   │   │   │  712 │ 
│   │   │   │  713 │                 obj.Children = children;
│   │   │   │  714 │ 
│   │   │   │  715 │                 foreach (var child in children)
│   │   │   │  716 │                 {
│   │   │   │  717 │                     await LoadObjectChildren(child);
│   │   │   │  718 │                 }
│   │   │   │  719 │             }
│   │   │   │  720 │             catch (Exception ex)
│   │   │   │  721 │             {
│   │   │   │  722 │                 _logger.LogError(ex, "Error loading children for object {ObjectId}", obj.Id);
│   │   │   │  723 │                 throw;
│   │   │   │  724 │             }
│   │   │   │  725 │         }
│   │   │   │  726 │ 
│   │   │   │  727 │         /// <inheritdoc/>
│   │   │   │  728 │         public async Task<int> CleanupOldSessionsAsync(TimeSpan maxAge)
│   │   │   │  729 │         {
│   │   │   │  730 │             var cutoff = DateTime.UtcNow - maxAge;
│   │   │   │  731 │             int removedCount = 0;
│   │   │   │  732 │ 
│   │   │   │  733 │             try
│   │   │   │  734 │             {
│   │   │   │  735 │                 _logger.LogInformation("Cleaning up sessions older than {Cutoff}", cutoff);
│   │   │   │  736 │ 
│   │   │   │  737 │                 var oldSessions = await _context.Controllers
│   │   │   │  738 │                     .AsNoTracking()
│   │   │   │  739 │                     .Where(c => c.Created < cutoff)
│   │   │   │  740 │                     .Select(c => c.SessionId)
│   │   │   │  741 │                     .Distinct()
│   │   │   │  742 │                     .ToListAsync();
│   │   │   │  743 │ 
│   │   │   │  744 │                 _logger.LogInformation("Found {SessionCount} sessions to clean up", oldSessions.Count);
│   │   │   │  745 │ 
│   │   │   │  746 │                 foreach (var sessionId in oldSessions)
│   │   │   │  747 │                 {
│   │   │   │  748 │                     bool success = await DeleteSessionAsync(sessionId);
│   │   │   │  749 │                     if (success)
│   │   │   │  750 │                     {
│   │   │   │  751 │                         removedCount++;
│   │   │   │  752 │                     }
│   │   │   │  753 │                 }
│   │   │   │  754 │ 
│   │   │   │  755 │                 _logger.LogInformation("Successfully removed {RemovedCount} old sessions", removedCount);
│   │   │   │  756 │ 
│   │   │   │  757 │                 // Force cleanup after large deletion
│   │   │   │  758 │                 GC.Collect();
│   │   │   │  759 │                 GC.WaitForPendingFinalizers();
│   │   │   │  760 │ 
│   │   │   │  761 │                 return removedCount;
│   │   │   │  762 │             }
│   │   │   │  763 │             catch (Exception ex)
│   │   │   │  764 │             {
│   │   │   │  765 │                 _logger.LogError(ex, "Error cleaning up old sessions");
│   │   │   │  766 │                 throw new DataAccessException("Failed to clean up old sessions", "CleanupOldSessions", "Session", ex);
│   │   │   │  767 │             }
│   │   │   │  768 │         }
│   │   │   │  769 │ 
│   │   │   │  770 │         /// <inheritdoc/>
│   │   │   │  771 │         public async Task OptimizeDatabaseAsync()
│   │   │   │  772 │         {
│   │   │   │  773 │             try
│   │   │   │  774 │             {
│   │   │   │  775 │                 _logger.LogInformation("Starting database optimization");
│   │   │   │  776 │ 
│   │   │   │  777 │                 // Run VACUUM to reclaim space and defragment the database
│   │   │   │  778 │                 _logger.LogDebug("Running VACUUM...");
│   │   │   │  779 │                 _timer.Restart();
│   │   │   │  780 │                 await _context.Database.ExecuteSqlRawAsync("VACUUM");
│   │   │   │  781 │                 _timer.Stop();
│   │   │   │  782 │                 _logger.LogDebug("VACUUM completed in {ElapsedMilliseconds}ms", _timer.ElapsedMilliseconds);
│   │   │   │  783 │ 
│   │   │   │  784 │                 // Run ANALYZE to update statistics
│   │   │   │  785 │                 _logger.LogDebug("Running ANALYZE...");
│   │   │   │  786 │                 _timer.Restart();
│   │   │   │  787 │                 await _context.Database.ExecuteSqlRawAsync("ANALYZE");
│   │   │   │  788 │                 _timer.Stop();
│   │   │   │  789 │                 _logger.LogDebug("ANALYZE completed in {ElapsedMilliseconds}ms", _timer.ElapsedMilliseconds);
│   │   │   │  790 │ 
│   │   │   │  791 │                 // Update indexed stats
│   │   │   │  792 │                 _logger.LogDebug("Running PRAGMA optimize...");
│   │   │   │  793 │                 _timer.Restart();
│   │   │   │  794 │                 await _context.Database.ExecuteSqlRawAsync("PRAGMA optimize");
│   │   │   │  795 │                 _timer.Stop();
│   │   │   │  796 │                 _logger.LogDebug("PRAGMA optimize completed in {ElapsedMilliseconds}ms", _timer.ElapsedMilliseconds);
│   │   │   │  797 │ 
│   │   │   │  798 │                 // Check index usage
│   │   │   │  799 │                 _logger.LogDebug("Checking index usage...");
│   │   │   │  800 │                 try
│   │   │   │  801 │                 {
│   │   │   │  802 │                     await _context.Database.ExecuteSqlRawAsync("PRAGMA index_list('Objects')");
│   │   │   │  803 │                     await _context.Database.ExecuteSqlRawAsync("PRAGMA index_list('Controllers')");
│   │   │   │  804 │                     _logger.LogDebug("Index check completed");
│   │   │   │  805 │                 }
│   │   │   │  806 │                 catch (Exception ex)
│   │   │   │  807 │                 {
│   │   │   │  808 │                     _logger.LogWarning(ex, "Error checking indexes");
│   │   │   │  809 │                 }
│   │   │   │  810 │ 
│   │   │   │  811 │                 _logger.LogInformation("Database optimization completed");
│   │   │   │  812 │             }
│   │   │   │  813 │             catch (Exception ex)
│   │   │   │  814 │             {
│   │   │   │  815 │                 _logger.LogError(ex, "Error optimizing database");
│   │   │   │  816 │                 // Fix: Pass Exception instead of string
│   │   │   │  817 │                 throw new DataAccessException("Failed to optimize database", "OptimizeDatabase", null, ex);
│   │   │   │  818 │             }
│   │   │   │  819 │         }
│   │   │   │  820 │ 
│   │   │   │  821 │         /// <inheritdoc/>
│   │   │   │  822 │         public async Task<string> GetDatabaseHealthReportAsync()
│   │   │   │  823 │         {
│   │   │   │  824 │             var report = new StringBuilder();
│   │   │   │  825 │             report.AppendLine("DATABASE HEALTH REPORT");
│   │   │   │  826 │             report.AppendLine("=====================");
│   │   │   │  827 │ 
│   │   │   │  828 │             try
│   │   │   │  829 │             {
│   │   │   │  830 │                 // Get database file path and size
│   │   │   │  831 │                 var dbPath = _context.Database.GetDbConnection().DataSource;
│   │   │   │  832 │                 report.AppendLine($"Database path: {dbPath}");
│   │   │   │  833 │ 
│   │   │   │  834 │                 if (File.Exists(dbPath))
│   │   │   │  835 │                 {
│   │   │   │  836 │                     var fileInfo = new FileInfo(dbPath);
│   │   │   │  837 │                     report.AppendLine($"Database size: {fileInfo.Length / 1024 / 1024} MB");
│   │   │   │  838 │                     report.AppendLine($"Created: {fileInfo.CreationTime}");
│   │   │   │  839 │                     report.AppendLine($"Last modified: {fileInfo.LastWriteTime}");
│   │   │   │  840 │                 }
│   │   │   │  841 │                 else
│   │   │   │  842 │                 {
│   │   │   │  843 │                     report.AppendLine("Database file not found!");
│   │   │   │  844 │                 }
│   │   │   │  845 │ 
│   │   │   │  846 │                 // Count tables
│   │   │   │  847 │                 var controllerCount = await _context.Controllers.CountAsync();
│   │   │   │  848 │                 var objectCount = await _context.Objects.CountAsync();
│   │   │   │  849 │ 
│   │   │   │  850 │                 report.AppendLine($"Controller count: {controllerCount}");
│   │   │   │  851 │                 report.AppendLine($"Object count: {objectCount}");
│   │   │   │  852 │ 
│   │   │   │  853 │                 // Get session count
│   │   │   │  854 │                 var sessionCount = await _context.Controllers
│   │   │   │  855 │                     .Select(c => c.SessionId)
│   │   │   │  856 │                     .Distinct()
│   │   │   │  857 │                     .CountAsync();
│   │   │   │  858 │ 
│   │   │   │  859 │                 report.AppendLine($"Session count: {sessionCount}");
│   │   │   │  860 │ 
│   │   │   │  861 │                 // Check for integrity errors
│   │   │   │  862 │                 try
│   │   │   │  863 │                 {
│   │   │   │  864 │                     report.AppendLine("Running integrity check...");
│   │   │   │  865 │                     await _context.Database.ExecuteSqlRawAsync("PRAGMA integrity_check");
│   │   │   │  866 │                     report.AppendLine("Integrity check passed");
│   │   │   │  867 │                 }
│   │   │   │  868 │                 catch (Exception ex)
│   │   │   │  869 │                 {
│   │   │   │  870 │                     report.AppendLine($"Integrity check failed: {ex.Message}");
│   │   │   │  871 │                 }
│   │   │   │  872 │ 
│   │   │   │  873 │                 report.AppendLine("=====================");
│   │   │   │  874 │ 
│   │   │   │  875 │                 return report.ToString();
│   │   │   │  876 │             }
│   │   │   │  877 │             catch (Exception ex)
│   │   │   │  878 │             {
│   │   │   │  879 │                 report.AppendLine($"Error generating health report: {ex.Message}");
│   │   │   │  880 │                 if (ex.InnerException != null)
│   │   │   │  881 │                 {
│   │   │   │  882 │                     report.AppendLine($"Inner exception: {ex.InnerException.Message}");
│   │   │   │  883 │                 }
│   │   │   │  884 │                 report.AppendLine("=====================");
│   │   │   │  885 │ 
│   │   │   │  886 │                 _logger.LogError(ex, "Error generating database health report");
│   │   │   │  887 │                 return report.ToString();
│   │   │   │  888 │             }
│   │   │   │  889 │         }
│   │   │   │  890 │ 
│   │   │   │  891 │         /// <inheritdoc/>
│   │   │   │  892 │         public async Task<IEnumerable<SessionInfo>> GetSessionsByProjectAsync(string projectId)
│   │   │   │  893 │         {
│   │   │   │  894 │             if (string.IsNullOrEmpty(projectId))
│   │   │   │  895 │                 return Enumerable.Empty<SessionInfo>();
│   │   │   │  896 │ 
│   │   │   │  897 │             try
│   │   │   │  898 │             {
│   │   │   │  899 │                 string prefix = $"project_{projectId}_";
│   │   │   │  900 │                 var sessionIds = await GetSessionIdsByPrefixAsync(prefix);
│   │   │   │  901 │ 
│   │   │   │  902 │                 var result = new List<SessionInfo>();
│   │   │   │  903 │                 foreach (var sessionId in sessionIds)
│   │   │   │  904 │                 {
│   │   │   │  905 │                     var sessionInfo = await GetSessionInfoAsync(sessionId);
│   │   │   │  906 │                     if (sessionInfo != null)
│   │   │   │  907 │                     {
│   │   │   │  908 │                         result.Add(sessionInfo);
│   │   │   │  909 │                     }
│   │   │   │  910 │                 }
│   │   │   │  911 │ 
│   │   │   │  912 │                 return result;
│   │   │   │  913 │             }
│   │   │   │  914 │             catch (Exception ex)
│   │   │   │  915 │             {
│   │   │   │  916 │                 _logger.LogError(ex, "Error getting sessions for project {ProjectId}", projectId);
│   │   │   │  917 │                 throw new DataAccessException("Failed to get sessions by project", "GetSessionsByProject", "Session", ex);
│   │   │   │  918 │             }
│   │   │   │  919 │         }
│   │   │   │  920 │ 
│   │   │   │  921 │         /// <summary>
│   │   │   │  922 │         /// Disposes the repository
│   │   │   │  923 │         /// </summary>
│   │   │   │  924 │         public void Dispose()
│   │   │   │  925 │         {
│   │   │   │  926 │             Dispose(true);
│   │   │   │  927 │             GC.SuppressFinalize(this);
│   │   │   │  928 │         }
│   │   │   │  929 │ 
│   │   │   │  930 │         /// <summary>
│   │   │   │  931 │         /// Disposes the repository
│   │   │   │  932 │         /// </summary>
│   │   │   │  933 │         /// <param name="disposing">True if disposing, false if finalizing</param>
│   │   │   │  934 │         protected virtual void Dispose(bool disposing)
│   │   │   │  935 │         {
│   │   │   │  936 │             if (!_disposed)
│   │   │   │  937 │             {
│   │   │   │  938 │                 if (disposing)
│   │   │   │  939 │                 {
│   │   │   │  940 │                     _context.Dispose();
│   │   │   │  941 │                 }
│   │   │   │  942 │                 _disposed = true;
│   │   │   │  943 │             }
│   │   │   │  944 │         }
│   │   │   │  945 │     }
│   │   │   │  946 │ }
│   │   │   └──────────────────────────────────────────────────────────────────────
│   │   └── 📄 FileProjectRepository.cs (28.94 KB, 2025-03-11 09:48:27)
│   │       ┌──────────────────────────────────────────────────────────────────────
│   │       │ FILE CONTENT: FileProjectRepository.cs
│   │       ├──────────────────────────────────────────────────────────────────────
│   │       │    1 │ ﻿using Microsoft.Extensions.Logging;
│   │       │    2 │ using System;
│   │       │    3 │ using System.Collections.Generic;
│   │       │    4 │ using System.IO;
│   │       │    5 │ using System.Linq;
│   │       │    6 │ using System.Text.Json;
│   │       │    7 │ using System.Threading.Tasks;
│   │       │    8 │ using test.Core.Domain;
│   │       │    9 │ using test.Core.Exceptions;
│   │       │   10 │ using test.Core.Interfaces;
│   │       │   11 │ 
│   │       │   12 │ 
│   │       │   13 │ 
│   │       │   14 │ namespace test.Infrastructure.Data
│   │       │   15 │ {
│   │       │   16 │     /// <summary>
│   │       │   17 │     /// File-based implementation of IProjectRepository
│   │       │   18 │     /// Projects are stored as JSON files in a directory structure
│   │       │   19 │     /// </summary>
│   │       │   20 │     public class FileProjectRepository : IProjectRepository
│   │       │   21 │     {
│   │       │   22 │         private readonly IFileSystem _fileSystem;
│   │       │   23 │         private readonly ILogger<FileProjectRepository> _logger;
│   │       │   24 │         private readonly string _baseProjectsDirectory;
│   │       │   25 │ 
│   │       │   26 │         private const string ProjectMetadataFileName = "project.json";
│   │       │   27 │ 
│   │       │   28 │         /// <summary>
│   │       │   29 │         /// Creates a new project repository
│   │       │   30 │         /// </summary>
│   │       │   31 │         /// <param name="fileSystem">The file system abstraction</param>
│   │       │   32 │         /// <param name="logger">The logger</param>
│   │       │   33 │         public FileProjectRepository(IFileSystem fileSystem, ILogger<FileProjectRepository> logger)
│   │       │   34 │         {
│   │       │   35 │             _fileSystem = fileSystem ?? throw new ArgumentNullException(nameof(fileSystem));
│   │       │   36 │             _logger = logger ?? throw new ArgumentNullException(nameof(logger));
│   │       │   37 │ 
│   │       │   38 │             // Projects are stored in the application data directory
│   │       │   39 │             _baseProjectsDirectory = Path.Combine(
│   │       │   40 │                 Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
│   │       │   41 │                 "PaapeConversionKit",
│   │       │   42 │                 "Projects"
│   │       │   43 │             );
│   │       │   44 │ 
│   │       │   45 │             // Ensure the directory exists
│   │       │   46 │             _fileSystem.CreateDirectory(_baseProjectsDirectory);
│   │       │   47 │         }
│   │       │   48 │ 
│   │       │   49 │         /// <inheritdoc/>
│   │       │   50 │         public async Task<IEnumerable<Project>> GetAllAsync()
│   │       │   51 │         {
│   │       │   52 │             try
│   │       │   53 │             {
│   │       │   54 │                 var projects = new List<Project>();
│   │       │   55 │                 var projectDirectories = Directory.GetDirectories(_baseProjectsDirectory);
│   │       │   56 │ 
│   │       │   57 │                 foreach (var directory in projectDirectories)
│   │       │   58 │                 {
│   │       │   59 │                     var project = await LoadProjectFromDirectoryAsync(directory);
│   │       │   60 │                     if (project != null)
│   │       │   61 │                     {
│   │       │   62 │                         projects.Add(project);
│   │       │   63 │                     }
│   │       │   64 │                 }
│   │       │   65 │ 
│   │       │   66 │                 return projects;
│   │       │   67 │             }
│   │       │   68 │             catch (Exception ex)
│   │       │   69 │             {
│   │       │   70 │                 _logger.LogError(ex, "Error retrieving all projects");
│   │       │   71 │                 throw new DataAccessException("Failed to retrieve all projects", "GetAll", "Project", ex);
│   │       │   72 │             }
│   │       │   73 │         }
│   │       │   74 │ 
│   │       │   75 │         /// <inheritdoc/>
│   │       │   76 │         public async Task<Project> GetByIdAsync(string id)
│   │       │   77 │         {
│   │       │   78 │             if (string.IsNullOrEmpty(id))
│   │       │   79 │                 throw new ArgumentException("Project ID cannot be empty", nameof(id));
│   │       │   80 │ 
│   │       │   81 │             try
│   │       │   82 │             {
│   │       │   83 │                 var projectDirectory = Path.Combine(_baseProjectsDirectory, id);
│   │       │   84 │                 if (!_fileSystem.DirectoryExists(projectDirectory))
│   │       │   85 │                 {
│   │       │   86 │                     throw new NotFoundException("Project", id);
│   │       │   87 │                 }
│   │       │   88 │ 
│   │       │   89 │                 return await LoadProjectFromDirectoryAsync(projectDirectory);
│   │       │   90 │             }
│   │       │   91 │             catch (NotFoundException)
│   │       │   92 │             {
│   │       │   93 │                 throw; // Let NotFoundException pass through
│   │       │   94 │             }
│   │       │   95 │             catch (Exception ex)
│   │       │   96 │             {
│   │       │   97 │                 _logger.LogError(ex, "Error retrieving project with ID {ProjectId}", id);
│   │       │   98 │                 throw new DataAccessException($"Failed to retrieve project with ID {id}", "GetById", "Project", ex);
│   │       │   99 │             }
│   │       │  100 │         }
│   │       │  101 │ 
│   │       │  102 │         /// <inheritdoc/>
│   │       │  103 │         public async Task CreateAsync(Project project)
│   │       │  104 │         {
│   │       │  105 │             if (project == null)
│   │       │  106 │                 throw new ArgumentNullException(nameof(project));
│   │       │  107 │ 
│   │       │  108 │             try
│   │       │  109 │             {
│   │       │  110 │                 var projectDirectory = Path.Combine(_baseProjectsDirectory, project.Id);
│   │       │  111 │ 
│   │       │  112 │                 // Create project directory
│   │       │  113 │                 _fileSystem.CreateDirectory(projectDirectory);
│   │       │  114 │ 
│   │       │  115 │                 // Create subdirectories
│   │       │  116 │                 _fileSystem.CreateDirectory(Path.Combine(projectDirectory, "Files"));
│   │       │  117 │                 _fileSystem.CreateDirectory(Path.Combine(projectDirectory, "SharedTypes"));
│   │       │  118 │                 _fileSystem.CreateDirectory(Path.Combine(projectDirectory, "CustomTypes"));
│   │       │  119 │ 
│   │       │  120 │                 // Save project metadata
│   │       │  121 │                 await SaveProjectMetadataAsync(projectDirectory, project);
│   │       │  122 │ 
│   │       │  123 │                 _logger.LogInformation("Project created successfully with ID {ProjectId}", project.Id);
│   │       │  124 │             }
│   │       │  125 │             catch (Exception ex)
│   │       │  126 │             {
│   │       │  127 │                 _logger.LogError(ex, "Error creating project with ID {ProjectId}", project.Id);
│   │       │  128 │                 throw new DataAccessException($"Failed to create project with ID {project.Id}", "Create", "Project", ex);
│   │       │  129 │             }
│   │       │  130 │         }
│   │       │  131 │ 
│   │       │  132 │         /// <inheritdoc/>
│   │       │  133 │         public async Task UpdateAsync(Project project)
│   │       │  134 │         {
│   │       │  135 │             if (project == null)
│   │       │  136 │                 throw new ArgumentNullException(nameof(project));
│   │       │  137 │ 
│   │       │  138 │             try
│   │       │  139 │             {
│   │       │  140 │                 var projectDirectory = Path.Combine(_baseProjectsDirectory, project.Id);
│   │       │  141 │                 if (!_fileSystem.DirectoryExists(projectDirectory))
│   │       │  142 │                 {
│   │       │  143 │                     throw new NotFoundException("Project", project.Id);
│   │       │  144 │                 }
│   │       │  145 │ 
│   │       │  146 │                 // Save updated project metadata
│   │       │  147 │                 await SaveProjectMetadataAsync(projectDirectory, project);
│   │       │  148 │ 
│   │       │  149 │                 _logger.LogInformation("Project updated successfully with ID {ProjectId}", project.Id);
│   │       │  150 │             }
│   │       │  151 │             catch (NotFoundException)
│   │       │  152 │             {
│   │       │  153 │                 throw; // Let NotFoundException pass through
│   │       │  154 │             }
│   │       │  155 │             catch (Exception ex)
│   │       │  156 │             {
│   │       │  157 │                 _logger.LogError(ex, "Error updating project with ID {ProjectId}", project.Id);
│   │       │  158 │                 throw new DataAccessException($"Failed to update project with ID {project.Id}", "Update", "Project", ex);
│   │       │  159 │             }
│   │       │  160 │         }
│   │       │  161 │ 
│   │       │  162 │         /// <inheritdoc/>
│   │       │  163 │         public async Task<bool> DeleteAsync(string id)
│   │       │  164 │         {
│   │       │  165 │             if (string.IsNullOrEmpty(id))
│   │       │  166 │                 throw new ArgumentException("Project ID cannot be empty", nameof(id));
│   │       │  167 │ 
│   │       │  168 │             try
│   │       │  169 │             {
│   │       │  170 │                 var projectDirectory = Path.Combine(_baseProjectsDirectory, id);
│   │       │  171 │                 if (!_fileSystem.DirectoryExists(projectDirectory))
│   │       │  172 │                 {
│   │       │  173 │                     return false;
│   │       │  174 │                 }
│   │       │  175 │ 
│   │       │  176 │                 // Delete the entire project directory
│   │       │  177 │                 Directory.Delete(projectDirectory, true);
│   │       │  178 │ 
│   │       │  179 │                 _logger.LogInformation("Project deleted successfully with ID {ProjectId}", id);
│   │       │  180 │                 return true;
│   │       │  181 │             }
│   │       │  182 │             catch (Exception ex)
│   │       │  183 │             {
│   │       │  184 │                 _logger.LogError(ex, "Error deleting project with ID {ProjectId}", id);
│   │       │  185 │                 throw new DataAccessException($"Failed to delete project with ID {id}", "Delete", "Project", ex);
│   │       │  186 │             }
│   │       │  187 │         }
│   │       │  188 │ 
│   │       │  189 │         /// <inheritdoc/>
│   │       │  190 │         public async Task<ImportedFile> ImportFileAsync(string projectId, string sourceFilePath)
│   │       │  191 │         {
│   │       │  192 │             if (string.IsNullOrEmpty(projectId))
│   │       │  193 │                 throw new ArgumentException("Project ID cannot be empty", nameof(projectId));
│   │       │  194 │             if (string.IsNullOrEmpty(sourceFilePath))
│   │       │  195 │                 throw new ArgumentException("Source file path cannot be empty", nameof(sourceFilePath));
│   │       │  196 │ 
│   │       │  197 │             try
│   │       │  198 │             {
│   │       │  199 │                 // Ensure the project exists
│   │       │  200 │                 var project = await GetByIdAsync(projectId);
│   │       │  201 │                 var fileName = Path.GetFileName(sourceFilePath);
│   │       │  202 │                 var filesDirectory = Path.Combine(_baseProjectsDirectory, projectId, "Files");
│   │       │  203 │ 
│   │       │  204 │                 // Generate a unique destination file name if needed
│   │       │  205 │                 var destinationPath = Path.Combine(filesDirectory, fileName);
│   │       │  206 │                 int counter = 1;
│   │       │  207 │                 while (_fileSystem.FileExists(destinationPath))
│   │       │  208 │                 {
│   │       │  209 │                     var fileNameWithoutExt = Path.GetFileNameWithoutExtension(fileName);
│   │       │  210 │                     var extension = Path.GetExtension(fileName);
│   │       │  211 │                     destinationPath = Path.Combine(filesDirectory, $"{fileNameWithoutExt}_{counter}{extension}");
│   │       │  212 │                     counter++;
│   │       │  213 │                 }
│   │       │  214 │ 
│   │       │  215 │                 // Copy the file
│   │       │  216 │                 using (var sourceStream = _fileSystem.OpenRead(sourceFilePath))
│   │       │  217 │                 using (var destStream = _fileSystem.OpenWrite(destinationPath))
│   │       │  218 │                 {
│   │       │  219 │                     await sourceStream.CopyToAsync(destStream);
│   │       │  220 │                 }
│   │       │  221 │ 
│   │       │  222 │                 // Get file info
│   │       │  223 │                 var fileInfo = new FileInfo(destinationPath);
│   │       │  224 │                 var fileType = Path.GetExtension(destinationPath).TrimStart('.');
│   │       │  225 │ 
│   │       │  226 │                 // Create the imported file record
│   │       │  227 │                 var importedFile = project.ImportFile(
│   │       │  228 │                     destinationPath,
│   │       │  229 │                     Path.GetFileName(destinationPath),
│   │       │  230 │                     fileInfo.Length,
│   │       │  231 │                     fileType);
│   │       │  232 │ 
│   │       │  233 │                 // Update project metadata
│   │       │  234 │                 await SaveProjectMetadataAsync(Path.Combine(_baseProjectsDirectory, projectId), project);
│   │       │  235 │ 
│   │       │  236 │                 _logger.LogInformation("File {FileName} imported to project {ProjectId}", fileName, projectId);
│   │       │  237 │                 return importedFile;
│   │       │  238 │             }
│   │       │  239 │             catch (NotFoundException)
│   │       │  240 │             {
│   │       │  241 │                 throw; // Let NotFoundException pass through
│   │       │  242 │             }
│   │       │  243 │             catch (Exception ex)
│   │       │  244 │             {
│   │       │  245 │                 _logger.LogError(ex, "Error importing file {FileName} to project {ProjectId}",
│   │       │  246 │                     Path.GetFileName(sourceFilePath), projectId);
│   │       │  247 │                 throw new DataAccessException(
│   │       │  248 │                     $"Failed to import file {Path.GetFileName(sourceFilePath)} to project {projectId}",
│   │       │  249 │                     "ImportFile", "Project", ex);
│   │       │  250 │             }
│   │       │  251 │         }
│   │       │  252 │ 
│   │       │  253 │         /// <inheritdoc/>
│   │       │  254 │         public async Task<bool> RemoveFileAsync(string projectId, string filePath)
│   │       │  255 │         {
│   │       │  256 │             if (string.IsNullOrEmpty(projectId))
│   │       │  257 │                 throw new ArgumentException("Project ID cannot be empty", nameof(projectId));
│   │       │  258 │             if (string.IsNullOrEmpty(filePath))
│   │       │  259 │                 throw new ArgumentException("File path cannot be empty", nameof(filePath));
│   │       │  260 │ 
│   │       │  261 │             try
│   │       │  262 │             {
│   │       │  263 │                 // Ensure the project exists
│   │       │  264 │                 var project = await GetByIdAsync(projectId);
│   │       │  265 │ 
│   │       │  266 │                 // Remove from project metadata
│   │       │  267 │                 bool removed = project.RemoveFile(filePath);
│   │       │  268 │                 if (removed)
│   │       │  269 │                 {
│   │       │  270 │                     // Update project metadata
│   │       │  271 │                     await SaveProjectMetadataAsync(Path.Combine(_baseProjectsDirectory, projectId), project);
│   │       │  272 │ 
│   │       │  273 │                     // Delete the physical file if it exists
│   │       │  274 │                     if (_fileSystem.FileExists(filePath))
│   │       │  275 │                     {
│   │       │  276 │                         File.Delete(filePath);
│   │       │  277 │                     }
│   │       │  278 │ 
│   │       │  279 │                     _logger.LogInformation("File {FilePath} removed from project {ProjectId}", filePath, projectId);
│   │       │  280 │                 }
│   │       │  281 │ 
│   │       │  282 │                 return removed;
│   │       │  283 │             }
│   │       │  284 │             catch (NotFoundException)
│   │       │  285 │             {
│   │       │  286 │                 throw; // Let NotFoundException pass through
│   │       │  287 │             }
│   │       │  288 │             catch (Exception ex)
│   │       │  289 │             {
│   │       │  290 │                 _logger.LogError(ex, "Error removing file {FilePath} from project {ProjectId}", filePath, projectId);
│   │       │  291 │                 throw new DataAccessException(
│   │       │  292 │                     $"Failed to remove file from project {projectId}",
│   │       │  293 │                     "RemoveFile", "Project", ex);
│   │       │  294 │             }
│   │       │  295 │         }
│   │       │  296 │ 
│   │       │  297 │         /// <inheritdoc/>
│   │       │  298 │         public async Task<SharedType> AddSharedTypeAsync(
│   │       │  299 │             string projectId,
│   │       │  300 │             string sourceFilePath,
│   │       │  301 │             string typeName = null,
│   │       │  302 │             string category = null,
│   │       │  303 │             string description = null)
│   │       │  304 │         {
│   │       │  305 │             if (string.IsNullOrEmpty(projectId))
│   │       │  306 │                 throw new ArgumentException("Project ID cannot be empty", nameof(projectId));
│   │       │  307 │             if (string.IsNullOrEmpty(sourceFilePath))
│   │       │  308 │                 throw new ArgumentException("Source file path cannot be empty", nameof(sourceFilePath));
│   │       │  309 │ 
│   │       │  310 │             try
│   │       │  311 │             {
│   │       │  312 │                 // Ensure the project exists
│   │       │  313 │                 var project = await GetByIdAsync(projectId);
│   │       │  314 │                 var fileName = Path.GetFileName(sourceFilePath);
│   │       │  315 │                 var sharedTypesDirectory = Path.Combine(_baseProjectsDirectory, projectId, "SharedTypes");
│   │       │  316 │ 
│   │       │  317 │                 // Generate a unique destination file name if needed
│   │       │  318 │                 var destinationPath = Path.Combine(sharedTypesDirectory, fileName);
│   │       │  319 │                 int counter = 1;
│   │       │  320 │                 while (_fileSystem.FileExists(destinationPath))
│   │       │  321 │                 {
│   │       │  322 │                     var fileNameWithoutExt = Path.GetFileNameWithoutExtension(fileName);
│   │       │  323 │                     var extension = Path.GetExtension(fileName);
│   │       │  324 │                     destinationPath = Path.Combine(sharedTypesDirectory, $"{fileNameWithoutExt}_{counter}{extension}");
│   │       │  325 │                     counter++;
│   │       │  326 │                 }
│   │       │  327 │ 
│   │       │  328 │                 // Copy the file
│   │       │  329 │                 using (var sourceStream = _fileSystem.OpenRead(sourceFilePath))
│   │       │  330 │                 using (var destStream = _fileSystem.OpenWrite(destinationPath))
│   │       │  331 │                 {
│   │       │  332 │                     await sourceStream.CopyToAsync(destStream);
│   │       │  333 │                 }
│   │       │  334 │ 
│   │       │  335 │                 // Get file info
│   │       │  336 │                 var fileInfo = new FileInfo(destinationPath);
│   │       │  337 │ 
│   │       │  338 │                 // Determine type name if not provided
│   │       │  339 │                 typeName ??= Path.GetFileNameWithoutExtension(destinationPath);
│   │       │  340 │                 category ??= "XML";
│   │       │  341 │                 description ??= "Imported shared type";
│   │       │  342 │ 
│   │       │  343 │                 // Add to project
│   │       │  344 │                 var sharedType = project.AddSharedType(
│   │       │  345 │                     typeName,
│   │       │  346 │                     Path.GetFileName(destinationPath),
│   │       │  347 │                     destinationPath,
│   │       │  348 │                     category,
│   │       │  349 │                     description,
│   │       │  350 │                     fileInfo.Length);
│   │       │  351 │ 
│   │       │  352 │                 // Update project metadata
│   │       │  353 │                 await SaveProjectMetadataAsync(Path.Combine(_baseProjectsDirectory, projectId), project);
│   │       │  354 │ 
│   │       │  355 │                 _logger.LogInformation("Shared type {TypeName} added to project {ProjectId}", typeName, projectId);
│   │       │  356 │                 return sharedType;
│   │       │  357 │             }
│   │       │  358 │             catch (NotFoundException)
│   │       │  359 │             {
│   │       │  360 │                 throw; // Let NotFoundException pass through
│   │       │  361 │             }
│   │       │  362 │             catch (Exception ex)
│   │       │  363 │             {
│   │       │  364 │                 _logger.LogError(ex, "Error adding shared type from {FileName} to project {ProjectId}",
│   │       │  365 │                     Path.GetFileName(sourceFilePath), projectId);
│   │       │  366 │                 throw new DataAccessException(
│   │       │  367 │                     $"Failed to add shared type to project {projectId}",
│   │       │  368 │                     "AddSharedType", "Project", ex);
│   │       │  369 │             }
│   │       │  370 │         }
│   │       │  371 │ 
│   │       │  372 │         /// <inheritdoc/>
│   │       │  373 │         public async Task<bool> UpdateSharedTypeDescriptionAsync(string projectId, string filePath, string description)
│   │       │  374 │         {
│   │       │  375 │             if (string.IsNullOrEmpty(projectId))
│   │       │  376 │                 throw new ArgumentException("Project ID cannot be empty", nameof(projectId));
│   │       │  377 │             if (string.IsNullOrEmpty(filePath))
│   │       │  378 │                 throw new ArgumentException("File path cannot be empty", nameof(filePath));
│   │       │  379 │ 
│   │       │  380 │             try
│   │       │  381 │             {
│   │       │  382 │                 // Ensure the project exists
│   │       │  383 │                 var project = await GetByIdAsync(projectId);
│   │       │  384 │ 
│   │       │  385 │                 // Update description
│   │       │  386 │                 bool updated = project.UpdateSharedTypeDescription(filePath, description);
│   │       │  387 │                 if (updated)
│   │       │  388 │                 {
│   │       │  389 │                     // Update project metadata
│   │       │  390 │                     await SaveProjectMetadataAsync(Path.Combine(_baseProjectsDirectory, projectId), project);
│   │       │  391 │                     _logger.LogInformation("Updated description for shared type in project {ProjectId}", projectId);
│   │       │  392 │                 }
│   │       │  393 │ 
│   │       │  394 │                 return updated;
│   │       │  395 │             }
│   │       │  396 │             catch (NotFoundException)
│   │       │  397 │             {
│   │       │  398 │                 throw; // Let NotFoundException pass through
│   │       │  399 │             }
│   │       │  400 │             catch (Exception ex)
│   │       │  401 │             {
│   │       │  402 │                 _logger.LogError(ex, "Error updating shared type description in project {ProjectId}", projectId);
│   │       │  403 │                 throw new DataAccessException(
│   │       │  404 │                     $"Failed to update shared type description in project {projectId}",
│   │       │  405 │                     "UpdateSharedTypeDescription", "Project", ex);
│   │       │  406 │             }
│   │       │  407 │         }
│   │       │  408 │ 
│   │       │  409 │         /// <inheritdoc/>
│   │       │  410 │         public async Task<bool> RemoveSharedTypeAsync(string projectId, string filePath)
│   │       │  411 │         {
│   │       │  412 │             if (string.IsNullOrEmpty(projectId))
│   │       │  413 │                 throw new ArgumentException("Project ID cannot be empty", nameof(projectId));
│   │       │  414 │             if (string.IsNullOrEmpty(filePath))
│   │       │  415 │                 throw new ArgumentException("File path cannot be empty", nameof(filePath));
│   │       │  416 │ 
│   │       │  417 │             try
│   │       │  418 │             {
│   │       │  419 │                 // Ensure the project exists
│   │       │  420 │                 var project = await GetByIdAsync(projectId);
│   │       │  421 │ 
│   │       │  422 │                 // Remove from project metadata
│   │       │  423 │                 bool removed = project.RemoveSharedType(filePath);
│   │       │  424 │                 if (removed)
│   │       │  425 │                 {
│   │       │  426 │                     // Update project metadata
│   │       │  427 │                     await SaveProjectMetadataAsync(Path.Combine(_baseProjectsDirectory, projectId), project);
│   │       │  428 │ 
│   │       │  429 │                     // Delete the physical file if it exists
│   │       │  430 │                     if (_fileSystem.FileExists(filePath))
│   │       │  431 │                     {
│   │       │  432 │                         File.Delete(filePath);
│   │       │  433 │                     }
│   │       │  434 │ 
│   │       │  435 │                     _logger.LogInformation("Shared type {FilePath} removed from project {ProjectId}", filePath, projectId);
│   │       │  436 │                 }
│   │       │  437 │ 
│   │       │  438 │                 return removed;
│   │       │  439 │             }
│   │       │  440 │             catch (NotFoundException)
│   │       │  441 │             {
│   │       │  442 │                 throw; // Let NotFoundException pass through
│   │       │  443 │             }
│   │       │  444 │             catch (Exception ex)
│   │       │  445 │             {
│   │       │  446 │                 _logger.LogError(ex, "Error removing shared type {FilePath} from project {ProjectId}", filePath, projectId);
│   │       │  447 │                 throw new DataAccessException(
│   │       │  448 │                     $"Failed to remove shared type from project {projectId}",
│   │       │  449 │                     "RemoveSharedType", "Project", ex);
│   │       │  450 │             }
│   │       │  451 │         }
│   │       │  452 │ 
│   │       │  453 │         #region Private Helper Methods
│   │       │  454 │ 
│   │       │  455 │         /// <summary>
│   │       │  456 │         /// Loads a project from its directory
│   │       │  457 │         /// </summary>
│   │       │  458 │         /// <param name="projectDirectory">The project directory path</param>
│   │       │  459 │         /// <returns>The loaded project or null if not found</returns>
│   │       │  460 │         private async Task<Project> LoadProjectFromDirectoryAsync(string projectDirectory)
│   │       │  461 │         {
│   │       │  462 │             var metadataPath = Path.Combine(projectDirectory, ProjectMetadataFileName);
│   │       │  463 │             if (!_fileSystem.FileExists(metadataPath))
│   │       │  464 │             {
│   │       │  465 │                 _logger.LogWarning("Project metadata file not found in directory {Directory}", projectDirectory);
│   │       │  466 │                 return null;
│   │       │  467 │             }
│   │       │  468 │ 
│   │       │  469 │             try
│   │       │  470 │             {
│   │       │  471 │                 var json = await _fileSystem.ReadAllTextAsync(metadataPath);
│   │       │  472 │                 var projectData = JsonSerializer.Deserialize<ProjectData>(json);
│   │       │  473 │ 
│   │       │  474 │                 // Extract project ID from directory name if not in metadata
│   │       │  475 │                 var projectId = projectData.Id ?? Path.GetFileName(projectDirectory);
│   │       │  476 │ 
│   │       │  477 │                 // Create project domain object
│   │       │  478 │                 var project = new Project(
│   │       │  479 │                     projectId,
│   │       │  480 │                     projectData.Name,
│   │       │  481 │                     projectData.Description);
│   │       │  482 │ 
│   │       │  483 │                 // Add imported files
│   │       │  484 │                 if (projectData.ImportedFiles != null)
│   │       │  485 │                 {
│   │       │  486 │                     foreach (var fileData in projectData.ImportedFiles)
│   │       │  487 │                     {
│   │       │  488 │                         try
│   │       │  489 │                         {
│   │       │  490 │                             var importedFile = new ImportedFile(
│   │       │  491 │                                 fileData.FilePath,
│   │       │  492 │                                 fileData.FileName,
│   │       │  493 │                                 fileData.FileSize,
│   │       │  494 │                                 fileData.FileType);
│   │       │  495 │ 
│   │       │  496 │                             // Add to project using reflection to avoid validation
│   │       │  497 │                             var importedFiles = typeof(Project).GetField("_importedFiles", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)
│   │       │  498 │                                 ?.GetValue(project) as List<ImportedFile>;
│   │       │  499 │ 
│   │       │  500 │                             if (importedFiles != null)
│   │       │  501 │                             {
│   │       │  502 │                                 importedFiles.Add(importedFile);
│   │       │  503 │                             }
│   │       │  504 │                         }
│   │       │  505 │                         catch (Exception ex)
│   │       │  506 │                         {
│   │       │  507 │                             _logger.LogWarning(ex, "Error adding imported file {FileName} to project {ProjectId}",
│   │       │  508 │                                 fileData.FileName, projectId);
│   │       │  509 │                         }
│   │       │  510 │                     }
│   │       │  511 │                 }
│   │       │  512 │ 
│   │       │  513 │                 // Add shared types
│   │       │  514 │                 if (projectData.SharedTypes != null)
│   │       │  515 │                 {
│   │       │  516 │                     foreach (var typeData in projectData.SharedTypes)
│   │       │  517 │                     {
│   │       │  518 │                         try
│   │       │  519 │                         {
│   │       │  520 │                             var sharedType = new SharedType(
│   │       │  521 │                                 typeData.TypeName,
│   │       │  522 │                                 typeData.FileName,
│   │       │  523 │                                 typeData.FilePath,
│   │       │  524 │                                 typeData.Category,
│   │       │  525 │                                 typeData.Description,
│   │       │  526 │                                 typeData.FileSize);
│   │       │  527 │ 
│   │       │  528 │                             // Set additional properties
│   │       │  529 │                             typeof(SharedType).GetMethod("SetVariableCount")
│   │       │  530 │                                 ?.Invoke(sharedType, new object[] { typeData.VariableCount });
│   │       │  531 │ 
│   │       │  532 │                             typeof(SharedType).GetMethod("SetDefaultTargetName")
│   │       │  533 │                                 ?.Invoke(sharedType, new object[] { typeData.DefaultTargetName });
│   │       │  534 │ 
│   │       │  535 │                             // Add usages
│   │       │  536 │                             for (int i = 0; i < typeData.UsageCount; i++)
│   │       │  537 │                             {
│   │       │  538 │                                 typeof(SharedType).GetMethod("IncrementUsageCount")
│   │       │  539 │                                     ?.Invoke(sharedType, null);
│   │       │  540 │                             }
│   │       │  541 │ 
│   │       │  542 │                             // Add to project using reflection to avoid validation
│   │       │  543 │                             var sharedTypes = typeof(Project).GetField("_sharedTypes", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)
│   │       │  544 │                                 ?.GetValue(project) as List<SharedType>;
│   │       │  545 │ 
│   │       │  546 │                             if (sharedTypes != null)
│   │       │  547 │                             {
│   │       │  548 │                                 sharedTypes.Add(sharedType);
│   │       │  549 │                             }
│   │       │  550 │                         }
│   │       │  551 │                         catch (Exception ex)
│   │       │  552 │                         {
│   │       │  553 │                             _logger.LogWarning(ex, "Error adding shared type {TypeName} to project {ProjectId}",
│   │       │  554 │                                 typeData.TypeName, projectId);
│   │       │  555 │                         }
│   │       │  556 │                     }
│   │       │  557 │                 }
│   │       │  558 │ 
│   │       │  559 │                 // Add custom type files
│   │       │  560 │                 if (projectData.CustomTypeFiles != null)
│   │       │  561 │                 {
│   │       │  562 │                     foreach (var fileData in projectData.CustomTypeFiles)
│   │       │  563 │                     {
│   │       │  564 │                         try
│   │       │  565 │                         {
│   │       │  566 │                             var customTypeFile = new CustomTypeFile(
│   │       │  567 │                                 fileData.FileName,
│   │       │  568 │                                 fileData.TypeCount,
│   │       │  569 │                                 fileData.Description);
│   │       │  570 │ 
│   │       │  571 │                             // Add to project using reflection to avoid validation
│   │       │  572 │                             var customTypeFiles = typeof(Project).GetField("_customTypeFiles", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)
│   │       │  573 │                                 ?.GetValue(project) as List<CustomTypeFile>;
│   │       │  574 │ 
│   │       │  575 │                             if (customTypeFiles != null)
│   │       │  576 │                             {
│   │       │  577 │                                 customTypeFiles.Add(customTypeFile);
│   │       │  578 │                             }
│   │       │  579 │                         }
│   │       │  580 │                         catch (Exception ex)
│   │       │  581 │                         {
│   │       │  582 │                             _logger.LogWarning(ex, "Error adding custom type file {FileName} to project {ProjectId}",
│   │       │  583 │                                 fileData.FileName, projectId);
│   │       │  584 │                         }
│   │       │  585 │                     }
│   │       │  586 │                 }
│   │       │  587 │ 
│   │       │  588 │                 return project;
│   │       │  589 │             }
│   │       │  590 │             catch (Exception ex)
│   │       │  591 │             {
│   │       │  592 │                 _logger.LogError(ex, "Error deserializing project metadata in directory {Directory}", projectDirectory);
│   │       │  593 │                 return null;
│   │       │  594 │             }
│   │       │  595 │         }
│   │       │  596 │ 
│   │       │  597 │         /// <summary>
│   │       │  598 │         /// Saves project metadata to the specified directory
│   │       │  599 │         /// </summary>
│   │       │  600 │         /// <param name="projectDirectory">The project directory</param>
│   │       │  601 │         /// <param name="project">The project to save</param>
│   │       │  602 │         private async Task SaveProjectMetadataAsync(string projectDirectory, Project project)
│   │       │  603 │         {
│   │       │  604 │             var projectData = new ProjectData
│   │       │  605 │             {
│   │       │  606 │                 Id = project.Id,
│   │       │  607 │                 Name = project.Name,
│   │       │  608 │                 Description = project.Description,
│   │       │  609 │                 Created = project.Created,
│   │       │  610 │                 LastModified = project.LastModified,
│   │       │  611 │                 ImportedFiles = project.ImportedFiles.Select(f => new ImportedFileData
│   │       │  612 │                 {
│   │       │  613 │                     FileName = f.FileName,
│   │       │  614 │                     FilePath = f.FilePath,
│   │       │  615 │                     FileSize = f.FileSize,
│   │       │  616 │                     FileType = f.FileType,
│   │       │  617 │                     ImportDate = f.ImportDate,
│   │       │  618 │                     Status = f.Status
│   │       │  619 │                 }).ToList(),
│   │       │  620 │                 SharedTypes = project.SharedTypes.Select(t => new SharedTypeData
│   │       │  621 │                 {
│   │       │  622 │                     TypeName = t.TypeName,
│   │       │  623 │                     FileName = t.FileName,
│   │       │  624 │                     FilePath = t.FilePath,
│   │       │  625 │                     Category = t.Category,
│   │       │  626 │                     Description = t.Description,
│   │       │  627 │                     ImportDate = t.ImportDate,
│   │       │  628 │                     FileSize = t.FileSize,
│   │       │  629 │                     UsageCount = t.UsageCount,
│   │       │  630 │                     VariableCount = t.VariableCount,
│   │       │  631 │                     DefaultTargetName = t.DefaultTargetName
│   │       │  632 │                 }).ToList(),
│   │       │  633 │                 CustomTypeFiles = project.CustomTypeFiles.Select(f => new CustomTypeFileData
│   │       │  634 │                 {
│   │       │  635 │                     FileName = f.FileName,
│   │       │  636 │                     TypeCount = f.TypeCount,
│   │       │  637 │                     LastModified = f.LastModified,
│   │       │  638 │                     Description = f.Description
│   │       │  639 │                 }).ToList()
│   │       │  640 │             };
│   │       │  641 │ 
│   │       │  642 │             var options = new JsonSerializerOptions { WriteIndented = true };
│   │       │  643 │             var json = JsonSerializer.Serialize(projectData, options);
│   │       │  644 │             var metadataPath = Path.Combine(projectDirectory, ProjectMetadataFileName);
│   │       │  645 │             await _fileSystem.WriteAllTextAsync(metadataPath, json);
│   │       │  646 │         }
│   │       │  647 │ 
│   │       │  648 │         #endregion
│   │       │  649 │ 
│   │       │  650 │         #region DTO Classes for Serialization
│   │       │  651 │ 
│   │       │  652 │         /// <summary>
│   │       │  653 │         /// Data transfer object for project metadata serialization
│   │       │  654 │         /// </summary>
│   │       │  655 │         private class ProjectData
│   │       │  656 │         {
│   │       │  657 │             public string Id { get; set; }
│   │       │  658 │             public string Name { get; set; }
│   │       │  659 │             public string Description { get; set; }
│   │       │  660 │             public DateTime Created { get; set; }
│   │       │  661 │             public DateTime LastModified { get; set; }
│   │       │  662 │             public List<ImportedFileData> ImportedFiles { get; set; } = new();
│   │       │  663 │             public List<SharedTypeData> SharedTypes { get; set; } = new();
│   │       │  664 │             public List<CustomTypeFileData> CustomTypeFiles { get; set; } = new();
│   │       │  665 │         }
│   │       │  666 │ 
│   │       │  667 │         private class ImportedFileData
│   │       │  668 │         {
│   │       │  669 │             public string FileName { get; set; }
│   │       │  670 │             public string FilePath { get; set; }
│   │       │  671 │             public long FileSize { get; set; }
│   │       │  672 │             public string FileType { get; set; }
│   │       │  673 │             public DateTime ImportDate { get; set; }
│   │       │  674 │             public string Status { get; set; }
│   │       │  675 │         }
│   │       │  676 │ 
│   │       │  677 │         private class SharedTypeData
│   │       │  678 │         {
│   │       │  679 │             public string TypeName { get; set; }
│   │       │  680 │             public string FileName { get; set; }
│   │       │  681 │             public string FilePath { get; set; }
│   │       │  682 │             public string Category { get; set; }
│   │       │  683 │             public string Description { get; set; }
│   │       │  684 │             public DateTime ImportDate { get; set; }
│   │       │  685 │             public long FileSize { get; set; }
│   │       │  686 │             public int UsageCount { get; set; }
│   │       │  687 │             public int VariableCount { get; set; }
│   │       │  688 │             public string DefaultTargetName { get; set; }
│   │       │  689 │         }
│   │       │  690 │ 
│   │       │  691 │         private class CustomTypeFileData
│   │       │  692 │         {
│   │       │  693 │             public string FileName { get; set; }
│   │       │  694 │             public int TypeCount { get; set; }
│   │       │  695 │             public DateTime LastModified { get; set; }
│   │       │  696 │             public string Description { get; set; }
│   │       │  697 │         }
│   │       │  698 │ 
│   │       │  699 │         #endregion
│   │       │  700 │     }
│   │       │  701 │ }
│   │       └──────────────────────────────────────────────────────────────────────
│   │   📁 FileSystem
│   │   └── 📄 PhysicalFileSystem.cs (977.00 B, 2025-03-11 09:48:27)
│   │       ┌──────────────────────────────────────────────────────────────────────
│   │       │ FILE CONTENT: PhysicalFileSystem.cs
│   │       ├──────────────────────────────────────────────────────────────────────
│   │       │    1 │ ﻿using test.Core.Interfaces;
│   │       │    2 │ using System;
│   │       │    3 │ using System.Collections.Generic;
│   │       │    4 │ using System.IO;
│   │       │    5 │ using System.Linq;
│   │       │    6 │ using System.Text;
│   │       │    7 │ using System.Threading.Tasks;
│   │       │    8 │ 
│   │       │    9 │ namespace test.Infrastructure.FileSystem
│   │       │   10 │ {
│   │       │   11 │     /// <summary>
│   │       │   12 │     /// Concrete implementation of IFileSystem that uses the physical file system
│   │       │   13 │     /// </summary>
│   │       │   14 │     public class PhysicalFileSystem : IFileSystem
│   │       │   15 │     {
│   │       │   16 │         public Task<string> ReadAllTextAsync(string path) => File.ReadAllTextAsync(path);
│   │       │   17 │         public Task WriteAllTextAsync(string path, string content) => File.WriteAllTextAsync(path, content);
│   │       │   18 │         public bool FileExists(string path) => File.Exists(path);
│   │       │   19 │         public Stream OpenRead(string path) => File.OpenRead(path);
│   │       │   20 │         public Stream OpenWrite(string path) => File.OpenWrite(path);
│   │       │   21 │         public void CreateDirectory(string path) => Directory.CreateDirectory(path);
│   │       │   22 │         public bool DirectoryExists(string path) => Directory.Exists(path);
│   │       │   23 │     }
│   │       │   24 │ }
│   │       └──────────────────────────────────────────────────────────────────────
│   │   📁 Logging
│   │   ├── 📄 ApplicationErrorHandler.cs (4.22 KB, 2025-03-11 09:48:27)
│   │   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │   │ FILE CONTENT: ApplicationErrorHandler.cs
│   │   │   ├──────────────────────────────────────────────────────────────────────
│   │   │   │    1 │ ﻿using Microsoft.Extensions.Logging;
│   │   │   │    2 │ using test.Core.Exceptions;
│   │   │   │    3 │ using test.Core.Interfaces;
│   │   │   │    4 │ using System;
│   │   │   │    5 │ using System.Collections.Generic;
│   │   │   │    6 │ using System.Threading.Tasks;
│   │   │   │    7 │ using System.IO;
│   │   │   │    8 │ 
│   │   │   │    9 │ namespace test.Infrastructure.Logging
│   │   │   │   10 │ {
│   │   │   │   11 │     /// <summary>
│   │   │   │   12 │     /// Implementation of the error handler that logs errors and shows UI notifications
│   │   │   │   13 │     /// </summary>
│   │   │   │   14 │     public class ApplicationErrorHandler : IErrorHandler
│   │   │   │   15 │     {
│   │   │   │   16 │         private readonly ILogger<ApplicationErrorHandler> _logger;
│   │   │   │   17 │         private readonly IDialogService _dialogService;
│   │   │   │   18 │ 
│   │   │   │   19 │         public ApplicationErrorHandler(
│   │   │   │   20 │             ILogger<ApplicationErrorHandler> logger,
│   │   │   │   21 │             IDialogService dialogService)
│   │   │   │   22 │         {
│   │   │   │   23 │             _logger = logger;
│   │   │   │   24 │             _dialogService = dialogService;
│   │   │   │   25 │         }
│   │   │   │   26 │ 
│   │   │   │   27 │         public void HandleException(Exception ex, string context)
│   │   │   │   28 │         {
│   │   │   │   29 │             // Log based on exception type
│   │   │   │   30 │             switch (ex)
│   │   │   │   31 │             {
│   │   │   │   32 │                 case BusinessRuleException:
│   │   │   │   33 │                     _logger.LogWarning(ex, "Business rule violation in {Context}: {Message}",
│   │   │   │   34 │                         context, ex.Message);
│   │   │   │   35 │                     break;
│   │   │   │   36 │ 
│   │   │   │   37 │                 case NotFoundException notFoundEx:
│   │   │   │   38 │                     _logger.LogInformation(ex, "Not found in {Context}: {EntityType} {EntityId}",
│   │   │   │   39 │                         context, notFoundEx.EntityType, notFoundEx.EntityId);
│   │   │   │   40 │                     break;
│   │   │   │   41 │ 
│   │   │   │   42 │                 case ParsingException parsingEx:
│   │   │   │   43 │                     _logger.LogError(ex, "Parsing error in {Context} for file {FilePath} ({FileType}): {Message}",
│   │   │   │   44 │                         context, parsingEx.FilePath, parsingEx.FileType, ex.Message);
│   │   │   │   45 │                     break;
│   │   │   │   46 │ 
│   │   │   │   47 │                 case DataAccessException dataEx:
│   │   │   │   48 │                     _logger.LogError(ex, "Data access error in {Context}, operation: {Operation}, entity: {EntityType}: {Message}",
│   │   │   │   49 │                         context, dataEx.Operation, dataEx.EntityType, ex.Message);
│   │   │   │   50 │                     break;
│   │   │   │   51 │ 
│   │   │   │   52 │                 default:
│   │   │   │   53 │                     _logger.LogError(ex, "Unexpected error in {Context}: {Message}",
│   │   │   │   54 │                         context, ex.Message);
│   │   │   │   55 │                     break;
│   │   │   │   56 │             }
│   │   │   │   57 │         }
│   │   │   │   58 │ 
│   │   │   │   59 │         public async Task HandleExceptionWithUIAsync(Exception ex, string context)
│   │   │   │   60 │         {
│   │   │   │   61 │             // Log first
│   │   │   │   62 │             HandleException(ex, context);
│   │   │   │   63 │ 
│   │   │   │   64 │             // Then show UI based on exception type
│   │   │   │   65 │             switch (ex)
│   │   │   │   66 │             {
│   │   │   │   67 │                 case BusinessRuleException:
│   │   │   │   68 │                     await _dialogService.ShowErrorDialogAsync(
│   │   │   │   69 │                         "Business Rule Violation",
│   │   │   │   70 │                         ex.Message);
│   │   │   │   71 │                     break;
│   │   │   │   72 │ 
│   │   │   │   73 │                 case NotFoundException:
│   │   │   │   74 │                     await _dialogService.ShowErrorDialogAsync(
│   │   │   │   75 │                         "Not Found",
│   │   │   │   76 │                         ex.Message);
│   │   │   │   77 │                     break;
│   │   │   │   78 │ 
│   │   │   │   79 │                 case ParsingException parsingEx:
│   │   │   │   80 │                     await _dialogService.ShowErrorDialogAsync(
│   │   │   │   81 │                         "Parsing Error",
│   │   │   │   82 │                         $"Error parsing file '{Path.GetFileName(parsingEx.FilePath)}':\n\n{ex.Message}");
│   │   │   │   83 │                     break;
│   │   │   │   84 │ 
│   │   │   │   85 │                 case DataAccessException:
│   │   │   │   86 │                     await _dialogService.ShowErrorDialogAsync(
│   │   │   │   87 │                         "Data Access Error",
│   │   │   │   88 │                         $"A data access error occurred:\n\n{ex.Message}");
│   │   │   │   89 │                     break;
│   │   │   │   90 │ 
│   │   │   │   91 │                 default:
│   │   │   │   92 │                     await _dialogService.ShowErrorDialogAsync(
│   │   │   │   93 │                         "Error",
│   │   │   │   94 │                         $"An unexpected error occurred:\n\n{ex.Message}");
│   │   │   │   95 │                     break;
│   │   │   │   96 │             }
│   │   │   │   97 │         }
│   │   │   │   98 │ 
│   │   │   │   99 │         public void LogWarning(string message, string context)
│   │   │   │  100 │         {
│   │   │   │  101 │             _logger.LogWarning("{Message} in {Context}", message, context);
│   │   │   │  102 │         }
│   │   │   │  103 │ 
│   │   │   │  104 │         public void TrackEvent(string name, IDictionary<string, string> properties = null)
│   │   │   │  105 │         {
│   │   │   │  106 │             var logProperties = properties != null
│   │   │   │  107 │                 ? new Dictionary<string, string>(properties)
│   │   │   │  108 │                 : new Dictionary<string, string>();
│   │   │   │  109 │ 
│   │   │   │  110 │             _logger.LogInformation("Event: {EventName}, Properties: {@Properties}",
│   │   │   │  111 │                 name, logProperties);
│   │   │   │  112 │         }
│   │   │   │  113 │     }
│   │   │   │  114 │ }
│   │   │   └──────────────────────────────────────────────────────────────────────
│   │   ├── 📄 ErrorHandlingExtensions.cs (3.66 KB, 2025-03-11 09:48:27)
│   │   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │   │ FILE CONTENT: ErrorHandlingExtensions.cs
│   │   │   ├──────────────────────────────────────────────────────────────────────
│   │   │   │    1 │ ﻿using test.Core.Exceptions;
│   │   │   │    2 │ using test.Core.Interfaces;
│   │   │   │    3 │ using System;
│   │   │   │    4 │ using System.Collections.Generic;
│   │   │   │    5 │ using System.Diagnostics;
│   │   │   │    6 │ using System.Threading.Tasks;
│   │   │   │    7 │ 
│   │   │   │    8 │ namespace test.Infrastructure.Logging
│   │   │   │    9 │ {
│   │   │   │   10 │     /// <summary>
│   │   │   │   11 │     /// Extensions for adding error handling capabilities to the application
│   │   │   │   12 │     /// </summary>
│   │   │   │   13 │     public static class ErrorHandlingExtensions
│   │   │   │   14 │     {
│   │   │   │   15 │         /// <summary>
│   │   │   │   16 │         /// Executes a function with error handling
│   │   │   │   17 │         /// </summary>
│   │   │   │   18 │         public static async Task<TResult> WithErrorHandlingAsync<TResult>(
│   │   │   │   19 │             this IErrorHandler errorHandler,
│   │   │   │   20 │             Func<Task<TResult>> func,
│   │   │   │   21 │             string context,
│   │   │   │   22 │             bool showUI = false)
│   │   │   │   23 │         {
│   │   │   │   24 │             try
│   │   │   │   25 │             {
│   │   │   │   26 │                 return await func();
│   │   │   │   27 │             }
│   │   │   │   28 │             catch (Exception ex)
│   │   │   │   29 │             {
│   │   │   │   30 │                 if (showUI)
│   │   │   │   31 │                 {
│   │   │   │   32 │                     await errorHandler.HandleExceptionWithUIAsync(ex, context);
│   │   │   │   33 │                 }
│   │   │   │   34 │                 else
│   │   │   │   35 │                 {
│   │   │   │   36 │                     errorHandler.HandleException(ex, context);
│   │   │   │   37 │                 }
│   │   │   │   38 │ 
│   │   │   │   39 │                 // Re-throw domain exceptions, but wrap others
│   │   │   │   40 │                 if (ex is DomainExceptionBase)
│   │   │   │   41 │                 {
│   │   │   │   42 │                     throw;
│   │   │   │   43 │                 }
│   │   │   │   44 │ 
│   │   │   │   45 │                 throw new ApplicationException($"Error in {context}: {ex.Message}", ex);
│   │   │   │   46 │             }
│   │   │   │   47 │         }
│   │   │   │   48 │ 
│   │   │   │   49 │         /// <summary>
│   │   │   │   50 │         /// Executes an action with error handling
│   │   │   │   51 │         /// </summary>
│   │   │   │   52 │         public static async Task WithErrorHandlingAsync(
│   │   │   │   53 │             this IErrorHandler errorHandler,
│   │   │   │   54 │             Func<Task> action,
│   │   │   │   55 │             string context,
│   │   │   │   56 │             bool showUI = false)
│   │   │   │   57 │         {
│   │   │   │   58 │             try
│   │   │   │   59 │             {
│   │   │   │   60 │                 await action();
│   │   │   │   61 │             }
│   │   │   │   62 │             catch (Exception ex)
│   │   │   │   63 │             {
│   │   │   │   64 │                 if (showUI)
│   │   │   │   65 │                 {
│   │   │   │   66 │                     await errorHandler.HandleExceptionWithUIAsync(ex, context);
│   │   │   │   67 │                 }
│   │   │   │   68 │                 else
│   │   │   │   69 │                 {
│   │   │   │   70 │                     errorHandler.HandleException(ex, context);
│   │   │   │   71 │                 }
│   │   │   │   72 │ 
│   │   │   │   73 │                 // Re-throw domain exceptions, but wrap others
│   │   │   │   74 │                 if (ex is DomainExceptionBase)
│   │   │   │   75 │                 {
│   │   │   │   76 │                     throw;
│   │   │   │   77 │                 }
│   │   │   │   78 │ 
│   │   │   │   79 │                 throw new ApplicationException($"Error in {context}: {ex.Message}", ex);
│   │   │   │   80 │             }
│   │   │   │   81 │         }
│   │   │   │   82 │ 
│   │   │   │   83 │         /// <summary>
│   │   │   │   84 │         /// Adds operation timing and logging
│   │   │   │   85 │         /// </summary>
│   │   │   │   86 │         public static async Task<T> WithTimingAsync<T>(
│   │   │   │   87 │             this IErrorHandler errorHandler,
│   │   │   │   88 │             Func<Task<T>> func,
│   │   │   │   89 │             string operationName)
│   │   │   │   90 │         {
│   │   │   │   91 │             var stopwatch = Stopwatch.StartNew();
│   │   │   │   92 │ 
│   │   │   │   93 │             try
│   │   │   │   94 │             {
│   │   │   │   95 │                 var result = await func();
│   │   │   │   96 │                 stopwatch.Stop();
│   │   │   │   97 │ 
│   │   │   │   98 │                 errorHandler.TrackEvent("OperationTiming", new Dictionary<string, string>
│   │   │   │   99 │                 {
│   │   │   │  100 │                     ["Operation"] = operationName,
│   │   │   │  101 │                     ["DurationMs"] = stopwatch.ElapsedMilliseconds.ToString(),
│   │   │   │  102 │                     ["Success"] = "true"
│   │   │   │  103 │                 });
│   │   │   │  104 │ 
│   │   │   │  105 │                 return result;
│   │   │   │  106 │             }
│   │   │   │  107 │             catch (Exception ex)
│   │   │   │  108 │             {
│   │   │   │  109 │                 stopwatch.Stop();
│   │   │   │  110 │ 
│   │   │   │  111 │                 errorHandler.TrackEvent("OperationTiming", new Dictionary<string, string>
│   │   │   │  112 │                 {
│   │   │   │  113 │                     ["Operation"] = operationName,
│   │   │   │  114 │                     ["DurationMs"] = stopwatch.ElapsedMilliseconds.ToString(),
│   │   │   │  115 │                     ["Success"] = "false",
│   │   │   │  116 │                     ["ExceptionType"] = ex.GetType().Name
│   │   │   │  117 │                 });
│   │   │   │  118 │ 
│   │   │   │  119 │                 throw;
│   │   │   │  120 │             }
│   │   │   │  121 │         }
│   │   │   │  122 │     }
│   │   │   │  123 │ }
│   │   │   └──────────────────────────────────────────────────────────────────────
│   │   └── 📄 LoggingService.cs (5.31 KB, 2025-03-12 14:30:48)
│   │       ┌──────────────────────────────────────────────────────────────────────
│   │       │ FILE CONTENT: LoggingService.cs
│   │       ├──────────────────────────────────────────────────────────────────────
│   │       │    1 │ ﻿using Microsoft.Extensions.Logging;
│   │       │    2 │ using Serilog;
│   │       │    3 │ using Serilog.Core;
│   │       │    4 │ using Serilog.Events;
│   │       │    5 │ using System;
│   │       │    6 │ using System.IO;
│   │       │    7 │ using test.Core.Interfaces;
│   │       │    8 │ 
│   │       │    9 │ namespace test.Infrastructure.Logging
│   │       │   10 │ {
│   │       │   11 │     public class LoggingService : ILoggingService, IDisposable
│   │       │   12 │     {
│   │       │   13 │         private readonly string _logDirectory;
│   │       │   14 │         private bool _isEnabled;
│   │       │   15 │         private readonly ILogger<LoggingService> _logger;
│   │       │   16 │         private LogEventLevel _currentLevel = LogEventLevel.Information;
│   │       │   17 │         private bool _disposed;
│   │       │   18 │ 
│   │       │   19 │         public bool IsLoggingEnabled => _isEnabled;
│   │       │   20 │ 
│   │       │   21 │         public string LogFilePath { get; private set; }
│   │       │   22 │ 
│   │       │   23 │         public LoggingService(ILogger<LoggingService> logger)
│   │       │   24 │         {
│   │       │   25 │             _logger = logger;
│   │       │   26 │             _logDirectory = Path.Combine(
│   │       │   27 │                 Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
│   │       │   28 │                 "PaapeConversionKit",
│   │       │   29 │                 "Logs"
│   │       │   30 │             );
│   │       │   31 │ 
│   │       │   32 │             // Ensure the log directory exists
│   │       │   33 │             Directory.CreateDirectory(_logDirectory);
│   │       │   34 │ 
│   │       │   35 │             // Set the log file path - using date in filename for daily rolling
│   │       │   36 │             LogFilePath = Path.Combine(_logDirectory, $"app_{DateTime.Now:yyyyMMdd}.log");
│   │       │   37 │ 
│   │       │   38 │             _logger?.LogDebug("LoggingService initialized. Path: {LogFilePath}", LogFilePath);
│   │       │   39 │ 
│   │       │   40 │             // Initialize the global logger with just console and debug (file will be added when enabled)
│   │       │   41 │             ReconfigureGlobalLogger(false);
│   │       │   42 │         }
│   │       │   43 │ 
│   │       │   44 │         public void EnableLogging(bool enable)
│   │       │   45 │         {
│   │       │   46 │             try
│   │       │   47 │             {
│   │       │   48 │                 if (enable == _isEnabled)
│   │       │   49 │                 {
│   │       │   50 │                     // No change in state, just return
│   │       │   51 │                     return;
│   │       │   52 │                 }
│   │       │   53 │ 
│   │       │   54 │                 _isEnabled = enable;
│   │       │   55 │ 
│   │       │   56 │                 // Reconfigure the global logger based on the enabled state
│   │       │   57 │                 ReconfigureGlobalLogger(_isEnabled);
│   │       │   58 │ 
│   │       │   59 │                 if (enable)
│   │       │   60 │                 {
│   │       │   61 │                     Log.Information("Logging enabled at {Timestamp}", DateTime.Now);
│   │       │   62 │                     _logger?.LogInformation("Logging enabled");
│   │       │   63 │                 }
│   │       │   64 │                 else
│   │       │   65 │                 {
│   │       │   66 │                     _logger?.LogInformation("Logging disabled");
│   │       │   67 │                 }
│   │       │   68 │             }
│   │       │   69 │             catch (Exception ex)
│   │       │   70 │             {
│   │       │   71 │                 _logger?.LogError(ex, "Error while {Action} logging", enable ? "enabling" : "disabling");
│   │       │   72 │                 Console.WriteLine($"Error {(enable ? "enabling" : "disabling")} logging: {ex.Message}");
│   │       │   73 │             }
│   │       │   74 │         }
│   │       │   75 │ 
│   │       │   76 │         public void SetLogLevel(LogEventLevel level)
│   │       │   77 │         {
│   │       │   78 │             try
│   │       │   79 │             {
│   │       │   80 │                 if (level == _currentLevel)
│   │       │   81 │                 {
│   │       │   82 │                     // No change in level, just return
│   │       │   83 │                     return;
│   │       │   84 │                 }
│   │       │   85 │ 
│   │       │   86 │                 _currentLevel = level;
│   │       │   87 │                 _logger?.LogInformation("Log level changed to {Level}", level);
│   │       │   88 │ 
│   │       │   89 │                 // Reconfigure the global logger with the new level
│   │       │   90 │                 ReconfigureGlobalLogger(_isEnabled);
│   │       │   91 │ 
│   │       │   92 │                 // Log directly to confirm level change
│   │       │   93 │                 Log.Write(level, "Log level changed to {Level}", level);
│   │       │   94 │             }
│   │       │   95 │             catch (Exception ex)
│   │       │   96 │             {
│   │       │   97 │                 _logger?.LogError(ex, "Error while setting log level to {Level}", level);
│   │       │   98 │                 Console.WriteLine($"Error setting log level: {ex.Message}");
│   │       │   99 │             }
│   │       │  100 │         }
│   │       │  101 │ 
│   │       │  102 │         private void ReconfigureGlobalLogger(bool includeFileSink)
│   │       │  103 │         {
│   │       │  104 │             try
│   │       │  105 │             {
│   │       │  106 │                 // Start with a clean configuration
│   │       │  107 │                 var loggerConfig = new LoggerConfiguration()
│   │       │  108 │                     .MinimumLevel.Is(_currentLevel)
│   │       │  109 │                     .WriteTo.Console()
│   │       │  110 │                     .WriteTo.Debug();
│   │       │  111 │ 
│   │       │  112 │                 // Add file sink if logging is enabled
│   │       │  113 │                 if (includeFileSink)
│   │       │  114 │                 {
│   │       │  115 │                     loggerConfig = loggerConfig.WriteTo.File(
│   │       │  116 │                         LogFilePath,
│   │       │  117 │                         rollingInterval: RollingInterval.Day,
│   │       │  118 │                         outputTemplate: "{Timestamp:yyyy-MM-dd HH:mm:ss.fff} [{Level:u3}] {Message:lj}{NewLine}{Exception}",
│   │       │  119 │                         shared: true);
│   │       │  120 │                 }
│   │       │  121 │ 
│   │       │  122 │                 // Set the global logger
│   │       │  123 │                 Log.Logger = loggerConfig.CreateLogger();
│   │       │  124 │             }
│   │       │  125 │             catch (Exception ex)
│   │       │  126 │             {
│   │       │  127 │                 _logger?.LogError(ex, "Failed to reconfigure global logger");
│   │       │  128 │                 Console.WriteLine($"Error configuring logger: {ex.Message}");
│   │       │  129 │             }
│   │       │  130 │         }
│   │       │  131 │ 
│   │       │  132 │         public void Dispose()
│   │       │  133 │         {
│   │       │  134 │             Dispose(true);
│   │       │  135 │             GC.SuppressFinalize(this);
│   │       │  136 │         }
│   │       │  137 │ 
│   │       │  138 │         protected virtual void Dispose(bool disposing)
│   │       │  139 │         {
│   │       │  140 │             if (!_disposed)
│   │       │  141 │             {
│   │       │  142 │                 if (disposing)
│   │       │  143 │                 {
│   │       │  144 │                     try
│   │       │  145 │                     {
│   │       │  146 │                         // Log disposing and flush
│   │       │  147 │                         Log.Information("LoggingService disposing at {Time}", DateTime.Now);
│   │       │  148 │                         Log.CloseAndFlush();
│   │       │  149 │                     }
│   │       │  150 │                     catch
│   │       │  151 │                     {
│   │       │  152 │                         // Ignore errors during disposal
│   │       │  153 │                     }
│   │       │  154 │                 }
│   │       │  155 │ 
│   │       │  156 │                 _disposed = true;
│   │       │  157 │             }
│   │       │  158 │         }
│   │       │  159 │     }
│   │       │  160 │ }
│   │       └──────────────────────────────────────────────────────────────────────
│   │   📁 Processing
│   │   └── 📄 ByteCodeProcessor.cs (3.80 KB, 2025-03-11 15:29:48)
│   │       ┌──────────────────────────────────────────────────────────────────────
│   │       │ FILE CONTENT: ByteCodeProcessor.cs
│   │       ├──────────────────────────────────────────────────────────────────────
│   │       │    1 │ ﻿using System;
│   │       │    2 │ using System.Text;
│   │       │    3 │ using Microsoft.Extensions.Logging;
│   │       │    4 │ 
│   │       │    5 │ namespace test.Infrastructure.Processing
│   │       │    6 │ {
│   │       │    7 │     /// <summary>
│   │       │    8 │     /// Utility class for processing ByteCode in controller objects
│   │       │    9 │     /// </summary>
│   │       │   10 │     public class ByteCodeProcessor
│   │       │   11 │     {
│   │       │   12 │         private readonly ILogger<ByteCodeProcessor> _logger;
│   │       │   13 │ 
│   │       │   14 │         public ByteCodeProcessor(ILogger<ByteCodeProcessor> logger)
│   │       │   15 │         {
│   │       │   16 │             _logger = logger ?? throw new ArgumentNullException(nameof(logger));
│   │       │   17 │         }
│   │       │   18 │ 
│   │       │   19 │         /// <summary>
│   │       │   20 │         /// Processes ByteCode by cleaning and normalizing it
│   │       │   21 │         /// </summary>
│   │       │   22 │         /// <param name="byteCode">The raw ByteCode to process</param>
│   │       │   23 │         /// <returns>Processed ByteCode or empty string if input is null or processing fails</returns>
│   │       │   24 │         public string ProcessByteCode(string byteCode)
│   │       │   25 │         {
│   │       │   26 │             if (string.IsNullOrEmpty(byteCode))
│   │       │   27 │             {
│   │       │   28 │                 return string.Empty;
│   │       │   29 │             }
│   │       │   30 │ 
│   │       │   31 │             try
│   │       │   32 │             {
│   │       │   33 │                 // Log large ByteCode for debugging
│   │       │   34 │                 if (byteCode.Length > 50000)
│   │       │   35 │                 {
│   │       │   36 │                     _logger.LogDebug("Processing large ByteCode, size: {ByteCodeLength} chars", byteCode.Length);
│   │       │   37 │                 }
│   │       │   38 │ 
│   │       │   39 │                 // Optimize string processing by reducing allocations
│   │       │   40 │                 var sb = new StringBuilder(byteCode.Length);
│   │       │   41 │ 
│   │       │   42 │                 // Process in one pass to reduce allocations
│   │       │   43 │                 foreach (var c in byteCode)
│   │       │   44 │                 {
│   │       │   45 │                     if (c == '\r')
│   │       │   46 │                     {
│   │       │   47 │                         // Skip carriage returns as we'll normalize to just newlines
│   │       │   48 │                         continue;
│   │       │   49 │                     }
│   │       │   50 │                     if (!char.IsControl(c) || c == '\n')
│   │       │   51 │                     {
│   │       │   52 │                         sb.Append(c);
│   │       │   53 │                     }
│   │       │   54 │                 }
│   │       │   55 │ 
│   │       │   56 │                 // Remove BOM and zero-width space at beginning and end
│   │       │   57 │                 var result = sb.ToString();
│   │       │   58 │                 if (result.Length > 0)
│   │       │   59 │                 {
│   │       │   60 │                     if (result[0] == '\uFEFF' || result[0] == '\u200B')
│   │       │   61 │                     {
│   │       │   62 │                         result = result.Substring(1);
│   │       │   63 │                     }
│   │       │   64 │                     if (result.Length > 0 && (result[result.Length - 1] == '\uFEFF' || result[result.Length - 1] == '\u200B'))
│   │       │   65 │                     {
│   │       │   66 │                         result = result.Substring(0, result.Length - 1);
│   │       │   67 │                     }
│   │       │   68 │                 }
│   │       │   69 │ 
│   │       │   70 │                 // Log processing results for large ByteCode
│   │       │   71 │                 if (byteCode.Length > 50000)
│   │       │   72 │                 {
│   │       │   73 │                     _logger.LogDebug("Finished processing large ByteCode, original size: {OriginalSize}, new size: {NewSize}",
│   │       │   74 │                         byteCode.Length, result.Length);
│   │       │   75 │                 }
│   │       │   76 │ 
│   │       │   77 │                 return string.IsNullOrEmpty(result) ? string.Empty : result;
│   │       │   78 │             }
│   │       │   79 │             catch (Exception ex)
│   │       │   80 │             {
│   │       │   81 │                 _logger.LogError(ex, "Error processing ByteCode: {ErrorMessage}", ex.Message);
│   │       │   82 │                 // Return empty string on error rather than crashing
│   │       │   83 │                 return string.Empty;
│   │       │   84 │             }
│   │       │   85 │         }
│   │       │   86 │ 
│   │       │   87 │         /// <summary>
│   │       │   88 │         /// Checks if the given object type is a ByteCode type
│   │       │   89 │         /// </summary>
│   │       │   90 │         /// <param name="objectType">The object type to check</param>
│   │       │   91 │         /// <returns>True if it's a ByteCode type, false otherwise</returns>
│   │       │   92 │         public static bool IsByteCodeType(string objectType)
│   │       │   93 │         {
│   │       │   94 │             if (string.IsNullOrEmpty(objectType))
│   │       │   95 │                 return false;
│   │       │   96 │ 
│   │       │   97 │             // Standard ByteCode types
│   │       │   98 │             return objectType.Equals("InfinityProgram", StringComparison.OrdinalIgnoreCase) ||
│   │       │   99 │                    objectType.Equals("InfinityFunction", StringComparison.OrdinalIgnoreCase);
│   │       │  100 │         }
│   │       │  101 │     }
│   │       │  102 │ }
│   │       └──────────────────────────────────────────────────────────────────────
│   │   📁 UI
│   │   │   📁 Converters
│   │   │   └── 📄 BoolToMarginConverter.cs (2.08 KB, 2025-03-12 07:55:51)
│   │   │       ┌──────────────────────────────────────────────────────────────────────
│   │   │       │ FILE CONTENT: BoolToMarginConverter.cs
│   │   │       ├──────────────────────────────────────────────────────────────────────
│   │   │       │    1 │ ﻿using Avalonia;
│   │   │       │    2 │ using Avalonia.Data.Converters;
│   │   │       │    3 │ using System;
│   │   │       │    4 │ using System.Globalization;
│   │   │       │    5 │ 
│   │   │       │    6 │ namespace test.Infrastructure.UI.Converters
│   │   │       │    7 │ {
│   │   │       │    8 │     /// <summary>
│   │   │       │    9 │     /// Converts a boolean value to a margin
│   │   │       │   10 │     /// </summary>
│   │   │       │   11 │     public class BoolToMarginConverter : IValueConverter
│   │   │       │   12 │     {
│   │   │       │   13 │         public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
│   │   │       │   14 │         {
│   │   │       │   15 │             return (bool)value ? new Thickness(250, 0, 0, 0) : new Thickness(50, 0, 0, 0);
│   │   │       │   16 │         }
│   │   │       │   17 │ 
│   │   │       │   18 │         public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
│   │   │       │   19 │         {
│   │   │       │   20 │             throw new NotImplementedException();
│   │   │       │   21 │         }
│   │   │       │   22 │     }
│   │   │       │   23 │ 
│   │   │       │   24 │     /// <summary>
│   │   │       │   25 │     /// Converts a boolean value to a prefix/suffix string
│   │   │       │   26 │     /// </summary>
│   │   │       │   27 │     public class BoolToPrefixSuffixConverter : IValueConverter
│   │   │       │   28 │     {
│   │   │       │   29 │         public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
│   │   │       │   30 │         {
│   │   │       │   31 │             if (value is bool isPrefix)
│   │   │       │   32 │             {
│   │   │       │   33 │                 return isPrefix ? "(Prefix)" : "(Suffix)";
│   │   │       │   34 │             }
│   │   │       │   35 │             return "(Suffix)";
│   │   │       │   36 │         }
│   │   │       │   37 │ 
│   │   │       │   38 │         public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
│   │   │       │   39 │         {
│   │   │       │   40 │             if (value is string strValue)
│   │   │       │   41 │             {
│   │   │       │   42 │                 return strValue.Contains("Prefix", StringComparison.OrdinalIgnoreCase);
│   │   │       │   43 │             }
│   │   │       │   44 │             return false;
│   │   │       │   45 │         }
│   │   │       │   46 │     }
│   │   │       │   47 │ 
│   │   │       │   48 │     /// <summary>
│   │   │       │   49 │     /// Subtracts an offset from a number
│   │   │       │   50 │     /// </summary>
│   │   │       │   51 │     public class NumberLessOffsetConverter : IValueConverter
│   │   │       │   52 │     {
│   │   │       │   53 │         public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
│   │   │       │   54 │         {
│   │   │       │   55 │             if (value is double width && parameter is string offset)
│   │   │       │   56 │             {
│   │   │       │   57 │                 return width - double.Parse(offset);
│   │   │       │   58 │             }
│   │   │       │   59 │             return value;
│   │   │       │   60 │         }
│   │   │       │   61 │ 
│   │   │       │   62 │         public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
│   │   │       │   63 │         {
│   │   │       │   64 │             throw new NotImplementedException();
│   │   │       │   65 │         }
│   │   │       │   66 │     }
│   │   │       │   67 │ }
│   │   │       └──────────────────────────────────────────────────────────────────────
│   │   ├── 📄 AvaloniaDialogService.cs (6.08 KB, 2025-03-12 11:30:34)
│   │   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │   │ FILE CONTENT: AvaloniaDialogService.cs
│   │   │   ├──────────────────────────────────────────────────────────────────────
│   │   │   │    1 │ ﻿using Avalonia.Controls;
│   │   │   │    2 │ using test.Core.Interfaces;
│   │   │   │    3 │ using test.Views;
│   │   │   │    4 │ using SukiUI.Controls;
│   │   │   │    5 │ using System.Collections.Generic;
│   │   │   │    6 │ using System.Threading.Tasks;
│   │   │   │    7 │ 
│   │   │   │    8 │ namespace test.Infrastructure.UI
│   │   │   │    9 │ {
│   │   │   │   10 │     /// <summary>
│   │   │   │   11 │     /// Avalonia implementation of the dialog service
│   │   │   │   12 │     /// </summary>
│   │   │   │   13 │     public class AvaloniaDialogService : IDialogService
│   │   │   │   14 │     {
│   │   │   │   15 │         private readonly Window _mainWindow;
│   │   │   │   16 │ 
│   │   │   │   17 │         /// <summary>
│   │   │   │   18 │         /// Creates a new Avalonia dialog service
│   │   │   │   19 │         /// </summary>
│   │   │   │   20 │         /// <param name="mainWindow">The main 
│   │   │   │   21 │         /// window</param>
│   │   │   │   22 │         public AvaloniaDialogService(Window mainWindow)
│   │   │   │   23 │         {
│   │   │   │   24 │             _mainWindow = mainWindow;
│   │   │   │   25 │         }
│   │   │   │   26 │ 
│   │   │   │   27 │         /// <summary>
│   │   │   │   28 │         /// Shows a file open dialog
│   │   │   │   29 │         /// </summary>
│   │   │   │   30 │         public async Task<string[]> ShowOpenFileDialogAsync(string title, IEnumerable<FileDialogFilter> filters, bool allowMultiple = false)
│   │   │   │   31 │         {
│   │   │   │   32 │             var dialog = new OpenFileDialog
│   │   │   │   33 │             {
│   │   │   │   34 │                 Title = title,
│   │   │   │   35 │                 AllowMultiple = allowMultiple,
│   │   │   │   36 │                 Filters = new List<FileDialogFilter>(filters)
│   │   │   │   37 │             };
│   │   │   │   38 │ 
│   │   │   │   39 │             return await dialog.ShowAsync(_mainWindow);
│   │   │   │   40 │         }
│   │   │   │   41 │ 
│   │   │   │   42 │         /// <summary>
│   │   │   │   43 │         /// Shows a file save dialog
│   │   │   │   44 │         /// </summary>
│   │   │   │   45 │         public async Task<string> ShowSaveFileDialogAsync(string title, string defaultExtension, IEnumerable<FileDialogFilter> filters)
│   │   │   │   46 │         {
│   │   │   │   47 │             var dialog = new SaveFileDialog
│   │   │   │   48 │             {
│   │   │   │   49 │                 Title = title,
│   │   │   │   50 │                 DefaultExtension = defaultExtension,
│   │   │   │   51 │                 Filters = new List<FileDialogFilter>(filters)
│   │   │   │   52 │             };
│   │   │   │   53 │ 
│   │   │   │   54 │             return await dialog.ShowAsync(_mainWindow);
│   │   │   │   55 │         }
│   │   │   │   56 │ 
│   │   │   │   57 │         /// <summary>
│   │   │   │   58 │         /// Shows a folder selection dialog
│   │   │   │   59 │         /// </summary>
│   │   │   │   60 │         public async Task<string> ShowOpenFolderDialogAsync(string title)
│   │   │   │   61 │         {
│   │   │   │   62 │             var dialog = new OpenFolderDialog
│   │   │   │   63 │             {
│   │   │   │   64 │                 Title = title
│   │   │   │   65 │             };
│   │   │   │   66 │ 
│   │   │   │   67 │             return await dialog.ShowAsync(_mainWindow);
│   │   │   │   68 │         }
│   │   │   │   69 │ 
│   │   │   │   70 │         /// <summary>
│   │   │   │   71 │         /// Shows a confirmation dialog
│   │   │   │   72 │         /// </summary>
│   │   │   │   73 │         public async Task<bool> ShowConfirmDialogAsync(string title, string message)
│   │   │   │   74 │         {
│   │   │   │   75 │             var dialog = new SukiWindow
│   │   │   │   76 │             {
│   │   │   │   77 │                 Title = title,
│   │   │   │   78 │                 Width = 400,
│   │   │   │   79 │                 Height = 180,
│   │   │   │   80 │                 WindowStartupLocation = WindowStartupLocation.CenterOwner
│   │   │   │   81 │             };
│   │   │   │   82 │ 
│   │   │   │   83 │             var panel = new StackPanel { Margin = new Avalonia.Thickness(20) };
│   │   │   │   84 │             panel.Children.Add(new TextBlock
│   │   │   │   85 │             {
│   │   │   │   86 │                 Text = message,
│   │   │   │   87 │                 TextWrapping = Avalonia.Media.TextWrapping.Wrap,
│   │   │   │   88 │                 Margin = new Avalonia.Thickness(0, 0, 0, 20)
│   │   │   │   89 │             });
│   │   │   │   90 │ 
│   │   │   │   91 │             var buttonPanel = new StackPanel
│   │   │   │   92 │             {
│   │   │   │   93 │                 Orientation = Avalonia.Layout.Orientation.Horizontal,
│   │   │   │   94 │                 HorizontalAlignment = Avalonia.Layout.HorizontalAlignment.Right,
│   │   │   │   95 │                 Spacing = 10
│   │   │   │   96 │             };
│   │   │   │   97 │ 
│   │   │   │   98 │             var cancelButton = new Button
│   │   │   │   99 │             {
│   │   │   │  100 │                 Content = "Cancel",
│   │   │   │  101 │                 Classes = { "Basic" },
│   │   │   │  102 │                 MinWidth = 80
│   │   │   │  103 │             };
│   │   │   │  104 │ 
│   │   │   │  105 │             var confirmButton = new Button
│   │   │   │  106 │             {
│   │   │   │  107 │                 Content = "Confirm",
│   │   │   │  108 │                 Classes = { "Accent" },
│   │   │   │  109 │                 MinWidth = 80
│   │   │   │  110 │             };
│   │   │   │  111 │ 
│   │   │   │  112 │             bool confirmed = false;
│   │   │   │  113 │ 
│   │   │   │  114 │             confirmButton.Click += (s, e) =>
│   │   │   │  115 │             {
│   │   │   │  116 │                 confirmed = true;
│   │   │   │  117 │                 dialog.Close();
│   │   │   │  118 │             };
│   │   │   │  119 │ 
│   │   │   │  120 │             cancelButton.Click += (s, e) =>
│   │   │   │  121 │             {
│   │   │   │  122 │                 dialog.Close();
│   │   │   │  123 │             };
│   │   │   │  124 │ 
│   │   │   │  125 │             buttonPanel.Children.Add(cancelButton);
│   │   │   │  126 │             buttonPanel.Children.Add(confirmButton);
│   │   │   │  127 │             panel.Children.Add(buttonPanel);
│   │   │   │  128 │ 
│   │   │   │  129 │             dialog.Content = new GlassCard
│   │   │   │  130 │             {
│   │   │   │  131 │                 Content = panel,
│   │   │   │  132 │                 Margin = new Avalonia.Thickness(10)
│   │   │   │  133 │             };
│   │   │   │  134 │ 
│   │   │   │  135 │             await dialog.ShowDialog(_mainWindow);
│   │   │   │  136 │             return confirmed;
│   │   │   │  137 │         }
│   │   │   │  138 │ 
│   │   │   │  139 │         /// <summary>
│   │   │   │  140 │         /// Shows an error dialog
│   │   │   │  141 │         /// </summary>
│   │   │   │  142 │         public async Task ShowErrorDialogAsync(string title, string message)
│   │   │   │  143 │         {
│   │   │   │  144 │             var dialog = new SukiWindow
│   │   │   │  145 │             {
│   │   │   │  146 │                 Title = title,
│   │   │   │  147 │                 Width = 400,
│   │   │   │  148 │                 Height = 180,
│   │   │   │  149 │                 WindowStartupLocation = WindowStartupLocation.CenterOwner
│   │   │   │  150 │             };
│   │   │   │  151 │ 
│   │   │   │  152 │             var panel = new StackPanel { Margin = new Avalonia.Thickness(20) };
│   │   │   │  153 │             panel.Children.Add(new TextBlock
│   │   │   │  154 │             {
│   │   │   │  155 │                 Text = message,
│   │   │   │  156 │                 TextWrapping = Avalonia.Media.TextWrapping.Wrap,
│   │   │   │  157 │                 Margin = new Avalonia.Thickness(0, 0, 0, 20)
│   │   │   │  158 │             });
│   │   │   │  159 │ 
│   │   │   │  160 │             var buttonPanel = new StackPanel
│   │   │   │  161 │             {
│   │   │   │  162 │                 Orientation = Avalonia.Layout.Orientation.Horizontal,
│   │   │   │  163 │                 HorizontalAlignment = Avalonia.Layout.HorizontalAlignment.Right
│   │   │   │  164 │             };
│   │   │   │  165 │ 
│   │   │   │  166 │             var okButton = new Button
│   │   │   │  167 │             {
│   │   │   │  168 │                 Content = "OK",
│   │   │   │  169 │                 Classes = { "Accent" },
│   │   │   │  170 │                 MinWidth = 80
│   │   │   │  171 │             };
│   │   │   │  172 │ 
│   │   │   │  173 │             okButton.Click += (s, e) => dialog.Close();
│   │   │   │  174 │             buttonPanel.Children.Add(okButton);
│   │   │   │  175 │             panel.Children.Add(buttonPanel);
│   │   │   │  176 │ 
│   │   │   │  177 │             dialog.Content = new GlassCard
│   │   │   │  178 │             {
│   │   │   │  179 │                 Content = panel,
│   │   │   │  180 │                 Margin = new Avalonia.Thickness(10)
│   │   │   │  181 │             };
│   │   │   │  182 │ 
│   │   │   │  183 │             await dialog.ShowDialog(_mainWindow);
│   │   │   │  184 │         }
│   │   │   │  185 │ 
│   │   │   │  186 │         /// <summary>
│   │   │   │  187 │         /// Shows a text input dialog
│   │   │   │  188 │         /// </summary>
│   │   │   │  189 │         public async Task<string> ShowInputDialogAsync(string title, string message, string defaultValue = "")
│   │   │   │  190 │         {
│   │   │   │  191 │             var inputDialog = new TextInputDialog
│   │   │   │  192 │             {
│   │   │   │  193 │                 Title = title,
│   │   │   │  194 │                 Message = message,
│   │   │   │  195 │                 DefaultValue = defaultValue
│   │   │   │  196 │             };
│   │   │   │  197 │ 
│   │   │   │  198 │             return await inputDialog.ShowAsync(_mainWindow);
│   │   │   │  199 │         }
│   │   │   │  200 │     }
│   │   │   │  201 │ }
│   │   │   └──────────────────────────────────────────────────────────────────────
│   │   └── 📄 AvaloniaNavigationService.cs (9.87 KB, 2025-03-12 15:13:47)
│   │       ┌──────────────────────────────────────────────────────────────────────
│   │       │ FILE CONTENT: AvaloniaNavigationService.cs
│   │       ├──────────────────────────────────────────────────────────────────────
│   │       │    1 │ ﻿using Avalonia.Controls;
│   │       │    2 │ using Avalonia.Threading;
│   │       │    3 │ using Microsoft.Extensions.DependencyInjection;
│   │       │    4 │ using Microsoft.Extensions.Logging;
│   │       │    5 │ using System;
│   │       │    6 │ using System.Collections.Generic;
│   │       │    7 │ using test.Core.Interfaces;
│   │       │    8 │ using test.ViewModels;
│   │       │    9 │ using test.Views;
│   │       │   10 │ 
│   │       │   11 │ namespace test.Infrastructure.UI
│   │       │   12 │ {
│   │       │   13 │     /// <summary>
│   │       │   14 │     /// Avalonia implementation of the navigation service
│   │       │   15 │     /// </summary>
│   │       │   16 │     public class AvaloniaNavigationService : INavigationService
│   │       │   17 │     {
│   │       │   18 │         private readonly ILogger<AvaloniaNavigationService> _logger;
│   │       │   19 │         private readonly IServiceProvider _serviceProvider;
│   │       │   20 │         private ContentControl _contentControl;
│   │       │   21 │         private readonly Window _window;
│   │       │   22 │         private readonly Dictionary<string, Type> _viewMappings = new();
│   │       │   23 │         private string _currentView;
│   │       │   24 │ 
│   │       │   25 │         /// <summary>
│   │       │   26 │         /// Gets the name of the currently active view
│   │       │   27 │         /// </summary>
│   │       │   28 │         public string CurrentView => _currentView;
│   │       │   29 │ 
│   │       │   30 │         /// <summary>
│   │       │   31 │         /// Event raised when navigation occurs
│   │       │   32 │         /// </summary>
│   │       │   33 │         public event EventHandler<NavigationEventArgs> Navigated;
│   │       │   34 │ 
│   │       │   35 │         /// <summary>
│   │       │   36 │         /// Creates a new Avalonia navigation service
│   │       │   37 │         /// </summary>
│   │       │   38 │         /// <param name="logger">The logger</param>
│   │       │   39 │         /// <param name="serviceProvider">The service provider</param>
│   │       │   40 │         /// <param name="window">The main window</param>
│   │       │   41 │         public AvaloniaNavigationService(
│   │       │   42 │             ILogger<AvaloniaNavigationService> logger,
│   │       │   43 │             IServiceProvider serviceProvider,
│   │       │   44 │             Window window)
│   │       │   45 │         {
│   │       │   46 │             _logger = logger ?? throw new ArgumentNullException(nameof(logger));
│   │       │   47 │             _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));
│   │       │   48 │             _window = window ?? throw new ArgumentNullException(nameof(window));
│   │       │   49 │ 
│   │       │   50 │             // Try to find the MainContent control immediately
│   │       │   51 │             _contentControl = _window.FindControl<ContentControl>("MainContent");
│   │       │   52 │ 
│   │       │   53 │             if (_contentControl == null)
│   │       │   54 │             {
│   │       │   55 │                 _logger.LogWarning("MainContent control not found during initialization, will try again later");
│   │       │   56 │ 
│   │       │   57 │                 // Schedule another attempt once the UI is loaded
│   │       │   58 │                 Dispatcher.UIThread.Post(() => {
│   │       │   59 │                     _contentControl = _window.FindControl<ContentControl>("MainContent");
│   │       │   60 │                     _logger.LogInformation("Second attempt to find MainContent: {Result}",
│   │       │   61 │                         _contentControl != null ? "Success" : "Failed");
│   │       │   62 │                 }, DispatcherPriority.Loaded);
│   │       │   63 │             }
│   │       │   64 │             else
│   │       │   65 │             {
│   │       │   66 │                 _logger.LogInformation("Successfully located MainContent control during initialization");
│   │       │   67 │             }
│   │       │   68 │ 
│   │       │   69 │             RegisterViews();
│   │       │   70 │         }
│   │       │   71 │ 
│   │       │   72 │         /// <summary>
│   │       │   73 │         /// Navigates to the specified view
│   │       │   74 │         /// </summary>
│   │       │   75 │         /// <param name="viewName">The name of the view to navigate to</param>
│   │       │   76 │         /// <param name="parameter">Optional parameter to pass to the view</param>
│   │       │   77 │         /// <returns>True if navigation was successful, false otherwise</returns>
│   │       │   78 │         public bool NavigateTo(string viewName, object parameter = null)
│   │       │   79 │         {
│   │       │   80 │             if (string.IsNullOrEmpty(viewName))
│   │       │   81 │             {
│   │       │   82 │                 _logger.LogWarning("Navigation attempted with null or empty view name");
│   │       │   83 │                 return false;
│   │       │   84 │             }
│   │       │   85 │ 
│   │       │   86 │             if (!CanNavigate(viewName))
│   │       │   87 │             {
│   │       │   88 │                 _logger.LogWarning("View {ViewName} is not registered", viewName);
│   │       │   89 │                 return false;
│   │       │   90 │             }
│   │       │   91 │ 
│   │       │   92 │             try
│   │       │   93 │             {
│   │       │   94 │                 _logger.LogDebug("Beginning navigation to {ViewName}", viewName);
│   │       │   95 │ 
│   │       │   96 │                 // Make one more attempt to find the content control if it wasn't found initially
│   │       │   97 │                 if (_contentControl == null)
│   │       │   98 │                 {
│   │       │   99 │                     _contentControl = _window.FindControl<ContentControl>("MainContent");
│   │       │  100 │                     _logger.LogDebug("Attempted to find MainContent during navigation: {Result}",
│   │       │  101 │                         _contentControl != null ? "Success" : "Failed");
│   │       │  102 │ 
│   │       │  103 │                     if (_contentControl == null)
│   │       │  104 │                     {
│   │       │  105 │                         _logger.LogError("Cannot navigate: MainContent control not found");
│   │       │  106 │                         return false;
│   │       │  107 │                     }
│   │       │  108 │                 }
│   │       │  109 │ 
│   │       │  110 │                 // Get the view type
│   │       │  111 │                 var viewType = _viewMappings[viewName];
│   │       │  112 │                 _logger.LogDebug("Creating view instance of type {ViewType}", viewType.Name);
│   │       │  113 │ 
│   │       │  114 │                 // Create view instance
│   │       │  115 │                 Control viewInstance;
│   │       │  116 │ 
│   │       │  117 │                 // Special handling for Settings view
│   │       │  118 │                 if (viewName == "Settings")
│   │       │  119 │                 {
│   │       │  120 │                     try
│   │       │  121 │                     {
│   │       │  122 │                         // Get both the view and view model from the service provider
│   │       │  123 │                         var settingsViewModel = _serviceProvider.GetService<SettingsViewModel>();
│   │       │  124 │ 
│   │       │  125 │                         if (settingsViewModel == null)
│   │       │  126 │                         {
│   │       │  127 │                             _logger.LogError("Failed to resolve SettingsViewModel from service provider");
│   │       │  128 │                         }
│   │       │  129 │ 
│   │       │  130 │                         // Try to get the Settings view from DI
│   │       │  131 │                         viewInstance = _serviceProvider.GetService<SettingsView>();
│   │       │  132 │ 
│   │       │  133 │                         if (viewInstance == null)
│   │       │  134 │                         {
│   │       │  135 │                             _logger.LogWarning("SettingsView could not be resolved from DI, creating manually");
│   │       │  136 │                             viewInstance = new SettingsView();
│   │       │  137 │                         }
│   │       │  138 │ 
│   │       │  139 │                         // Ensure the view has a view model
│   │       │  140 │                         if (settingsViewModel != null && viewInstance.DataContext == null)
│   │       │  141 │                         {
│   │       │  142 │                             viewInstance.DataContext = settingsViewModel;
│   │       │  143 │                             _logger.LogDebug("Assigned SettingsViewModel to SettingsView");
│   │       │  144 │                         }
│   │       │  145 │                     }
│   │       │  146 │                     catch (Exception ex)
│   │       │  147 │                     {
│   │       │  148 │                         _logger.LogError(ex, "Error creating SettingsView");
│   │       │  149 │                         viewInstance = new SettingsView(); // Fallback to creating it directly
│   │       │  150 │                     }
│   │       │  151 │                 }
│   │       │  152 │                 else
│   │       │  153 │                 {
│   │       │  154 │                     // For other views, create using ActivatorUtilities
│   │       │  155 │                     viewInstance = (Control)ActivatorUtilities.CreateInstance(_serviceProvider, viewType);
│   │       │  156 │                 }
│   │       │  157 │ 
│   │       │  158 │                 if (viewInstance == null)
│   │       │  159 │                 {
│   │       │  160 │                     _logger.LogError("Failed to create view instance for {ViewName}", viewName);
│   │       │  161 │                     return false;
│   │       │  162 │                 }
│   │       │  163 │ 
│   │       │  164 │                 // Update the content control on the UI thread
│   │       │  165 │                 Dispatcher.UIThread.Post(() =>
│   │       │  166 │                 {
│   │       │  167 │                     _logger?.LogDebug("Setting Content property of MainContent to {ViewType}", viewInstance.GetType().Name);
│   │       │  168 │ 
│   │       │  169 │                     // Get the MainViewModel from the window's DataContext
│   │       │  170 │                     if (_window.DataContext is MainViewModel mainViewModel)
│   │       │  171 │                     {
│   │       │  172 │                         // Update the view model's CurrentView property
│   │       │  173 │                         mainViewModel.CurrentView = viewInstance;
│   │       │  174 │                         _logger?.LogDebug("Updated MainViewModel.CurrentView to {ViewType}", viewInstance.GetType().Name);
│   │       │  175 │                     }
│   │       │  176 │                     else
│   │       │  177 │                     {
│   │       │  178 │                         // If we can't update the view model, set the content directly
│   │       │  179 │                         _contentControl.Content = viewInstance;
│   │       │  180 │                     }
│   │       │  181 │ 
│   │       │  182 │                     // Update current view
│   │       │  183 │                     _currentView = viewName;
│   │       │  184 │ 
│   │       │  185 │                     // Raise navigated event
│   │       │  186 │                     Navigated?.Invoke(this, new NavigationEventArgs(viewName, viewInstance));
│   │       │  187 │ 
│   │       │  188 │                     _logger?.LogInformation("Successfully navigated to {ViewName}", viewName);
│   │       │  189 │                 }, DispatcherPriority.Render);
│   │       │  190 │ 
│   │       │  191 │                 return true;
│   │       │  192 │             }
│   │       │  193 │             catch (Exception ex)
│   │       │  194 │             {
│   │       │  195 │                 _logger.LogError(ex, "Error navigating to view {ViewName}", viewName);
│   │       │  196 │                 return false;
│   │       │  197 │             }
│   │       │  198 │         }
│   │       │  199 │ 
│   │       │  200 │         /// <summary>
│   │       │  201 │         /// Checks if navigation to the specified view is possible
│   │       │  202 │         /// </summary>
│   │       │  203 │         /// <param name="viewName">The name of the view to check</param>
│   │       │  204 │         /// <returns>True if navigation is possible, false otherwise</returns>
│   │       │  205 │         public bool CanNavigate(string viewName)
│   │       │  206 │         {
│   │       │  207 │             return !string.IsNullOrEmpty(viewName) && _viewMappings.ContainsKey(viewName);
│   │       │  208 │         }
│   │       │  209 │ 
│   │       │  210 │         /// <summary>
│   │       │  211 │         /// Registers available views
│   │       │  212 │         /// </summary>
│   │       │  213 │         private void RegisterViews()
│   │       │  214 │         {
│   │       │  215 │             try
│   │       │  216 │             {
│   │       │  217 │                 // Register views
│   │       │  218 │                 _viewMappings.Add("Converters", typeof(test.Views.ConvertersView));
│   │       │  219 │ 
│   │       │  220 │                 // Add SettingsView with the correct type
│   │       │  221 │                 _viewMappings.Add("Settings", typeof(test.Views.SettingsView));
│   │       │  222 │ 
│   │       │  223 │                 // Use UserControl as fallback for other views
│   │       │  224 │                 _viewMappings.Add("Dashboard", typeof(UserControl));
│   │       │  225 │                 _viewMappings.Add("Projects", typeof(UserControl));
│   │       │  226 │                 _viewMappings.Add("Analysis", typeof(UserControl));
│   │       │  227 │                 _viewMappings.Add("Diff", typeof(UserControl));
│   │       │  228 │                 _viewMappings.Add("Databases", typeof(UserControl));
│   │       │  229 │                 _viewMappings.Add("Help", typeof(UserControl));
│   │       │  230 │                 _viewMappings.Add("Reports", typeof(UserControl));
│   │       │  231 │ 
│   │       │  232 │                 _logger.LogInformation("Registered {Count} views", _viewMappings.Count);
│   │       │  233 │             }
│   │       │  234 │             catch (Exception ex)
│   │       │  235 │             {
│   │       │  236 │                 _logger.LogError(ex, "Error registering views");
│   │       │  237 │             }
│   │       │  238 │         }
│   │       │  239 │     }
│   │       │  240 │ }
│   │       └──────────────────────────────────────────────────────────────────────
│   ├── 📄 AppBootstrapper.cs (3.11 KB, 2025-03-12 14:41:14)
│   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │ FILE CONTENT: AppBootstrapper.cs
│   │   ├──────────────────────────────────────────────────────────────────────
│   │   │    1 │ ﻿using Microsoft.Extensions.DependencyInjection;
│   │   │    2 │ using Microsoft.Extensions.Logging;
│   │   │    3 │ using Serilog;
│   │   │    4 │ using Serilog.Events;
│   │   │    5 │ using System;
│   │   │    6 │ using test.Core.Interfaces;
│   │   │    7 │ using test.Infrastructure;
│   │   │    8 │ using test.Core.Domain;
│   │   │    9 │ using test;
│   │   │   10 │ using test.Application.Services;
│   │   │   11 │ using test.ViewModels;
│   │   │   12 │ 
│   │   │   13 │ namespace test.Application
│   │   │   14 │ {
│   │   │   15 │     /// <summary>
│   │   │   16 │     /// Bootstrapper for the application
│   │   │   17 │     /// </summary>
│   │   │   18 │     public class AppBootstrapper
│   │   │   19 │     {
│   │   │   20 │         /// <summary>
│   │   │   21 │         /// The service provider
│   │   │   22 │         /// </summary>
│   │   │   23 │         public IServiceProvider ServiceProvider { get; private set; }
│   │   │   24 │ 
│   │   │   25 │         /// <summary>
│   │   │   26 │         /// Creates a new application bootstrapper
│   │   │   27 │         /// </summary>
│   │   │   28 │         public AppBootstrapper(Avalonia.Controls.Window mainWindow)
│   │   │   29 │         {
│   │   │   30 │             // Create service collection
│   │   │   31 │             var services = new ServiceCollection();
│   │   │   32 │             ConfigureServices(services, mainWindow);
│   │   │   33 │             ServiceProvider = services.BuildServiceProvider();
│   │   │   34 │         }
│   │   │   35 │ 
│   │   │   36 │         /// <summary>
│   │   │   37 │         /// Configures application services
│   │   │   38 │         /// </summary>
│   │   │   39 │         /// <param name="services">The service collection</param>
│   │   │   40 │         /// <param name="mainWindow">The main window</param>
│   │   │   41 │         private void ConfigureServices(IServiceCollection services, Avalonia.Controls.Window mainWindow)
│   │   │   42 │         {
│   │   │   43 │             // Initialize Serilog's global logger with just console & debug output
│   │   │   44 │             // This ensures logs appear immediately in the console/debug output
│   │   │   45 │             // The file logger will be added by LoggingService when enabled
│   │   │   46 │             Log.Logger = new LoggerConfiguration()
│   │   │   47 │                 .MinimumLevel.Debug() // Start with Debug level - LoggingService will adjust this
│   │   │   48 │                 .WriteTo.Console()
│   │   │   49 │                 .WriteTo.Debug()
│   │   │   50 │                 .CreateLogger();
│   │   │   51 │ 
│   │   │   52 │             // Configure logging
│   │   │   53 │             services.AddLogging(builder =>
│   │   │   54 │             {
│   │   │   55 │                 // Use Serilog for logging
│   │   │   56 │                 builder.AddSerilog(Log.Logger, dispose: false); // Don't dispose when container is disposed
│   │   │   57 │             });
│   │   │   58 │ 
│   │   │   59 │             // Register application services
│   │   │   60 │             services.AddApplicationServices();
│   │   │   61 │ 
│   │   │   62 │             // Register UI services
│   │   │   63 │             services.AddUIServices(mainWindow);
│   │   │   64 │ 
│   │   │   65 │             // Register view models
│   │   │   66 │             services.AddViewModels();
│   │   │   67 │         }
│   │   │   68 │ 
│   │   │   69 │         /// <summary>
│   │   │   70 │         /// Gets a service from the service provider
│   │   │   71 │         /// </summary>
│   │   │   72 │         /// <typeparam name="T">The service type</typeparam>
│   │   │   73 │         /// <returns>The service</returns>
│   │   │   74 │         public T GetService<T>() where T : class
│   │   │   75 │         {
│   │   │   76 │             return ServiceProvider.GetService<T>();
│   │   │   77 │         }
│   │   │   78 │ 
│   │   │   79 │         /// <summary>
│   │   │   80 │         /// Gets a required service from the service provider
│   │   │   81 │         /// </summary>
│   │   │   82 │         /// <typeparam name="T">The service type</typeparam>
│   │   │   83 │         /// <returns>The service</returns>
│   │   │   84 │         /// <exception cref="InvalidOperationException">Thrown if the service is not found</exception>
│   │   │   85 │         public T GetRequiredService<T>() where T : class
│   │   │   86 │         {
│   │   │   87 │             return ServiceProvider.GetRequiredService<T>();
│   │   │   88 │         }
│   │   │   89 │     }
│   │   │   90 │ }
│   │   └──────────────────────────────────────────────────────────────────────
│   ├── 📄 AppSettings.cs (1.81 KB, 2025-03-12 07:56:25)
│   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │ FILE CONTENT: AppSettings.cs
│   │   ├──────────────────────────────────────────────────────────────────────
│   │   │    1 │ ﻿using System;
│   │   │    2 │ 
│   │   │    3 │ namespace test.Infrastructure
│   │   │    4 │ {
│   │   │    5 │     /// <summary>
│   │   │    6 │     /// Application settings data model
│   │   │    7 │     /// </summary>
│   │   │    8 │     public class AppSettings
│   │   │    9 │     {
│   │   │   10 │         /// <summary>
│   │   │   11 │         /// Indicates if logging is enabled
│   │   │   12 │         /// </summary>
│   │   │   13 │         public bool EnableLogging { get; set; } = true;
│   │   │   14 │ 
│   │   │   15 │         /// <summary>
│   │   │   16 │         /// The log level as a string
│   │   │   17 │         /// </summary>
│   │   │   18 │         public string LogLevel { get; set; } = "Information";
│   │   │   19 │ 
│   │   │   20 │         /// <summary>
│   │   │   21 │         /// Indicates if logs should be deleted on exit
│   │   │   22 │         /// </summary>
│   │   │   23 │         public bool DeleteLogsOnExit { get; set; } = false;
│   │   │   24 │ 
│   │   │   25 │         /// <summary>
│   │   │   26 │         /// Indicates if the light theme is used
│   │   │   27 │         /// </summary>
│   │   │   28 │         public bool IsLightTheme { get; set; } = false;
│   │   │   29 │     }
│   │   │   30 │ 
│   │   │   31 │     /// <summary>
│   │   │   32 │     /// Interface for managing application settings
│   │   │   33 │     /// </summary>
│   │   │   34 │     public interface ISettingsManager
│   │   │   35 │     {
│   │   │   36 │         /// <summary>
│   │   │   37 │         /// Gets the current application settings
│   │   │   38 │         /// </summary>
│   │   │   39 │         /// <returns>The current settings</returns>
│   │   │   40 │         AppSettings GetCurrentSettings();
│   │   │   41 │ 
│   │   │   42 │         /// <summary>
│   │   │   43 │         /// Gets the path to the settings file
│   │   │   44 │         /// </summary>
│   │   │   45 │         /// <returns>The settings file path</returns>
│   │   │   46 │         string GetSettingsPath();
│   │   │   47 │ 
│   │   │   48 │         /// <summary>
│   │   │   49 │         /// Saves application settings
│   │   │   50 │         /// </summary>
│   │   │   51 │         /// <param name="settings">The settings to save</param>
│   │   │   52 │         /// <returns>A task that completes when settings are saved</returns>
│   │   │   53 │         System.Threading.Tasks.Task SaveSettingsAsync(AppSettings settings);
│   │   │   54 │ 
│   │   │   55 │         /// <summary>
│   │   │   56 │         /// Loads application settings
│   │   │   57 │         /// </summary>
│   │   │   58 │         /// <returns>The loaded settings</returns>
│   │   │   59 │         System.Threading.Tasks.Task<AppSettings> LoadSettingsAsync();
│   │   │   60 │     }
│   │   │   61 │ }
│   │   └──────────────────────────────────────────────────────────────────────
│   ├── 📄 ServiceCollectionExtensions.cs (4.45 KB, 2025-03-12 14:31:40)
│   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │ FILE CONTENT: ServiceCollectionExtensions.cs
│   │   ├──────────────────────────────────────────────────────────────────────
│   │   │    1 │ ﻿using Microsoft.Extensions.DependencyInjection;
│   │   │    2 │ using Microsoft.Extensions.Logging;
│   │   │    3 │ using Serilog.Core;
│   │   │    4 │ using System;
│   │   │    5 │ using test.Application.Services;
│   │   │    6 │ using test.Application.Services.Parsers;
│   │   │    7 │ using test.Application.Services.Writers;
│   │   │    8 │ using test.Core.Interfaces;
│   │   │    9 │ using test.Data;
│   │   │   10 │ using test.Infrastructure.Data;
│   │   │   11 │ using test.Infrastructure.FileSystem;
│   │   │   12 │ using test.Infrastructure.Logging;
│   │   │   13 │ using test.Infrastructure.Processing;
│   │   │   14 │ using test.Infrastructure.UI;
│   │   │   15 │ using test.ViewModels;
│   │   │   16 │ using Avalonia.Controls;
│   │   │   17 │ using test.Infrastructure;
│   │   │   18 │ using test.Views;
│   │   │   19 │ 
│   │   │   20 │ namespace test.Infrastructure
│   │   │   21 │ {
│   │   │   22 │     /// <summary>
│   │   │   23 │     /// Extensions for service collection to register application services
│   │   │   24 │     /// </summary>
│   │   │   25 │     public static class ServiceCollectionExtensions
│   │   │   26 │     {
│   │   │   27 │         /// <summary>
│   │   │   28 │         /// Registers all application services
│   │   │   29 │         /// </summary>
│   │   │   30 │         /// <param name="services">The service collection</param>
│   │   │   31 │         /// <returns>The service collection</returns>
│   │   │   32 │         public static IServiceCollection AddApplicationServices(this IServiceCollection services)
│   │   │   33 │         {
│   │   │   34 │             // Register infrastructure services
│   │   │   35 │             services.AddSingleton<IFileSystem, PhysicalFileSystem>();
│   │   │   36 │             services.AddSingleton<IErrorHandler, ApplicationErrorHandler>();
│   │   │   37 │             services.AddSingleton<ISettingsManager, SettingsManager>();
│   │   │   38 │             services.AddSingleton<ILoggingService, LoggingService>();
│   │   │   39 │ 
│   │   │   40 │             // Register ByteCode processor
│   │   │   41 │             services.AddSingleton<ByteCodeProcessor>();
│   │   │   42 │ 
│   │   │   43 │             // Register repositories
│   │   │   44 │             services.AddSingleton<ParserDbContext>();
│   │   │   45 │             services.AddSingleton<IControllerRepository, EfControllerRepository>();
│   │   │   46 │             services.AddSingleton<IProjectRepository, FileProjectRepository>();
│   │   │   47 │ 
│   │   │   48 │             // Register application services
│   │   │   49 │             services.AddTransient<ProjectService>();
│   │   │   50 │             services.AddTransient<ControllerService>();
│   │   │   51 │             services.AddTransient<ParsingService>();
│   │   │   52 │             services.AddTransient<IExportService, ExportService>();
│   │   │   53 │             services.AddTransient<IComparisonService, ComparisonService>();
│   │   │   54 │             services.AddSingleton<IControllerModelService, ControllerModelService>();
│   │   │   55 │ 
│   │   │   56 │             // Register ObjectSet parsers and writers
│   │   │   57 │             services.AddTransient<IObjectSetParser, ObjectSetParserImpl>();
│   │   │   58 │             services.AddTransient<IObjectSetWriter, ObjectSetWriterImpl>();
│   │   │   59 │ 
│   │   │   60 │             // Add the XML modification service
│   │   │   61 │             services.AddTransient<IXmlModificationService, XmlModificationService>();
│   │   │   62 │ 
│   │   │   63 │             return services;
│   │   │   64 │         }
│   │   │   65 │ 
│   │   │   66 │         /// <summary>
│   │   │   67 │         /// Registers UI-related services
│   │   │   68 │         /// </summary>
│   │   │   69 │         /// <param name="services">The service collection</param>
│   │   │   70 │         /// <param name="mainWindow">The main window</param>
│   │   │   71 │         /// <returns>The service collection</returns>
│   │   │   72 │         public static IServiceCollection AddUIServices(this IServiceCollection services, Window mainWindow)
│   │   │   73 │         {
│   │   │   74 │             // Register dialog service
│   │   │   75 │             services.AddSingleton<IDialogService>(provider =>
│   │   │   76 │                 new AvaloniaDialogService(mainWindow));
│   │   │   77 │ 
│   │   │   78 │             // Register navigation service
│   │   │   79 │             services.AddSingleton<INavigationService>(provider =>
│   │   │   80 │             {
│   │   │   81 │                 var logger = provider.GetRequiredService<ILogger<AvaloniaNavigationService>>();
│   │   │   82 │                 return new AvaloniaNavigationService(
│   │   │   83 │                     logger,
│   │   │   84 │                     provider,
│   │   │   85 │                     mainWindow);
│   │   │   86 │             });
│   │   │   87 │ 
│   │   │   88 │             return services;
│   │   │   89 │         }
│   │   │   90 │ 
│   │   │   91 │         /// <summary>
│   │   │   92 │         /// Registers view models
│   │   │   93 │         /// </summary>
│   │   │   94 │         /// <param name="services">The service collection</param>
│   │   │   95 │         /// <returns>The service collection</returns>
│   │   │   96 │         public static IServiceCollection AddViewModels(this IServiceCollection services)
│   │   │   97 │         {
│   │   │   98 │             // Main view model
│   │   │   99 │             services.AddSingleton<MainViewModel>();
│   │   │  100 │ 
│   │   │  101 │             // Settings view model - register as singleton to maintain state
│   │   │  102 │             services.AddSingleton<SettingsViewModel>();
│   │   │  103 │ 
│   │   │  104 │             // Register Settings view explicitly to ensure it can be resolved
│   │   │  105 │             services.AddTransient<SettingsView>();
│   │   │  106 │ 
│   │   │  107 │             // Feature view models
│   │   │  108 │             services.AddTransient<ProjectsViewModel>();
│   │   │  109 │             services.AddTransient<ObjectSetViewModel>();
│   │   │  110 │ 
│   │   │  111 │             // Add more view models as needed
│   │   │  112 │ 
│   │   │  113 │             return services;
│   │   │  114 │         }
│   │   │  115 │     }
│   │   │  116 │ }
│   │   └──────────────────────────────────────────────────────────────────────
│   ├── 📄 SettingsManager.cs (9.40 KB, 2025-03-12 14:46:39)
│   │   ┌──────────────────────────────────────────────────────────────────────
│   │   │ FILE CONTENT: SettingsManager.cs
│   │   ├──────────────────────────────────────────────────────────────────────
│   │   │    1 │ ﻿using Microsoft.Extensions.Logging;
│   │   │    2 │ using Serilog.Core;
│   │   │    3 │ using Serilog.Events;
│   │   │    4 │ using System;
│   │   │    5 │ using System.IO;
│   │   │    6 │ using System.Text.Json;
│   │   │    7 │ using System.Threading.Tasks;
│   │   │    8 │ using test.Core.Interfaces;
│   │   │    9 │ 
│   │   │   10 │ namespace test.Infrastructure
│   │   │   11 │ {
│   │   │   12 │     /// <summary>
│   │   │   13 │     /// Implementation of settings manager for application settings
│   │   │   14 │     /// </summary>
│   │   │   15 │     public class SettingsManager : ISettingsManager, IDisposable
│   │   │   16 │     {
│   │   │   17 │         private readonly ILogger<SettingsManager> _logger;
│   │   │   18 │         private readonly IFileSystem _fileSystem;
│   │   │   19 │         private AppSettings _currentSettings;
│   │   │   20 │         private readonly string _settingsPath;
│   │   │   21 │         private bool _disposed;
│   │   │   22 │ 
│   │   │   23 │         /// <summary>
│   │   │   24 │         /// Creates a new settings manager
│   │   │   25 │         /// </summary>
│   │   │   26 │         public SettingsManager(
│   │   │   27 │             ILogger<SettingsManager> logger,
│   │   │   28 │             IFileSystem fileSystem)
│   │   │   29 │         {
│   │   │   30 │             _logger = logger ?? throw new ArgumentNullException(nameof(logger));
│   │   │   31 │             _fileSystem = fileSystem ?? throw new ArgumentNullException(nameof(fileSystem));
│   │   │   32 │ 
│   │   │   33 │             // Determine settings path
│   │   │   34 │             var appDataFolder = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
│   │   │   35 │             var appFolder = Path.Combine(appDataFolder, "PaapeConversionKit");
│   │   │   36 │ 
│   │   │   37 │             // Ensure directory exists
│   │   │   38 │             _fileSystem.CreateDirectory(appFolder);
│   │   │   39 │ 
│   │   │   40 │             _settingsPath = Path.Combine(appFolder, "settings.json");
│   │   │   41 │ 
│   │   │   42 │             // Load or create default settings
│   │   │   43 │             _currentSettings = LoadSettings();
│   │   │   44 │ 
│   │   │   45 │             // Apply the settings immediately
│   │   │   46 │             ApplyInitialSettings();
│   │   │   47 │         }
│   │   │   48 │ 
│   │   │   49 │         /// <inheritdoc/>
│   │   │   50 │         public AppSettings GetCurrentSettings()
│   │   │   51 │         {
│   │   │   52 │             return _currentSettings;
│   │   │   53 │         }
│   │   │   54 │ 
│   │   │   55 │         /// <inheritdoc/>
│   │   │   56 │         public string GetSettingsPath()
│   │   │   57 │         {
│   │   │   58 │             return _settingsPath;
│   │   │   59 │         }
│   │   │   60 │ 
│   │   │   61 │         /// <inheritdoc/>
│   │   │   62 │         public async Task SaveSettingsAsync(AppSettings settings)
│   │   │   63 │         {
│   │   │   64 │             if (settings == null)
│   │   │   65 │                 throw new ArgumentNullException(nameof(settings));
│   │   │   66 │ 
│   │   │   67 │             try
│   │   │   68 │             {
│   │   │   69 │                 var json = JsonSerializer.Serialize(settings, new JsonSerializerOptions { WriteIndented = true });
│   │   │   70 │                 await _fileSystem.WriteAllTextAsync(_settingsPath, json);
│   │   │   71 │                 _currentSettings = settings;
│   │   │   72 │                 _logger.LogInformation("Settings saved successfully");
│   │   │   73 │             }
│   │   │   74 │             catch (Exception ex)
│   │   │   75 │             {
│   │   │   76 │                 _logger.LogError(ex, "Error saving settings");
│   │   │   77 │                 throw;
│   │   │   78 │             }
│   │   │   79 │         }
│   │   │   80 │ 
│   │   │   81 │         /// <inheritdoc/>
│   │   │   82 │         public async Task<AppSettings> LoadSettingsAsync()
│   │   │   83 │         {
│   │   │   84 │             try
│   │   │   85 │             {
│   │   │   86 │                 if (_fileSystem.FileExists(_settingsPath))
│   │   │   87 │                 {
│   │   │   88 │                     var json = await _fileSystem.ReadAllTextAsync(_settingsPath);
│   │   │   89 │                     var settings = JsonSerializer.Deserialize<AppSettings>(json);
│   │   │   90 │ 
│   │   │   91 │                     if (settings != null)
│   │   │   92 │                     {
│   │   │   93 │                         _currentSettings = settings;
│   │   │   94 │                         _logger.LogInformation("Settings loaded successfully");
│   │   │   95 │ 
│   │   │   96 │                         // Apply the loaded settings
│   │   │   97 │                         ApplySettings(_currentSettings);
│   │   │   98 │ 
│   │   │   99 │                         return settings;
│   │   │  100 │                     }
│   │   │  101 │                 }
│   │   │  102 │ 
│   │   │  103 │                 // If we get here, either the file doesn't exist or deserialization failed
│   │   │  104 │                 _logger.LogInformation("Creating default settings");
│   │   │  105 │                 _currentSettings = new AppSettings();
│   │   │  106 │                 await SaveSettingsAsync(_currentSettings);
│   │   │  107 │                 return _currentSettings;
│   │   │  108 │             }
│   │   │  109 │             catch (Exception ex)
│   │   │  110 │             {
│   │   │  111 │                 _logger.LogError(ex, "Error loading settings");
│   │   │  112 │                 _currentSettings = new AppSettings();
│   │   │  113 │                 return _currentSettings;
│   │   │  114 │             }
│   │   │  115 │         }
│   │   │  116 │ 
│   │   │  117 │         /// <summary>
│   │   │  118 │         /// Loads settings synchronously
│   │   │  119 │         /// </summary>
│   │   │  120 │         private AppSettings LoadSettings()
│   │   │  121 │         {
│   │   │  122 │             try
│   │   │  123 │             {
│   │   │  124 │                 if (_fileSystem.FileExists(_settingsPath))
│   │   │  125 │                 {
│   │   │  126 │                     using var stream = _fileSystem.OpenRead(_settingsPath);
│   │   │  127 │                     using var reader = new StreamReader(stream);
│   │   │  128 │                     var json = reader.ReadToEnd();
│   │   │  129 │                     var settings = JsonSerializer.Deserialize<AppSettings>(json);
│   │   │  130 │ 
│   │   │  131 │                     if (settings != null)
│   │   │  132 │                     {
│   │   │  133 │                         _logger.LogInformation("Settings loaded successfully");
│   │   │  134 │                         return settings;
│   │   │  135 │                     }
│   │   │  136 │                 }
│   │   │  137 │ 
│   │   │  138 │                 // If we get here, either the file doesn't exist or deserialization failed
│   │   │  139 │                 _logger.LogInformation("Creating default settings");
│   │   │  140 │                 return new AppSettings();
│   │   │  141 │             }
│   │   │  142 │             catch (Exception ex)
│   │   │  143 │             {
│   │   │  144 │                 _logger.LogError(ex, "Error loading settings");
│   │   │  145 │                 return new AppSettings();
│   │   │  146 │             }
│   │   │  147 │         }
│   │   │  148 │ 
│   │   │  149 │         /// <summary>
│   │   │  150 │         /// Applies initial settings after loading
│   │   │  151 │         /// </summary>
│   │   │  152 │         private void ApplyInitialSettings()
│   │   │  153 │         {
│   │   │  154 │             try
│   │   │  155 │             {
│   │   │  156 │                 ApplySettings(_currentSettings);
│   │   │  157 │             }
│   │   │  158 │             catch (Exception ex)
│   │   │  159 │             {
│   │   │  160 │                 _logger.LogError(ex, "Error applying initial settings");
│   │   │  161 │             }
│   │   │  162 │         }
│   │   │  163 │ 
│   │   │  164 │         /// <summary>
│   │   │  165 │         /// Applies settings to the system
│   │   │  166 │         /// </summary>
│   │   │  167 │         private void ApplySettings(AppSettings settings)
│   │   │  168 │         {
│   │   │  169 │             if (settings == null) return;
│   │   │  170 │ 
│   │   │  171 │             try
│   │   │  172 │             {
│   │   │  173 │                 // Get the logging service to apply log level
│   │   │  174 │                 var loggingService = GetLoggingService();
│   │   │  175 │                 if (loggingService != null)
│   │   │  176 │                 {
│   │   │  177 │                     // Apply log level if it can be parsed
│   │   │  178 │                     if (Enum.TryParse<LogEventLevel>(settings.LogLevel, out var level))
│   │   │  179 │                     {
│   │   │  180 │                         loggingService.SetLogLevel(level);
│   │   │  181 │                         _logger.LogDebug("Applied log level from settings: {Level}", level);
│   │   │  182 │                     }
│   │   │  183 │ 
│   │   │  184 │                     // Apply logging enabled setting
│   │   │  185 │                     loggingService.EnableLogging(settings.EnableLogging);
│   │   │  186 │                     _logger.LogDebug("Applied logging enabled from settings: {Enabled}", settings.EnableLogging);
│   │   │  187 │                 }
│   │   │  188 │             }
│   │   │  189 │             catch (Exception ex)
│   │   │  190 │             {
│   │   │  191 │                 _logger.LogError(ex, "Error applying settings");
│   │   │  192 │             }
│   │   │  193 │         }
│   │   │  194 │ 
│   │   │  195 │         /// <summary>
│   │   │  196 │         /// Gets the logging service from the global service provider
│   │   │  197 │         /// This is a fallback method to apply settings when the service isn't explicitly injected
│   │   │  198 │         /// </summary>
│   │   │  199 │         private ILoggingService GetLoggingService()
│   │   │  200 │         {
│   │   │  201 │             try
│   │   │  202 │             {
│   │   │  203 │                 // Try to get the logging service from the global App instance
│   │   │  204 │                 if (Avalonia.Application.Current is App app)
│   │   │  205 │                 {
│   │   │  206 │                     var serviceProvider = GetServiceProvider(app);
│   │   │  207 │                     if (serviceProvider != null)
│   │   │  208 │                     {
│   │   │  209 │                         return serviceProvider.GetService(typeof(ILoggingService)) as ILoggingService;
│   │   │  210 │                     }
│   │   │  211 │                 }
│   │   │  212 │             }
│   │   │  213 │             catch (Exception ex)
│   │   │  214 │             {
│   │   │  215 │                 _logger.LogError(ex, "Error getting logging service");
│   │   │  216 │             }
│   │   │  217 │ 
│   │   │  218 │             return null;
│   │   │  219 │         }
│   │   │  220 │ 
│   │   │  221 │         /// <summary>
│   │   │  222 │         /// Gets the service provider from the App instance
│   │   │  223 │         /// </summary>
│   │   │  224 │         private IServiceProvider GetServiceProvider(App app)
│   │   │  225 │         {
│   │   │  226 │             try
│   │   │  227 │             {
│   │   │  228 │                 // Use reflection to access the private _serviceProvider field
│   │   │  229 │                 var field = typeof(App).GetField("_serviceProvider",
│   │   │  230 │                     System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
│   │   │  231 │ 
│   │   │  232 │                 return field?.GetValue(app) as IServiceProvider;
│   │   │  233 │             }
│   │   │  234 │             catch (Exception ex)
│   │   │  235 │             {
│   │   │  236 │                 _logger.LogError(ex, "Error getting service provider");
│   │   │  237 │                 return null;
│   │   │  238 │             }
│   │   │  239 │         }
│   │   │  240 │ 
│   │   │  241 │         /// <summary>
│   │   │  242 │         /// Disposes resources
│   │   │  243 │         /// </summary>
│   │   │  244 │         public void Dispose()
│   │   │  245 │         {
│   │   │  246 │             Dispose(true);
│   │   │  247 │             GC.SuppressFinalize(this);
│   │   │  248 │         }
│   │   │  249 │ 
│   │   │  250 │         /// <summary>
│   │   │  251 │         /// Disposes resources
│   │   │  252 │         /// </summary>
│   │   │  253 │         /// <param name="disposing">True if disposing, false if finalizing</param>
│   │   │  254 │         protected virtual void Dispose(bool disposing)
│   │   │  255 │         {
│   │   │  256 │             if (!_disposed)
│   │   │  257 │             {
│   │   │  258 │                 if (disposing)
│   │   │  259 │                 {
│   │   │  260 │                     // Save settings if needed
│   │   │  261 │                     if (_currentSettings.DeleteLogsOnExit)
│   │   │  262 │                     {
│   │   │  263 │                         try
│   │   │  264 │                         {
│   │   │  265 │                             // Logic to delete logs would go here
│   │   │  266 │                             _logger.LogInformation("Cleaning up logs on exit");
│   │   │  267 │                         }
│   │   │  268 │                         catch (Exception ex)
│   │   │  269 │                         {
│   │   │  270 │                             _logger.LogError(ex, "Error cleaning up logs");
│   │   │  271 │                         }
│   │   │  272 │                     }
│   │   │  273 │                 }
│   │   │  274 │ 
│   │   │  275 │                 _disposed = true;
│   │   │  276 │             }
│   │   │  277 │         }
│   │   │  278 │     }
│   │   │  279 │ }
│   │   └──────────────────────────────────────────────────────────────────────
│   └── 📄 SukiThemeExtensions.cs (2.27 KB, 2025-03-12 12:50:28)
│       ┌──────────────────────────────────────────────────────────────────────
│       │ FILE CONTENT: SukiThemeExtensions.cs
│       ├──────────────────────────────────────────────────────────────────────
│       │    1 │ ﻿using Avalonia.Styling;
│       │    2 │ using SukiUI;
│       │    3 │ using SukiUI.Theme;
│       │    4 │ using System;
│       │    5 │ 
│       │    6 │ namespace test.Infrastructure
│       │    7 │ {
│       │    8 │     /// <summary>
│       │    9 │     /// Extension methods for SukiTheme to make theme operations more robust
│       │   10 │     /// </summary>
│       │   11 │     public static class SukiThemeExtensions
│       │   12 │     {
│       │   13 │         /// <summary>
│       │   14 │         /// Applies a theme change at both SukiTheme and application levels
│       │   15 │         /// </summary>
│       │   16 │         /// <param name="theme">The SukiTheme instance</param>
│       │   17 │         /// <param name="isLightTheme">Whether to use light theme</param>
│       │   18 │         public static void ApplyThemeChange(this SukiTheme theme, bool isLightTheme)
│       │   19 │         {
│       │   20 │             if (theme == null) return;
│       │   21 │ 
│       │   22 │             // First apply at SukiTheme level
│       │   23 │             theme.ChangeBaseTheme(isLightTheme ? ThemeVariant.Light : ThemeVariant.Dark);
│       │   24 │ 
│       │   25 │             // Also apply at application level for consistent theming
│       │   26 │             if (Avalonia.Application.Current != null)
│       │   27 │             {
│       │   28 │                 Avalonia.Application.Current.RequestedThemeVariant =
│       │   29 │                     isLightTheme ? ThemeVariant.Light : ThemeVariant.Dark;
│       │   30 │             }
│       │   31 │         }
│       │   32 │ 
│       │   33 │         /// <summary>
│       │   34 │         /// Gets the current theme setting as a boolean
│       │   35 │         /// </summary>
│       │   36 │         /// <param name="theme">The SukiTheme instance</param>
│       │   37 │         /// <returns>True if light theme, false if dark theme</returns>
│       │   38 │         public static bool IsLightTheme(this SukiTheme theme)
│       │   39 │         {
│       │   40 │             return theme?.ActiveBaseTheme == ThemeVariant.Light;
│       │   41 │         }
│       │   42 │ 
│       │   43 │         /// <summary>
│       │   44 │         /// Force applies the current application theme to SukiTheme
│       │   45 │         /// </summary>
│       │   46 │         /// <param name="theme">The SukiTheme instance</param>
│       │   47 │         public static void SyncWithApplicationTheme(this SukiTheme theme)
│       │   48 │         {
│       │   49 │             if (theme == null || Avalonia.Application.Current == null) return;
│       │   50 │ 
│       │   51 │             var appTheme = Avalonia.Application.Current.RequestedThemeVariant ?? ThemeVariant.Default;
│       │   52 │ 
│       │   53 │             // If app theme is default, don't change anything
│       │   54 │             if (appTheme == ThemeVariant.Default) return;
│       │   55 │ 
│       │   56 │             // Apply the app theme to SukiTheme if different
│       │   57 │             if (theme.ActiveBaseTheme != appTheme)
│       │   58 │             {
│       │   59 │                 theme.ChangeBaseTheme(appTheme);
│       │   60 │             }
│       │   61 │         }
│       │   62 │     }
│       │   63 │ }
│       └──────────────────────────────────────────────────────────────────────
├── 📄 App.axaml (1.44 KB, 2025-03-12 07:53:50)
│   ┌──────────────────────────────────────────────────────────────────────
│   │ FILE CONTENT: App.axaml
│   ├──────────────────────────────────────────────────────────────────────
│   │    1 │ <Application
│   │    2 │     x:Class="test.App"
│   │    3 │     xmlns="https://github.com/avaloniaui"
│   │    4 │     xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
│   │    5 │     xmlns:converters="clr-namespace:test.Infrastructure.UI.Converters"
│   │    6 │     xmlns:local="clr-namespace:test"
│   │    7 │     xmlns:materialIcons="clr-namespace:Material.Icons.Avalonia;assembly=Material.Icons.Avalonia"
│   │    8 │     xmlns:suki="using:SukiUI"
│   │    9 │     xmlns:sukiUi="clr-namespace:SukiUI;assembly=SukiUI"
│   │   10 │     xmlns:svg="clr-namespace:Avalonia.Svg.Skia;assembly=Avalonia.Svg.Skia"
│   │   11 │     xmlns:vm="clr-namespace:test.ViewModels"
│   │   12 │     RequestedThemeVariant="Default">
│   │   13 │ 
│   │   14 │     <Application.Resources>
│   │   15 │         <local:ViewLocator x:Key="ViewLocator" />
│   │   16 │     </Application.Resources>
│   │   17 │ 
│   │   18 │     <Application.DataTemplates>
│   │   19 │         <DataTemplate DataType="{x:Type vm:ViewModelBase}">
│   │   20 │             <ContentControl Content="{Binding}">
│   │   21 │                 <ContentControl.ContentTemplate>
│   │   22 │                     <StaticResource ResourceKey="ViewLocator" />
│   │   23 │                 </ContentControl.ContentTemplate>
│   │   24 │             </ContentControl>
│   │   25 │         </DataTemplate>
│   │   26 │     </Application.DataTemplates>
│   │   27 │ 
│   │   28 │     <Application.Styles>
│   │   29 │         <materialIcons:MaterialIconStyles />
│   │   30 │         <suki:SukiTheme ThemeColor="Orange" />
│   │   31 │ 
│   │   32 │         <!--  Add default padding to all UserControls in the Views namespace  -->
│   │   33 │         <Style Selector="UserControl">
│   │   34 │             <Setter Property="Padding" Value="20" />
│   │   35 │         </Style>
│   │   36 │     </Application.Styles>
│   │   37 │ </Application>
│   └──────────────────────────────────────────────────────────────────────
├── 📄 App.axaml.cs (4.96 KB, 2025-03-12 15:18:44)
│   ┌──────────────────────────────────────────────────────────────────────
│   │ FILE CONTENT: App.axaml.cs
│   ├──────────────────────────────────────────────────────────────────────
│   │    1 │ using Avalonia;
│   │    2 │ using Avalonia.Controls.ApplicationLifetimes;
│   │    3 │ using Avalonia.Markup.Xaml;
│   │    4 │ using Microsoft.Extensions.DependencyInjection;
│   │    5 │ using Microsoft.Extensions.Logging;
│   │    6 │ using System;
│   │    7 │ using Avalonia.Styling;
│   │    8 │ using System.Diagnostics;
│   │    9 │ using test.Infrastructure;
│   │   10 │ using test.ViewModels;
│   │   11 │ using test.Views;
│   │   12 │ using SukiUI;
│   │   13 │ using test.Application.Services;
│   │   14 │ using SukiUI.Theme;
│   │   15 │ using SukiUI.Dialogs;
│   │   16 │ using test.Application;
│   │   17 │ using test.Core.Interfaces;
│   │   18 │ 
│   │   19 │ namespace test
│   │   20 │ {
│   │   21 │     public partial class App : Avalonia.Application
│   │   22 │     {
│   │   23 │         private IServiceProvider? _serviceProvider;
│   │   24 │ 
│   │   25 │         public override void Initialize()
│   │   26 │         {
│   │   27 │             AvaloniaXamlLoader.Load(this);
│   │   28 │         }
│   │   29 │ 
│   │   30 │         public override void OnFrameworkInitializationCompleted()
│   │   31 │         {
│   │   32 │             if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
│   │   33 │             {
│   │   34 │                 try
│   │   35 │                 {
│   │   36 │                     Trace.WriteLine("Creating main window");
│   │   37 │ 
│   │   38 │                     // Create temporary window for bootstrapping
│   │   39 │                     var tempWindow = new MainWindow();
│   │   40 │ 
│   │   41 │                     // Create application bootstrapper with the temporary window
│   │   42 │                     var bootstrapper = new AppBootstrapper(tempWindow);
│   │   43 │                     _serviceProvider = bootstrapper.ServiceProvider;
│   │   44 │ 
│   │   45 │                     // Initialize logging explicitly at startup
│   │   46 │                     var loggingService = _serviceProvider.GetRequiredService<ILoggingService>();
│   │   47 │                     loggingService.EnableLogging(true);
│   │   48 │ 
│   │   49 │                     // Log application startup
│   │   50 │                     var logger = _serviceProvider.GetRequiredService<ILogger<App>>();
│   │   51 │                     logger.LogInformation("Application starting up");
│   │   52 │ 
│   │   53 │                     // Initialize theme BEFORE creating MainWindow DataContext
│   │   54 │                     InitializeTheme();
│   │   55 │ 
│   │   56 │                     // Get MainViewModel from service provider
│   │   57 │                     var mainViewModel = _serviceProvider.GetRequiredService<MainViewModel>();
│   │   58 │                     logger.LogInformation("Created MainViewModel: {ViewModel}",
│   │   59 │                         mainViewModel != null ? "Success" : "Failed");
│   │   60 │ 
│   │   61 │                     // Create the main window
│   │   62 │                     desktop.MainWindow = new MainWindow(
│   │   63 │                         _serviceProvider.GetService<ILogger<MainWindow>>())
│   │   64 │                     {
│   │   65 │                         DataContext = mainViewModel
│   │   66 │                     };
│   │   67 │ 
│   │   68 │                     logger.LogInformation("Main window created with ViewModel");
│   │   69 │ 
│   │   70 │                     desktop.Exit += OnApplicationExit;
│   │   71 │                 }
│   │   72 │                 catch (Exception ex)
│   │   73 │                 {
│   │   74 │                     Trace.WriteLine($"Error in application initialization: {ex}");
│   │   75 │ 
│   │   76 │                     // Create a minimal main window if initialization fails
│   │   77 │                     if (desktop.MainWindow == null)
│   │   78 │                     {
│   │   79 │                         desktop.MainWindow = new MainWindow();
│   │   80 │                     }
│   │   81 │                 }
│   │   82 │             }
│   │   83 │ 
│   │   84 │             base.OnFrameworkInitializationCompleted();
│   │   85 │             Trace.WriteLine("App initialized");
│   │   86 │         }
│   │   87 │ 
│   │   88 │         private void InitializeTheme()
│   │   89 │         {
│   │   90 │             try
│   │   91 │             {
│   │   92 │                 var settingsManager = _serviceProvider?.GetService<ISettingsManager>();
│   │   93 │                 if (settingsManager != null)
│   │   94 │                 {
│   │   95 │                     var settings = settingsManager.GetCurrentSettings();
│   │   96 │                     var theme = SukiTheme.GetInstance();
│   │   97 │ 
│   │   98 │                     Trace.WriteLine($"Initializing Theme: IsLightTheme={settings.IsLightTheme}");
│   │   99 │ 
│   │  100 │                     // Force theme change
│   │  101 │                     theme.ChangeBaseTheme(settings.IsLightTheme ? ThemeVariant.Light : ThemeVariant.Dark);
│   │  102 │ 
│   │  103 │                     // Ensure theme change is applied
│   │  104 │                     Current.RequestedThemeVariant = settings.IsLightTheme ? ThemeVariant.Light : ThemeVariant.Dark;
│   │  105 │                 }
│   │  106 │                 else
│   │  107 │                 {
│   │  108 │                     Trace.WriteLine("Warning: SettingsManager not available during theme initialization");
│   │  109 │                 }
│   │  110 │             }
│   │  111 │             catch (Exception ex)
│   │  112 │             {
│   │  113 │                 Trace.WriteLine($"Error initializing theme: {ex}");
│   │  114 │             }
│   │  115 │         }
│   │  116 │ 
│   │  117 │         private void OnApplicationExit(object? sender, ControlledApplicationLifetimeExitEventArgs e)
│   │  118 │         {
│   │  119 │             if (_serviceProvider != null)
│   │  120 │             {
│   │  121 │                 var settingsManager = _serviceProvider.GetService<ISettingsManager>();
│   │  122 │                 if (settingsManager is IDisposable disposable)
│   │  123 │                 {
│   │  124 │                     disposable.Dispose();
│   │  125 │                 }
│   │  126 │ 
│   │  127 │                 // Also dispose logging service
│   │  128 │                 var loggingService = _serviceProvider.GetService<ILoggingService>();
│   │  129 │                 if (loggingService is IDisposable loggingDisposable)
│   │  130 │                 {
│   │  131 │                     loggingDisposable.Dispose();
│   │  132 │                 }
│   │  133 │             }
│   │  134 │         }
│   │  135 │     }
│   │  136 │ 
│   │  137 │ }
│   └──────────────────────────────────────────────────────────────────────
├── 📄 MainWindow.axaml (7.02 KB, 2025-03-12 15:11:51)
│   ┌──────────────────────────────────────────────────────────────────────
│   │ FILE CONTENT: MainWindow.axaml
│   ├──────────────────────────────────────────────────────────────────────
│   │    1 │ <sukiUi:SukiWindow
│   │    2 │     x:Class="test.MainWindow"
│   │    3 │     xmlns="https://github.com/avaloniaui"
│   │    4 │     xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
│   │    5 │     xmlns:converters="clr-namespace:test.Infrastructure.UI.Converters"
│   │    6 │     xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
│   │    7 │     xmlns:materialIcons="using:Material.Icons.Avalonia"
│   │    8 │     xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
│   │    9 │     xmlns:models="using:test.Core.Domain"
│   │   10 │     xmlns:suki="using:SukiUI.Controls"
│   │   11 │     xmlns:sukiUi="using:SukiUI.Controls"
│   │   12 │     xmlns:vm="using:test.ViewModels"
│   │   13 │     Title="Paape Conversion Kit"
│   │   14 │     Width="1200"
│   │   15 │     Height="900"
│   │   16 │     d:DesignHeight="800"
│   │   17 │     d:DesignWidth="1200"
│   │   18 │     x:DataType="vm:MainViewModel"
│   │   19 │     ExtendClientAreaToDecorationsHint="True"
│   │   20 │     WindowStartupLocation="CenterScreen"
│   │   21 │     mc:Ignorable="d">
│   │   22 │     <Window.Resources>
│   │   23 │         <!--  We'll create the converter below  -->
│   │   24 │         <converters:BoolToMarginConverter x:Key="BoolToMarginConverter" />
│   │   25 │     </Window.Resources>
│   │   26 │ 
│   │   27 │     <sukiUi:SukiWindow.Hosts>
│   │   28 │         <sukiUi:SukiDialogHost Name="DialogHost" />
│   │   29 │     </sukiUi:SukiWindow.Hosts>
│   │   30 │ 
│   │   31 │     <sukiUi:SukiWindow.LogoContent>
│   │   32 │         <Viewbox
│   │   33 │             Width="24"
│   │   34 │             Height="24"
│   │   35 │             VerticalAlignment="Center">
│   │   36 │             <Canvas Width="200" Height="168">
│   │   37 │                 <Path Data="M 90.662158 22.881994 A 89.771187 68.461014 0 0 0 0.89110804 91.342931 A 89.771187 68.461014 0 0 0 56.259029 154.43882 A 89.771187 68.461014 0 0 1 43.333252 145.43627 L 145.64053 145.43627 A 89.771187 68.461014 0 0 1 90.662158 159.80387 A 89.771187 68.461014 0 0 1 56.2590...
│   │   38 │                     <Path.Transitions>
│   │   39 │                         <Transitions>
│   │   40 │                             <BrushTransition Property="Fill" Duration="{DynamicResource ShortAnimationDuration}" />
│   │   41 │                         </Transitions>
│   │   42 │                     </Path.Transitions>
│   │   43 │                 </Path>
│   │   44 │             </Canvas>
│   │   45 │         </Viewbox>
│   │   46 │     </sukiUi:SukiWindow.LogoContent>
│   │   47 │     <Grid>
│   │   48 │         <suki:SukiSideMenu
│   │   49 │             x:Name="SideMenu"
│   │   50 │             IsSearchEnabled="False"
│   │   51 │             IsSelectedItemContentMovable="True"
│   │   52 │             IsToggleButtonVisible="True"
│   │   53 │             ItemsSource="{Binding MenuItems}"
│   │   54 │             OpenPaneLength="250"
│   │   55 │             SelectedItem="{Binding SelectedMenuItem, Mode=TwoWay}"
│   │   56 │             SelectionChanged="SukiSideMenu_SelectionChanged">
│   │   57 │ 
│   │   58 │             <suki:SukiSideMenu.ItemTemplate>
│   │   59 │                 <DataTemplate>
│   │   60 │                     <suki:SukiSideMenuItem
│   │   61 │                         Classes="Compact"
│   │   62 │                         Header="{Binding Header}"
│   │   63 │                         IsTopMenuExpanded="True"
│   │   64 │                         ToolTip.Tip="{Binding Header}">
│   │   65 │                         <suki:SukiSideMenuItem.Icon>
│   │   66 │                             <materialIcons:MaterialIcon Kind="{Binding Icon}" />
│   │   67 │                         </suki:SukiSideMenuItem.Icon>
│   │   68 │                     </suki:SukiSideMenuItem>
│   │   69 │                 </DataTemplate>
│   │   70 │             </suki:SukiSideMenu.ItemTemplate>
│   │   71 │ 
│   │   72 │             <suki:SukiSideMenu.HeaderContent>
│   │   73 │                 <StackPanel Margin="30,20" HorizontalAlignment="Center">
│   │   74 │                     <Grid>
│   │   75 │                         <Ellipse
│   │   76 │                             Width="120"
│   │   77 │                             Height="120"
│   │   78 │                             Opacity="0.1">
│   │   79 │                             <Ellipse.Fill>
│   │   80 │                                 <RadialGradientBrush>
│   │   81 │                                     <GradientStop Offset="0" Color="{DynamicResource SukiPrimaryColor}" />
│   │   82 │                                     <GradientStop Offset="1" Color="Transparent" />
│   │   83 │                                 </RadialGradientBrush>
│   │   84 │                             </Ellipse.Fill>
│   │   85 │                             <Ellipse.Effect>
│   │   86 │                                 <BlurEffect Radius="8" />
│   │   87 │                             </Ellipse.Effect>
│   │   88 │                             <Ellipse.Transitions>
│   │   89 │                                 <Transitions>
│   │   90 │                                     <BrushTransition Property="Fill" Duration="{DynamicResource ShortAnimationDuration}" />
│   │   91 │                                 </Transitions>
│   │   92 │                             </Ellipse.Transitions>
│   │   93 │                         </Ellipse>
│   │   94 │                         <TextBlock
│   │   95 │                             HorizontalAlignment="Center"
│   │   96 │                             VerticalAlignment="Center"
│   │   97 │                             FontSize="42"
│   │   98 │                             FontWeight="Bold"
│   │   99 │                             Foreground="{DynamicResource SukiPrimaryColor}"
│   │  100 │                             Text="PCK" />
│   │  101 │                     </Grid>
│   │  102 │                     <TextBlock
│   │  103 │                         Margin="0,10,0,0"
│   │  104 │                         HorizontalAlignment="Center"
│   │  105 │                         FontSize="16"
│   │  106 │                         Text="Paape Tools" />
│   │  107 │                 </StackPanel>
│   │  108 │             </suki:SukiSideMenu.HeaderContent>
│   │  109 │ 
│   │  110 │             <suki:SukiSideMenu.FooterContent>
│   │  111 │                 <StackPanel
│   │  112 │                     Margin="0,10"
│   │  113 │                     HorizontalAlignment="Center"
│   │  114 │                     Orientation="Horizontal"
│   │  115 │                     Spacing="10">
│   │  116 │                     <Button Classes="Basic">
│   │  117 │                         <materialIcons:MaterialIcon Kind="Settings" />
│   │  118 │                     </Button>
│   │  119 │                     <Button Classes="Basic">
│   │  120 │                         <materialIcons:MaterialIcon Kind="Help" />
│   │  121 │                     </Button>
│   │  122 │                 </StackPanel>
│   │  123 │             </suki:SukiSideMenu.FooterContent>
│   │  124 │         </suki:SukiSideMenu>
│   │  125 │ 
│   │  126 │         <ContentControl
│   │  127 │             x:Name="MainContent"
│   │  128 │             Grid.Column="1"
│   │  129 │             Margin="{Binding ElementName=SideMenu, Path=IsMenuExpanded, Converter={StaticResource BoolToMarginConverter}}">
│   │  130 │             <ContentControl.Transitions>
│   │  131 │                 <Transitions>
│   │  132 │                     <ThicknessTransition
│   │  133 │                         Easing="QuadraticEaseInOut"
│   │  134 │                         Property="Margin"
│   │  135 │                         Duration="0:0:0.2" />
│   │  136 │                 </Transitions>
│   │  137 │             </ContentControl.Transitions>
│   │  138 │         </ContentControl>
│   │  139 │     </Grid>
│   │  140 │ </sukiUi:SukiWindow>
│   └──────────────────────────────────────────────────────────────────────
├── 📄 MainWindow.axaml.cs (7.88 KB, 2025-03-12 15:18:53)
│   ┌──────────────────────────────────────────────────────────────────────
│   │ FILE CONTENT: MainWindow.axaml.cs
│   ├──────────────────────────────────────────────────────────────────────
│   │    1 │ using Avalonia;
│   │    2 │ using Avalonia.Controls;
│   │    3 │ using Avalonia.Markup.Xaml;
│   │    4 │ using test.ViewModels;
│   │    5 │ using SukiUI.Controls;
│   │    6 │ using SukiUI.Theme;
│   │    7 │ using SukiUI;
│   │    8 │ using System;
│   │    9 │ using Microsoft.Extensions.Logging;
│   │   10 │ 
│   │   11 │ namespace test
│   │   12 │ {
│   │   13 │     public partial class MainWindow : SukiWindow
│   │   14 │     {
│   │   15 │         private readonly ILogger<MainWindow> _logger;
│   │   16 │ 
│   │   17 │         // Add parameterless constructor for design-time
│   │   18 │         public MainWindow()
│   │   19 │         {
│   │   20 │             InitializeComponent();
│   │   21 │ #if DEBUG
│   │   22 │             this.AttachDevTools();
│   │   23 │ #endif
│   │   24 │             if (Design.IsDesignMode)
│   │   25 │             {
│   │   26 │                 // Set design-time DataContext
│   │   27 │                 DataContext = new MainViewModel();
│   │   28 │             }
│   │   29 │ 
│   │   30 │             // Initialize theme
│   │   31 │             SukiTheme.GetInstance().SwitchBaseTheme();
│   │   32 │         }
│   │   33 │ 
│   │   34 │         // Constructor that can accept a logger if available
│   │   35 │         public MainWindow(ILogger<MainWindow> logger = null)
│   │   36 │         {
│   │   37 │             _logger = logger;
│   │   38 │ 
│   │   39 │             try
│   │   40 │             {
│   │   41 │                 InitializeComponent();
│   │   42 │ #if DEBUG
│   │   43 │                 this.AttachDevTools();
│   │   44 │ #endif
│   │   45 │                 // Initialize theme
│   │   46 │                 SukiTheme.GetInstance().SwitchBaseTheme();
│   │   47 │ 
│   │   48 │                 // Log that the window was initialized
│   │   49 │                 _logger?.LogInformation("MainWindow initialized");
│   │   50 │ 
│   │   51 │                 // Ensure ApplicationLifetime is initialized before calling TestSettingsView
│   │   52 │                 if (App.Current?.ApplicationLifetime != null)
│   │   53 │                 {
│   │   54 │                     TestSettingsView();  // Uncomment this line to test
│   │   55 │                 }
│   │   56 │                 else
│   │   57 │                 {
│   │   58 │                     _logger?.LogError("ApplicationLifetime is not initialized!");
│   │   59 │                 }
│   │   60 │             }
│   │   61 │             catch (Exception ex)
│   │   62 │             {
│   │   63 │                 _logger?.LogError(ex, "Error initializing MainWindow");
│   │   64 │             }
│   │   65 │         }
│   │   66 │ 
│   │   67 │ 
│   │   68 │         protected override void OnDataContextChanged(EventArgs e)
│   │   69 │         {
│   │   70 │             base.OnDataContextChanged(e);
│   │   71 │             _logger?.LogInformation("MainWindow DataContext changed to: {Type}",
│   │   72 │                 DataContext?.GetType().Name ?? "null");
│   │   73 │         }
│   │   74 │ 
│   │   75 │         private void SukiSideMenu_SelectionChanged(object? sender, SelectionChangedEventArgs e)
│   │   76 │         {
│   │   77 │             try
│   │   78 │             {
│   │   79 │                 var viewModel = DataContext as MainViewModel;
│   │   80 │                 _logger?.LogDebug("SukiSideMenu_SelectionChanged event triggered. ViewModel: {ViewModel}",
│   │   81 │                     viewModel != null ? "Available" : "Null");
│   │   82 │ 
│   │   83 │                 if (viewModel?.MenuItemSelectedCommand != null && e.AddedItems.Count > 0)
│   │   84 │                 {
│   │   85 │                     _logger?.LogDebug("Executing MenuItemSelectedCommand with {Item}", e.AddedItems[0]);
│   │   86 │                     viewModel.MenuItemSelectedCommand.Execute(e.AddedItems[0]);
│   │   87 │                 }
│   │   88 │                 else
│   │   89 │                 {
│   │   90 │                     _logger?.LogWarning("Could not execute MenuItemSelectedCommand: {Reason}",
│   │   91 │                         viewModel == null ? "ViewModel is null" :
│   │   92 │                         viewModel.MenuItemSelectedCommand == null ? "Command is null" :
│   │   93 │                         e.AddedItems.Count == 0 ? "No items selected" : "Unknown reason");
│   │   94 │                 }
│   │   95 │             }
│   │   96 │             catch (Exception ex)
│   │   97 │             {
│   │   98 │                 _logger?.LogError(ex, "Error in SukiSideMenu_SelectionChanged");
│   │   99 │             }
│   │  100 │         }
│   │  101 │ 
│   │  102 │         private void InitializeComponent()
│   │  103 │         {
│   │  104 │             try
│   │  105 │             {
│   │  106 │                 AvaloniaXamlLoader.Load(this);
│   │  107 │                 _logger?.LogDebug("MainWindow component initialized successfully");
│   │  108 │ 
│   │  109 │                 // Check if MainContent was found
│   │  110 │                 var mainContent = this.FindControl<ContentControl>("MainContent");
│   │  111 │                 _logger?.LogInformation("MainContent control {Status}",
│   │  112 │                     mainContent != null ? "found" : "not found");
│   │  113 │ 
│   │  114 │                 // Check if SideMenu was found
│   │  115 │                 var sideMenu = this.FindControl<SukiUI.Controls.SukiSideMenu>("SideMenu");
│   │  116 │                 _logger?.LogInformation("SideMenu control {Status}",
│   │  117 │                     sideMenu != null ? "found" : "not found");
│   │  118 │ 
│   │  119 │                 // If we have a side menu, check its binding
│   │  120 │                 if (sideMenu != null)
│   │  121 │                 {
│   │  122 │                     _logger?.LogDebug("SideMenu ItemsSource binding {Status}",
│   │  123 │                         sideMenu.ItemsSource != null ? "present" : "missing");
│   │  124 │                 }
│   │  125 │             }
│   │  126 │             catch (Exception ex)
│   │  127 │             {
│   │  128 │                 _logger?.LogError(ex, "Error in InitializeComponent");
│   │  129 │             }
│   │  130 │         }
│   │  131 │         private void TestMainContent()
│   │  132 │         {
│   │  133 │             try
│   │  134 │             {
│   │  135 │                 // Find the MainContent control
│   │  136 │                 var mainContent = this.FindControl<ContentControl>("MainContent");
│   │  137 │ 
│   │  138 │                 if (mainContent != null)
│   │  139 │                 {
│   │  140 │                     _logger?.LogInformation("MainContent control found, setting test content");
│   │  141 │ 
│   │  142 │                     // Create a simple test panel with obvious content
│   │  143 │                     var testPanel = new StackPanel();
│   │  144 │                     testPanel.Children.Add(new TextBlock
│   │  145 │                     {
│   │  146 │                         Text = "TEST CONTENT - If you can see this, the ContentControl is working",
│   │  147 │                         FontSize = 24,
│   │  148 │                         Foreground = Avalonia.Media.Brushes.Red,
│   │  149 │                         TextWrapping = Avalonia.Media.TextWrapping.Wrap
│   │  150 │                     });
│   │  151 │ 
│   │  152 │                     // Set it directly to the MainContent
│   │  153 │                     mainContent.Content = testPanel;
│   │  154 │ 
│   │  155 │                     _logger?.LogInformation("Test content has been set to MainContent");
│   │  156 │                 }
│   │  157 │                 else
│   │  158 │                 {
│   │  159 │                     _logger?.LogError("MainContent control was not found!");
│   │  160 │                 }
│   │  161 │             }
│   │  162 │             catch (Exception ex)
│   │  163 │             {
│   │  164 │                 _logger?.LogError(ex, "Error in TestMainContent");
│   │  165 │             }
│   │  166 │         }
│   │  167 │         private void TestSettingsView()
│   │  168 │         {
│   │  169 │             try
│   │  170 │             {
│   │  171 │                 _logger?.LogInformation("Creating SettingsView directly");
│   │  172 │ 
│   │  173 │                 // Get the MainContent control
│   │  174 │                 var mainContent = this.FindControl<ContentControl>("MainContent");
│   │  175 │ 
│   │  176 │                 if (mainContent != null)
│   │  177 │                 {
│   │  178 │                     // Create a SettingsView directly
│   │  179 │                     var settingsView = new Views.SettingsView();
│   │  180 │ 
│   │  181 │                     // Create a SettingsViewModel (which is needed by the SettingsView)
│   │  182 │                     var serviceProvider = App.Current.ApplicationLifetime
│   │  183 │                         .GetType()
│   │  184 │                         .GetProperty("Services")
│   │  185 │                         .GetValue(App.Current.ApplicationLifetime) as IServiceProvider;
│   │  186 │ 
│   │  187 │                     if (serviceProvider != null)
│   │  188 │                     {
│   │  189 │                         var settingsManager = serviceProvider.GetService(typeof(test.Infrastructure.ISettingsManager)) as test.Infrastructure.ISettingsManager;
│   │  190 │                         var settingsViewModel = new ViewModels.SettingsViewModel(settingsManager);
│   │  191 │ 
│   │  192 │                         // Set the DataContext
│   │  193 │                         settingsView.DataContext = settingsViewModel;
│   │  194 │ 
│   │  195 │                         // Set it as the content
│   │  196 │                         mainContent.Content = settingsView;
│   │  197 │ 
│   │  198 │                         _logger?.LogInformation("SettingsView directly set as content");
│   │  199 │                     }
│   │  200 │                     else
│   │  201 │                     {
│   │  202 │                         _logger?.LogError("ServiceProvider is null!");
│   │  203 │                     }
│   │  204 │                 }
│   │  205 │                 else
│   │  206 │                 {
│   │  207 │                     _logger?.LogError("MainContent control was not found!");
│   │  208 │                 }
│   │  209 │             }
│   │  210 │             catch (Exception ex)
│   │  211 │             {
│   │  212 │                 _logger?.LogError(ex, "Error in TestSettingsView");
│   │  213 │             }
│   │  214 │         }
│   │  215 │     }
│   │  216 │ }
│   └──────────────────────────────────────────────────────────────────────
├── 📄 Program.cs (676.00 B, 2025-03-11 09:48:27)
│   ┌──────────────────────────────────────────────────────────────────────
│   │ FILE CONTENT: Program.cs
│   ├──────────────────────────────────────────────────────────────────────
│   │    1 │ ﻿using Avalonia;
│   │    2 │ using System;
│   │    3 │ 
│   │    4 │ namespace test;
│   │    5 │ 
│   │    6 │ class Program
│   │    7 │ {
│   │    8 │     // Initialization code. Don't use any Avalonia, third-party APIs or any
│   │    9 │     // SynchronizationContext-reliant code before AppMain is called: things aren't initialized
│   │   10 │     // yet and stuff might break.
│   │   11 │     [STAThread]
│   │   12 │     public static void Main(string[] args) => BuildAvaloniaApp()
│   │   13 │         .StartWithClassicDesktopLifetime(args);
│   │   14 │ 
│   │   15 │     // Avalonia configuration, don't remove; also used by visual designer.
│   │   16 │     public static AppBuilder BuildAvaloniaApp()
│   │   17 │         => AppBuilder.Configure<App>()
│   │   18 │             .UsePlatformDetect()
│   │   19 │             .WithInterFont()
│   │   20 │             .LogToTrace();
│   │   21 │ }
│   └──────────────────────────────────────────────────────────────────────
├── 📄 ViewLocator.cs (798.00 B, 2025-03-12 11:28:27)
│   ┌──────────────────────────────────────────────────────────────────────
│   │ FILE CONTENT: ViewLocator.cs
│   ├──────────────────────────────────────────────────────────────────────
│   │    1 │ ﻿using Avalonia.Controls;
│   │    2 │ using Avalonia.Controls.Templates;
│   │    3 │ using System;
│   │    4 │ using test.ViewModels;
│   │    5 │ 
│   │    6 │ namespace test
│   │    7 │ {
│   │    8 │     public class ViewLocator : IDataTemplate
│   │    9 │     {
│   │   10 │         public Control? Build(object? param)
│   │   11 │         {
│   │   12 │             if (param is null)
│   │   13 │                 return null;
│   │   14 │ 
│   │   15 │             var name = param.GetType().FullName!.Replace("ViewModel", "View");
│   │   16 │             var type = Type.GetType(name);
│   │   17 │ 
│   │   18 │             if (type != null)
│   │   19 │             {
│   │   20 │                 return (Control)Activator.CreateInstance(type)!;
│   │   21 │             }
│   │   22 │             else
│   │   23 │             {
│   │   24 │                 return new TextBlock { Text = $"Not Found: {name}" };
│   │   25 │             }
│   │   26 │         }
│   │   27 │ 
│   │   28 │         public bool Match(object? data)
│   │   29 │         {
│   │   30 │             return data is ViewModelBase;
│   │   31 │         }
│   │   32 │     }
│   │   33 │ }
│   └──────────────────────────────────────────────────────────────────────
└── 📄 test.csproj (3.69 KB, 2025-03-12 15:07:44)
    ┌──────────────────────────────────────────────────────────────────────
    │ FILE CONTENT: test.csproj
    ├──────────────────────────────────────────────────────────────────────
    │    1 │ ﻿<Project Sdk="Microsoft.NET.Sdk">
    │    2 │   <PropertyGroup>
    │    3 │     <OutputType>WinExe</OutputType>
    │    4 │     <TargetFramework>net8.0</TargetFramework>
    │    5 │     <Nullable>enable</Nullable>
    │    6 │     <BuiltInComInteropSupport>true</BuiltInComInteropSupport>
    │    7 │     <ApplicationManifest>app.manifest</ApplicationManifest>
    │    8 │     <AvaloniaUseCompiledBindingsByDefault>true</AvaloniaUseCompiledBindingsByDefault>
    │    9 │   </PropertyGroup>
    │   10 │   <ItemGroup>
    │   11 │     <None Remove="Views\SettingsView.xaml" />
    │   12 │   </ItemGroup>
    │   13 │   <ItemGroup>
    │   14 │     <AvaloniaResource Include="Views\ConvertersView.xaml">
    │   15 │       <Generator>MSBuild:Compile</Generator>
    │   16 │     </AvaloniaResource>
    │   17 │     <AvaloniaResource Include="Views\SettingsView.xaml">
    │   18 │       <Generator>MSBuild:Compile</Generator>
    │   19 │     </AvaloniaResource>
    │   20 │   </ItemGroup>
    │   21 │ 
    │   22 │   <ItemGroup>
    │   23 │     <PackageReference Include="Antlr4.Runtime.Standard" Version="4.13.1" />
    │   24 │     <PackageReference Include="Antlr4BuildTasks" Version="12.10.0" />
    │   25 │     <PackageReference Include="Avalonia" Version="11.2.5" />
    │   26 │     <PackageReference Include="Avalonia.AvaloniaEdit" Version="11.1.0" />
    │   27 │     <PackageReference Include="Avalonia.Desktop" Version="11.2.5" />
    │   28 │     <PackageReference Include="Avalonia.ReactiveUI" Version="11.2.5" />
    │   29 │     <PackageReference Include="Avalonia.Skia" Version="11.2.5" />
    │   30 │     <PackageReference Include="Avalonia.Svg.Skia" Version="11.2.0.2" />
    │   31 │     <PackageReference Include="Avalonia.Themes.Fluent" Version="11.2.5" />
    │   32 │     <PackageReference Include="Avalonia.Fonts.Inter" Version="11.2.5" />
    │   33 │     <!--Condition below is needed to remove Avalonia.Diagnostics package from build output in Release configuration.-->
    │   34 │     <PackageReference Condition="'$(Configuration)' == 'Debug'" Include="Avalonia.Diagnostics" Version="11.2.5" />
    │   35 │     <PackageReference Include="Avalonia.Xaml.Behaviors" Version="11.2.0.14" />
    │   36 │     <PackageReference Include="Avalonia.Xaml.Interactions" Version="11.2.0.14" />
    │   37 │     <PackageReference Include="Avalonia.Xaml.Interactivity" Version="11.2.0.14" />
    │   38 │     <PackageReference Include="AvaloniaEdit.TextMate" Version="11.1.0" />
    │   39 │     <PackageReference Include="AvaloniaEdit.TextMate.Grammars" Version="0.10.12" />
    │   40 │     <PackageReference Include="ClosedXML" Version="0.104.2" />
    │   41 │     <PackageReference Include="CommunityToolkit.Mvvm" Version="8.4.0" />
    │   42 │     <PackageReference Include="DiffPlex" Version="1.7.2" />
    │   43 │     <PackageReference Include="Irony" Version="1.5.3" />
    │   44 │     <PackageReference Include="Material.Icons.Avalonia" Version="2.3.1" />
    │   45 │     <PackageReference Include="Microsoft.EntityFrameworkCore" Version="9.0.3" />
    │   46 │     <PackageReference Include="Microsoft.EntityFrameworkCore.Sqlite" Version="9.0.3" />
    │   47 │     <PackageReference Include="Microsoft.EntityFrameworkCore.Sqlite.Core" Version="9.0.3" />
    │   48 │     <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="9.0.3" />
    │   49 │     <PackageReference Include="Microsoft.Extensions.Logging" Version="9.0.3" />
    │   50 │     <PackageReference Include="NETStandard.Library" Version="2.0.3" />
    │   51 │     <PackageReference Include="NUlid" Version="1.7.2" />
    │   52 │     <PackageReference Include="ReactiveUI" Version="20.1.63" />
    │   53 │     <PackageReference Include="Serilog" Version="4.2.0" />
    │   54 │     <PackageReference Include="Serilog.Extensions.Logging" Version="9.0.0" />
    │   55 │     <PackageReference Include="Serilog.Formatting.Compact" Version="3.0.0" />
    │   56 │     <PackageReference Include="Serilog.Settings.Configuration" Version="9.0.0" />
    │   57 │     <PackageReference Include="Serilog.Sinks.Console" Version="6.0.0" />
    │   58 │     <PackageReference Include="Serilog.Sinks.Debug" Version="3.0.0" />
    │   59 │     <PackageReference Include="Serilog.Sinks.File" Version="6.0.0" />
    │   60 │     <PackageReference Include="SukiUI" Version="6.0.1" />
    │   61 │     <PackageReference Include="Ulid" Version="1.3.4" />
    │   62 │   </ItemGroup>
    │   63 │ </Project>
    └──────────────────────────────────────────────────────────────────────